<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArrayList 源码分析</title>
    <url>/2020/08/17/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p><code>ArrayList</code> 是一种以数组实现的 <code>List</code>，与数组相比，它具有动态扩展的能力，因此也可称之为动态数组。</p>
<p>在添加大量元素前，应用程序可以使用 <code>ensureCapacity</code> 操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<p>是 <code>Collection</code> 集合框架下 <code>List</code> 接口的一种实现。</p>
<p><img src="/2020/08/17/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Collection%E6%A1%86%E6%9E%B6.png" alt="Collection框架"></p>
<p>具体的继承体系如下：</p>
<blockquote>
<p>蓝色路径：继承<br>绿色路径： 接口实现</p>
</blockquote>
<p><img src="/2020/08/17/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Collection%E6%A1%86%E6%9E%B6.png" alt="ArrayList继承体系"></p>
<ul>
<li><code>ArrayList</code> 继承了 **<code>AbstractList</code>**，实现了 <code>List</code>。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能；</li>
<li><code>ArrayList</code> 实现了 **<code>RandomAccess</code> 接口<strong>， <code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持</strong>快速随机访问 ** 的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 **<code>Cloneable</code> 接口<strong>，即覆盖了函数 <code>clone()</code>，</strong>能被克隆 **；</li>
<li><code>ArrayList</code> 实现 **<code>java.io.Serializable</code> 接口<strong>，这意味着 <code>ArrayList</code><strong>支持序列化</strong>，</strong>能通过序列化去传输 **。</li>
</ul>
<h3 id="2-内部变量"><a href="#2-内部变量" class="headerlink" title="2 内部变量"></a>2 内部变量</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// 序列化IDserialVersionUID是用来验证版本一致性的字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default initial capacity.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 一个空数组，主要用于带参数构造函数初始话和读取序列化对象等（方便使用）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">   * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">   * first element is added.</span></span><br><span class="line"><span class="comment">   * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别：</span></span><br><span class="line"><span class="comment">   * 仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</span></span><br><span class="line"><span class="comment">   * 		当用户带参为0的构造，第一次add时，数组容量grow到1；</span></span><br><span class="line"><span class="comment">   *		当用户使用默认构造时，第一次add时，容量直接grow到DEFAULT_CAPACITY（10）；</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">   * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">   * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">   * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 当前数据对象存放地方，当前对象不参与序列化</span></span><br><span class="line"><span class="comment">// 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化</span></span><br><span class="line"><span class="comment">// ArraryList另外实现了序列化与反序列化</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 当前数组数组中的元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">	</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">   * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">   * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">   * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 数组最大可分配容量 </span></span><br><span class="line"><span class="comment">// 存储的最大容量也取决于运行Java代码的平台内存和JVM的堆比例</span></span><br><span class="line"><span class="comment">// 8个byte是用来存储元数据，用来描述这个数组的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合数组修改次数的标识（由AbstractList继承下来）（fail-fast机制）</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3 源码分析"></a>3 源码分析</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 无参（默认）构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> {</span><br><span class="line">    	<span class="comment">// 只有这个地方会引用DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    	<span class="comment">// 使用这个数组是在添加第一个元素的时候会扩容到默认大小10</span></span><br><span class="line">      <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">   *         is negative</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 当用户带参为0的构造，第一次add时，数组容量grow到1；</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> {</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {</span><br><span class="line">        	<span class="comment">// 如果传入的初始容量大于0，就新建一个数组存储元素</span></span><br><span class="line">          <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {</span><br><span class="line">          <span class="comment">// 使用EMPTY_ELEMENTDATA，在其他的多个地方可能会引用EMPTY_ELEMENTDATA</span></span><br><span class="line">          <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">   * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">   * iterator.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    	<span class="comment">// 集合转数组给elementData(toArray浅拷贝？) </span></span><br><span class="line">      elementData = c.toArray();</span><br><span class="line">      <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) {</span><br><span class="line">          <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        	<span class="comment">// 若c.toArray()返回的数组类型不是Object[]，则利用Arrays.copyOf(); 来构造一个大小为size的Object[]数组</span></span><br><span class="line">          <span class="comment">// 此时elementData是指向传入集合的内存，还需要创建新的内存区域深拷贝给elementData </span></span><br><span class="line">          <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">              elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// replace with empty array.</span></span><br><span class="line">          <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在数组最后添加新元素</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    	<span class="comment">// 确保数组已使用长度（size）加1之后足够存下 下一个数据</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    	<span class="comment">// 数组的下一个index存放传入元素。</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组指定位置插入新元素</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> {</span><br><span class="line">      rangeCheckForAdd(index);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 确保数组已使用长度（size）加1之后足够存下 下一个数据</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    	<span class="comment">// 将index及其之后的元素往后挪一位，则index位置处就空出来了</span></span><br><span class="line">      System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                       size - index);</span><br><span class="line">    	<span class="comment">// 数组的下一个index存放传入元素</span></span><br><span class="line">      elementData[index] = element;</span><br><span class="line">    	<span class="comment">// 数组长度加1</span></span><br><span class="line">      size++;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个结合元素</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    	<span class="comment">// 将集合c转为数组 </span></span><br><span class="line">      Object[] a = c.toArray();</span><br><span class="line">      <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    	<span class="comment">// 检查是否需要扩容</span></span><br><span class="line">      ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    	<span class="comment">// 将c中元素全部拷贝到数组的最后</span></span><br><span class="line">      System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    	<span class="comment">// 大小增加c的大小</span></span><br><span class="line">      size += numNew;</span><br><span class="line">    	<span class="comment">// 如果c不为空就返回true，否则返回false</span></span><br><span class="line">      <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置，添加一个集合元素</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    	<span class="comment">// 检查索引是否在范围内</span></span><br><span class="line">      rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">      Object[] a = c.toArray();</span><br><span class="line">      <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">      ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">		<span class="comment">// 原数组中需要平移的元素的数量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">// 将需要平移的数组元素向后平移数组长度</span></span><br><span class="line">          System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                           numMoved);</span><br><span class="line">		<span class="comment">// 将新的集合元素 拷贝目标数组中</span></span><br><span class="line">      System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">      size += numNew;</span><br><span class="line">      <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">      ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    	<span class="comment">// 这里就是DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和 EMPTY_ELEMENTDATA 最主要的区别，</span></span><br><span class="line">    	<span class="comment">// 如果是空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，就初始化为默认大小10</span></span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br><span class="line">        	<span class="comment">// 默认构造第一次add返回10</span></span><br><span class="line">          <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      }</span><br><span class="line">    	<span class="comment">// 带参为0构造第一次add返回 1 （0 + 1）</span></span><br><span class="line">      <span class="keyword">return</span> minCapacity;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    	<span class="comment">// 自增修改计数</span></span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">    	<span class="comment">// 当前数组容量小于需要的最小容量</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">// 准备扩容数组</span></span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">    	<span class="comment">// 获得当前数组容量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    	<span class="comment">// 新数组容量为1.5倍的旧数组容量</span></span><br><span class="line">    	<span class="comment">// 如果新容量发现比需要的容量还小，则以需要的容量为准</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">// 若newCapacity依旧小于minCapacity</span></span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">    	<span class="comment">// 如果新容量已经超过最大容量了，则使用最大容量</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    	<span class="comment">// 以新容量拷贝数组到一个新数组</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的元素</span></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    	<span class="comment">// 检查index范围</span></span><br><span class="line">      rangeCheck(index);</span><br><span class="line">		</span><br><span class="line">      modCount++;</span><br><span class="line">			<span class="comment">// 需要删除的元素</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 如果index不是最后一位，则将index之后的元素往前挪一位</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">    	<span class="comment">// 将最后一个元素删除，帮助GC</span></span><br><span class="line">      elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">		<span class="comment">// 返回旧值</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素值的元素，时间复杂度为O(n)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> {</span><br><span class="line">      <span class="keyword">if</span> (o == <span class="literal">null</span>) {</span><br><span class="line">        	<span class="comment">// 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            	<span class="comment">// 如果要删除的元素为null，则以null进行比较，使用 “==”</span></span><br><span class="line">              <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) {</span><br><span class="line">                  fastRemove(index);</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              }</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        	<span class="comment">// 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            	<span class="comment">// 如果要删除的元素不为null，则进行比较，使用 “equals()” 方法</span></span><br><span class="line">              <span class="keyword">if</span> (o.equals(elementData[index])) {</span><br><span class="line">                  fastRemove(index);</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">      modCount++;</span><br><span class="line">    	<span class="comment">// 如果index不是最后一位，则将index之后的元素往前挪一位</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除 数组中 集合c的元素</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> {</span><br><span class="line">    	<span class="comment">// 集合c 不能为null</span></span><br><span class="line">      Objects.requireNonNull(c);</span><br><span class="line">      <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除元素</span></span><br><span class="line"><span class="comment">// complement 为true表示删除数组中，c不包含的元素</span></span><br><span class="line"><span class="comment">// complement 为false表示删除数组中，c包含的元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="type">boolean</span> complement)</span> {</span><br><span class="line">      <span class="keyword">final</span> Object[] elementData = <span class="built_in">this</span>.elementData;</span><br><span class="line">      <span class="comment">// 使用读写两个指针同时遍历数组</span></span><br><span class="line">  		<span class="comment">// 读指针每次自增1，写指针放入元素的时候才加1</span></span><br><span class="line">  		<span class="comment">// 这样不需要额外的空间，只需要在原有的数组上操作就可以了</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        	<span class="comment">// 遍历整个数组，如果c中包含该元素，则把该元素放到写指针的位置（以complement为准）</span></span><br><span class="line">          <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">              <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                  elementData[w++] = elementData[r];</span><br><span class="line">      } <span class="keyword">finally</span> {</span><br><span class="line">          <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">          <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        	<span class="comment">// 正常来说r最后是等于size的，除非c.contains()抛出了异常</span></span><br><span class="line">          <span class="keyword">if</span> (r != size) {</span><br><span class="line">            	<span class="comment">// 如果c.contains()抛出了异常，则把未读的元素都拷贝到写指针之后</span></span><br><span class="line">              System.arraycopy(elementData, r,</span><br><span class="line">                               elementData, w,</span><br><span class="line">                               size - r);</span><br><span class="line">              w += size - r;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (w != size) {</span><br><span class="line">              <span class="comment">// clear to let GC do its work</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> w; i &lt; size; i++)</span><br><span class="line">                  elementData[i] = <span class="literal">null</span>;</span><br><span class="line">              modCount += size - w;</span><br><span class="line">            	<span class="comment">// 新大小等于写指针的位置（因为每写一次写指针就加1，所以新大小正好等于写指针的位置）</span></span><br><span class="line">              size = w;</span><br><span class="line">              modified = <span class="literal">true</span>;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> modified;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">// 更新数组指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> {</span><br><span class="line">    	<span class="comment">// 数组index检查</span></span><br><span class="line">      rangeCheck(index);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 取出要更新的位置的元素（旧值）</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    	<span class="comment">// 更新新值</span></span><br><span class="line">      elementData[index] = element;</span><br><span class="line">    	<span class="comment">// 返回旧值</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">// 查找数组</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">      rangeCheck(index);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> elementData(index);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h4><p><code>ArrayList</code> 实现了 <code>java.io.Serializable</code> 接口，但是自己定义了序列化和反序列化。这是因为 <code>ArrayList</code> 是基于数组实现，并且具有动态扩容特性，在这个过程当中会进行新老数组的拷贝，因此原来保存元素的数组不一定都会被使用，那么久没必要全部进行序列化。因此 <code>elementData</code> 数组使用 <code>transient</code> 修饰，可以防止被自动序列化。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">      <span class="keyword">throws</span> java.io.IOException{</span><br><span class="line">      <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    	<span class="comment">// 防止序列化期间数组元素有修改</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    	<span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">      s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    	<span class="comment">// 序列化数组包含元素数量，为了向后兼容</span></span><br><span class="line">      <span class="comment">// 两次将size写入流</span></span><br><span class="line">      s.writeInt(size);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Write out all elements in the proper order</span></span><br><span class="line">    	<span class="comment">// 按照顺序写入，只写入到数组包含元素的结尾，并不会把数组的所有容量区域全部写入</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) {</span><br><span class="line">          s.writeObject(elementData[i]);</span><br><span class="line">      }</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 判断是否触发Fast-Fail</span></span><br><span class="line">      <span class="keyword">if</span> (modCount != expectedModCount) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">      <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException {</span><br><span class="line">    	<span class="comment">// 设置数组引用空数组</span></span><br><span class="line">      elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">      <span class="comment">// 将流中的的非静态(non-static)和非瞬态(non-transient)字段读取到当前类</span></span><br><span class="line">      <span class="comment">// 包含 size</span></span><br><span class="line">      s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read in capacity</span></span><br><span class="line">    	<span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">      s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line">          <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        	<span class="comment">// 根据size计算容量</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> calculateCapacity(elementData, size);</span><br><span class="line">        	<span class="comment">// 用于调用另一个包中的实现专用方法，而不使用反射。TODO</span></span><br><span class="line">          SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        	<span class="comment">// 检查是否需要扩容</span></span><br><span class="line">          ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">          Object[] a = elementData;</span><br><span class="line">          <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) {</span><br><span class="line">            	<span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">              a[i] = s.readObject();</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p><code>ArrayList</code> 为什么要序列化两次？</p>
<blockquote>
<p>在序列化的代码中，<code>s.defaultWriteObject()</code>; 中 <code>size</code> 应该也被序列化了。为什么还要再单独调用 <code>s.writeInt(size)</code> 序列化一次呢？</p>
<p>其实是出于兼容性考虑。</p>
<p>旧版本的 JDK 中，<code>ArrayList</code> 实现不同，会对 <code>length</code> 字段序列化；而新版的 <code>JDK</code> 中，优化了实现，不再序列化 <code>length</code> 字段。如果去掉 <code>s.writeInt(size)</code>，那么新版 <code>JDK</code> 序列化的对象，在旧版本中无法正确反序列化了，因为缺少了 <code>length</code> 字段。</p>
</blockquote>
<h4 id="关于System-arraycopy-和Arrays-copyOf"><a href="#关于System-arraycopy-和Arrays-copyOf" class="headerlink" title="关于System.arraycopy()和Arrays.copyOf()"></a>关于 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code></h4><p>通过上面的源码可以知道两种实现数组复制的方法 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>，其中 <code>arraycopy</code> 方法实现数组自己复制自己；其中 <code>copyOf</code> 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组；</p>
<p><strong>联系：</strong> </p>
<ul>
<li>看两者源代码可以发现 <code>copyOf()</code> 内部调用了 <code>System.arraycopy()</code> 方法；</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置；</li>
<li><code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组</li>
</ul>
<h4 id="关于Fail-Fast机制"><a href="#关于Fail-Fast机制" class="headerlink" title="关于Fail-Fast机制"></a>关于 <code>Fail-Fast</code> 机制</h4><p><code>fail-fast</code> 机制，即快速失败机制，是 <code>Java</code> 集合 <code>(Collection)</code> 中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生 <code>fail-fast</code>，即抛出 <code>ConcurrentModificationException</code> 异常。<code>fail-fast</code> 机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测 <code>bug</code>。</p>
<blockquote>
<p>结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代操作时，需要比较操作前后 <code>modCount</code> 是否改变，如果改变了需要跑出 <code>ConcurrentModificationException</code></p>
</blockquote>
<h4 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] srgs)</span>{</span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">         System.out.printf(<span class="string">"Before add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line"></span><br><span class="line">         arrayList.add(<span class="number">1</span>);</span><br><span class="line">         arrayList.add(<span class="number">3</span>);</span><br><span class="line">         arrayList.add(<span class="number">5</span>);</span><br><span class="line">         arrayList.add(<span class="number">7</span>);</span><br><span class="line">         arrayList.add(<span class="number">9</span>);</span><br><span class="line">         System.out.printf(<span class="string">"After add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">"Printing elements of arrayList"</span>);</span><br><span class="line">         <span class="comment">// 三种遍历方式打印元素</span></span><br><span class="line">         <span class="comment">// 第一种：通过迭代器遍历</span></span><br><span class="line">         System.out.print(<span class="string">"通过迭代器遍历:"</span>);</span><br><span class="line">         Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class="line">         <span class="keyword">while</span>(it.hasNext()){</span><br><span class="line">             System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">         }</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第二种：通过随机索引值遍历</span></span><br><span class="line">         System.out.print(<span class="string">"通过索引值遍历:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++){</span><br><span class="line">             System.out.print(arrayList.get(i) + <span class="string">" "</span>);</span><br><span class="line">         }</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第三种：for循环遍历</span></span><br><span class="line">         System.out.print(<span class="string">"foreach循环遍历:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(Integer number : arrayList){</span><br><span class="line">             System.out.print(number + <span class="string">" "</span>);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// toArray用法</span></span><br><span class="line">         <span class="comment">// 第一种方式(最常用)</span></span><br><span class="line">         Integer[] integer = arrayList.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第二种方式(容易理解)</span></span><br><span class="line">         Integer[] integer1 = <span class="keyword">new</span> <span class="title class_">Integer</span>[arrayList.size()];</span><br><span class="line">         arrayList.toArray(integer1);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 抛出异常，java不支持向下转型</span></span><br><span class="line">         <span class="comment">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class="line">         <span class="comment">//integer2 = arrayList.toArray();</span></span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">         arrayList.add(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">         <span class="comment">// 删除指定位置上的元素</span></span><br><span class="line">         arrayList.remove(<span class="number">2</span>);    </span><br><span class="line">         <span class="comment">// 删除指定元素</span></span><br><span class="line">         arrayList.remove((Object)<span class="number">3</span>);</span><br><span class="line">         <span class="comment">// 判断arrayList是否包含5</span></span><br><span class="line">         System.out.println(<span class="string">"ArrayList contains 5 is: "</span> + arrayList.contains(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 清空ArrayList</span></span><br><span class="line">         arrayList.clear();</span><br><span class="line">         <span class="comment">// 判断ArrayList是否为空</span></span><br><span class="line">         System.out.println(<span class="string">"ArrayList is empty: "</span> + arrayList.isEmpty());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中遍历效率最高的是索引随机访问 <code>for</code>，<code>foreach</code> 和 <code>iterator</code> 效率差不多。主要原因是 <code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，可以快速随机访问集合，所以效率比较高。而 <code>foreach</code> 的底层是 <code>for+iterator</code> 实现的，所以效率差不多。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><ul>
<li><code>ArrayList</code> 基于数组方式实现，无容量的限制（会扩容）；</li>
<li>添加元素时可能要扩容（所以最好预判一下），删除元素时不会减少容量（若希望减少容量可以使用 <code>trimToSize()</code>），删除元素时，将删除掉的位置元素置为 <code>null</code>，下次 <code>gc</code> 就会回收这些元素所占的内存空间；</li>
<li>线程不安全；</li>
<li><code>add(int index, E element)</code>：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位；</li>
<li><code>get(int index)</code>：获取指定位置上的元素时，可以通过索引直接获取<code>（O(1)）</code>；</li>
<li><code>remove(Object o)</code> 需要遍历数组；</li>
<li><code>remove(int index)</code> 不需要遍历数组，只需判断 <code>index</code> 是否符合条件即可，效率比 <code>remove(Object o)</code> 高；</li>
<li><code>contains(E)</code> 需要遍历数组；</li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>B+Tree 与存储索引</title>
    <url>/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="1-硬盘存储知识"><a href="#1-硬盘存储知识" class="headerlink" title="1 硬盘存储知识"></a>1 硬盘存储知识</h1><p>计算机的主存基本都是随机访问存储器 <code>(Random-Access Memory，RAM)</code>，分为两类：静态随机访问存储器<code>（SRAM）</code>和动态随机访问存储器<code>（DRAM）</code>。<code>SRAM</code> 比 <code>DRAM</code> 快，但是也贵的多，一般作为 <code>CPU</code> 的高速缓存，<code>DRAM</code> 通常作为内存。这类存储器他们的结构和存储原理比较复杂，基本是使用电信号来保存信息的，不存在机械操作，所以访问速度非常快，具体的访问原理可以查看 <code>CSAPP</code>，另外，他们是易失的，即如果断电，保存 <code>DRAM</code> 和 <code>SRAM</code> 保存的信息就会丢失。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<p>内存的大小限制等原因，若要操作的数据集非常大，内存已经无法完全加载，则需要外部存储磁盘来进行数据存储。磁盘能够保存大量的数据，从 GB 一直到 TB 级，但是磁盘的读取速度比较慢，因为涉及到机械操作，读取速度为毫秒级，从 <code>DRAM</code> 读速度比从磁盘度快 <code>10万倍</code>，从 <code>SRAM</code> 读速度比从磁盘读快 <code>100万倍</code>。磁盘的结构：</p>
<p><img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220814165957102.png" alt="image-20220814165957102"></p>
<p>如上图，磁盘由盘片构成，每个盘片有两面，又称为盘面 <code>(Surface)</code>，这些盘面覆盖有磁性材料。盘片中央有一个可以旋转的主轴 <code>(spindle)</code>，他使得盘片以固定的旋转速率旋转，通常是 <code>5400</code> 转每分钟 <code>(Revolution Per Minute,RPM)</code> 或者是 <code>7200RPM</code>。磁盘包含多个这样的盘片并封装在一个密封的容器内。上图左，展示了一个典型的磁盘表面结构。每个表面是由一组成为磁道 <code>(track)</code> 的同心圆组成的，每个磁道被划分为了一组扇区 <code>(sector)</code>。每个扇区包含相等数量的数据位，通常是（512）子节。扇区之间由一些间隔 <code>(gap)</code> 隔开，不存储数据。</p>
<p><img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220814171109054.png" alt="image-20220814171109054"></p>
<p>如上图，磁盘用读 / 写头来读写存储在磁性表面的位，而读写头连接到一个传动臂的一端。通过沿着半径轴前后移动传动臂，驱动器可以将读写头定位到任何磁道上，这称之为<strong>寻道操作</strong>。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到位的值，也可以修改值。对磁盘的访问时间分为 <strong>寻道时间</strong>，<strong>旋转时间</strong>，以及<strong>传送时间</strong>。</p>
<p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗时，所以为了提高效率，应尽量减少磁盘 I/O，即减少读写操作。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。</strong> <strong>程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。</p>
<p>预读的长度一般为页<code>（page）</code>的整倍数。<strong>页是计算机管理存储器的逻辑块</strong>，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为 4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个 BTree/B+Tree 节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。为了达到这个目的，在实际实现中还需要使用如下技巧：</p>
<ul>
<li>每次新建一个节点的同时，直接申请一个页的空间 (512 或者 1024)，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。</li>
</ul>
<h1 id="2-BTree简介"><a href="#2-BTree简介" class="headerlink" title="2 BTree简介"></a>2 BTree 简介</h1><p>BTree（平衡多路查找树）是为磁盘等外存储设备设计的一种平衡查找树。</p>
<p>按照上节内容介绍的，系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p>KV 存储或者数据库中，也是以页为基础的基本单位进行磁盘管理（存储中的单页大小是系统页的倍数）。</p>
<p>BTree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 BTree，首先定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key 值互不相同。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>一棵 m 阶的 B-Tree 有如下特性：</p>
<ol>
<li>每个节点最多有 m 个孩子。</li>
<li>除了根节点和叶子节点外，其它每个节点至少有 Ceil (m/2)（向上取整）个孩子。</li>
<li>若根节点不是叶子节点，则至少有 2 个孩子。</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息。</li>
<li>每个非终端节点包含 n 个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>关键字的个数 n 满足：ceil (m/2)-1 &lt;= n &lt;= m-1</li>
<li>ki (i=1,…n) 为关键字，且关键字升序排序。</li>
<li>Pi (i=1,…n) 为指向子树根节点的指针。P (i-1) 指向的子树的所有节点关键字均小于 <code>ki</code>，但都大于 k (i-1)。</li>
</ol>
<p>BTree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 BTree：</p>
<p><img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820213724065.png" alt="image-20220820213724065"></p>
<p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为 17 和 35，P1 指针指向的子树的数据范围为小于 17，P2 指针指向的子树的数据范围为 <code>[17, 35)</code>，P3 指针指向的子树的数据范围为大于 35。</p>
<p>模拟查找<code>关键字29</code> 的过程：</p>
<ol>
<li>根据根节点找到<code>磁盘块1</code>，读入内存。<strong>【磁盘 I/O 操作第 1 次】</strong></li>
<li>比较<code>关键字29</code> 在区间 <code>[17, 35)</code>，找到<code>磁盘块1</code> 的指针 <code>P2</code>。</li>
<li>根据 <code>P2</code> 指针找到<code>磁盘块3</code>，读入内存。<strong>【磁盘 I/O 操作第 2 次】</strong></li>
<li>比较<code>关键字29</code> 在区间 <code>[26, 30)</code>，找到<code>磁盘块3</code> 的指针 <code>P2</code>。</li>
<li>根据 <code>P2</code> 指针找到<code>磁盘块8</code>，读入内存。<strong>【磁盘 I/O 操作第 3 次】</strong></li>
<li>在<code>磁盘块8</code> 中的关键字列表中找到<code>关键字29</code>。</li>
</ol>
<p>分析上面过程，发现需要 <code>3次</code>磁盘 I/O 操作，和 <code>3次</code>内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而 **<code>3次</code>磁盘 I/O 操作是影响整个 BTree 查找效率的决定因素 **。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h1 id="3-B-Tree"><a href="#3-B-Tree" class="headerlink" title="3 B+Tree"></a>3 B+Tree</h1><p>从上一节中的 BTree 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 BTree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。</p>
<p>B+Tree 是在 BTree 基础上的一种优化，使其更适合实现外存储索引结构。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值索引信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。减少磁盘的 I/O，提高查找效率。</p>
<h2 id="3-1-特性"><a href="#3-1-特性" class="headerlink" title="3.1 特性"></a>3.1 特性</h2><p>B+Tree 与 BTree 不同的几点：</p>
<ol>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ol>
<p>将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：</p>
<p><img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820215539180.png" alt="image-20220820215539180"></p>
<p>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：</p>
<ol>
<li>一种是对于主键的范围查找和分页查找；</li>
<li>一种是从根节点开始，进行随机查找；</li>
</ol>
<h2 id="3-2-B-Tree的创建与数据插入"><a href="#3-2-B-Tree的创建与数据插入" class="headerlink" title="3.2 B+Tree的创建与数据插入"></a>3.2 B+Tree 的创建与数据插入</h2><p>假设需要创建 3 阶 B+Tree：</p>
<blockquote>
<p>Max Key         = M - 1 = 3<br>Min Key          = (M / 2) - 1 = 1<br>Max Children = 4<br>Min Children  = M / 2 = 2</p>
</blockquote>
<p>创建 B+Tree, 依次插入值：<code>1, 4 ,7, 10, 17, 21, 31, 25, 19, 20, 22, 42</code></p>
<p>首先定义一颗空树，然后依次新增，新增流程如下：</p>
<p>依次插入 1、4、7、10</p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820222046768.png" alt="image-20220820222046768" style="zoom: 50%;">

<p>此时结点关键字已经达到 M（4）个的要求，若继续插入 17，则超过了 <code>Max Children = 4</code> 的规定，此时需要对节点进行分裂，分裂成树形结构，数据保存在 LeafNode 中，索引保存在 IndexNode 中。LeafNode 之间形成单向链表。</p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820222954418.png" alt="image-20220820222954418" style="zoom: 50%;">

<p>继续插入 21、31，新增 31 时，右节点则超过最大阶数 4，则需要继续分裂成两个 LeafNode，同时索引也需要更新。</p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820224127106.png" alt="image-20220820224127106" style="zoom: 50%;">

<p>继续新增 25、19</p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820225800977.png" alt="image-20220820225800977" style="zoom:50%;">

<p>继续新增 20、22，需要注意，此时不经超过了 <code>Max Children = 4</code> 的规定，Root 中，也超过了 <code>Max Key = M - 1 = 3</code> 的规定需要对 Root 进行分裂，分裂成两个 IndexNode。前面提到过，在 B+Tree 中除了 LeafNode，其他的 Node 存储的都是索引，Root 也是特殊的 IndexNode，所以不应该存在重复的索引，没有意义，因此在 LeafNode 中的 20 的索引，应该删除，具体步骤如下：</p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820232047245.png" alt="image-20220820232047245" style="zoom:50%;">

<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820232123482.png" alt="image-20220820232123482" style="zoom:50%;">

<p>继续新增 42，最终 B+Tree 结构如下：</p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820232356586.png" alt="image-20220820232356586" style="zoom: 50%;">

<h2 id="3-3-B-Tree的数据删除"><a href="#3-3-B-Tree的数据删除" class="headerlink" title="3.3 B+Tree的数据删除"></a>3.3 B+Tree 的数据删除</h2><p>本节介绍 B+Tree 的删除流程，复用上节的例子，对以下 B+Tree 依次删除：<code>31、42、7、10、17</code></p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220820232356586.png" alt="image-20220820232356586" style="zoom: 50%;">

<p>删除 31 的过程中，即没有打破索引，也没有导致结点关键字少于最小关键字个数，所以整棵树并没有大的改动。</p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220821212846585.png" alt="image-20220821212846585" style="zoom: 50%;">

<p>我们删除 42 的时候，结点最关键字小于最小关键字个数。此时就需要借结点或者合并结点。针对删除 42，我们会发现，他的左兄弟结点关键字个数 3 大于最小关键字个数 2，所以可以借用。</p>
<p>借用规则：<strong>借用左兄弟最大关键字或者右兄弟最小关键字，如果是借用左兄弟，则更新左兄弟对应父结点的索引值 (因为最大关键字被借走)， 如果借用右兄弟则更新当前结点对应父结点的索引值 (因为借过来的肯定比当前索引值大)。</strong></p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220821213419714.png" alt="image-20220821213419714" style="zoom:50%;">

<p>继续删除 7，LeafNode 关键字个数小于最小值，且最有兄弟结点的关键字个数无法外借 (因为已经是最少关键字 2)，此时只能进行合并。</p>
<p>合并规则：<strong>如果合并之后索引结点孩子不足 2，则移除索引结点，合并结点充当新的索引结点，树的高度 - 1，如果合并之后，索引结点孩子大于等于 2， 则将被合并结点对应父结点的索引值移除。</strong></p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220821214247494.png" alt="image-20220821214247494" style="zoom:50%;">

<p>最后删除 10、17，删除 17 时，也触发合并流程，且更新索引时，索引节点也需要合并，索引结点的合并后，树的高度 - 1，并且更新根结点。</p>
<img src="/2023/08/14/B-Tree%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/image-20220821220406095.png" alt="image-20220821220406095" style="zoom:50%;">

<h2 id="3-4-Java实现"><a href="#3-4-Java实现" class="headerlink" title="3.4 Java实现"></a>3.4 Java 实现</h2><p>参见 git: <a href="https://github.com/MarkHe1222/BPlusTree">https://github.com/MarkHe1222/BPlusTree</a></p>
<h2 id="3-5-MySql为什么选择B-Tree"><a href="#3-5-MySql为什么选择B-Tree" class="headerlink" title="3.5 MySql为什么选择B+Tree"></a>3.5 MySql 为什么选择 B+Tree</h2><ol>
<li><p>B+Tree 是 B TREE 的变种，B TREE 能解决的问题，B+TREE 也能够解决（降低树的⾼度，增⼤节点存储数据量）</p>
</li>
<li><p>B+Tree 扫库和扫表能⼒更强。如果我们要根据索引去进⾏数据表的扫描，对 BTree 进⾏扫描，需要把整棵树遍历⼀遍，⽽ B+Tree 只需要遍历他的所有叶⼦节点即可（叶⼦节点之间有引⽤）</p>
</li>
<li><p>B+Tree 磁盘读写能⼒更强。他的根结点和索引结点不保存数据区，所以根结点和索引结点同样⼤⼩的情况下，保存的关键字要⽐ BTree 要多。⽽叶⼦结点不保存索引结点引⽤，能⽤于保存更多的关键字和数据。所以，B+Tree 读写⼀次磁盘加载的关键字⽐ BTree 更多。</p>
</li>
<li><p>B+Tree 排序能⼒更强。B+Tree 天然具有排序功能。</p>
</li>
<li><p>B+Tree 查询性能稳定。B+Tree 数据只保存在叶⼦节点，每次查询数据，查询 IO 次数⼀定是稳定的。但是在 BTree 如果根节点命中直接返回，确实效率更⾼。</p>
</li>
</ol>
<h2 id="3-6-B-Tree与LSM-Tree对比"><a href="#3-6-B-Tree与LSM-Tree对比" class="headerlink" title="3.6 B+Tree与LSM-Tree对比"></a>3.6 B+Tree 与 LSM-Tree 对比</h2><table>
<thead>
<tr>
<th>存储引擎</th>
<th> B+Tree</th>
<th align="left">LSM-Tree</th>
<th> 备注</th>
</tr>
</thead>
<tbody><tr>
<td>优势</td>
<td>读取更快</td>
<td align="left">写入更快</td>
<td></td>
</tr>
<tr>
<td>写放大</td>
<td> 1. 数据和 WAL 2. 更改数据时多次覆盖整个 Page</td>
<td align="left">1. 数据和 WAL 2. Compaction</td>
<td>SSD 不能过多擦除。因此 SSD 内部的固件中也多用日志结构来减少随机写。</td>
</tr>
<tr>
<td>写吞吐</td>
<td>相对较低，大量随机写</td>
<td align="left">相对较高：1. 较低的写放大（取决于数据和配置）2. 顺序写入；3. 更为紧凑</td>
<td></td>
</tr>
<tr>
<td>压缩率</td>
<td>存在较多内部碎片</td>
<td align="left"> 1. 更加紧凑，没有碎片；2. 压缩率更大（共享前缀）</td>
<td>但 Compaction 不及时会造成 LSM-Tree 存在很多垃圾</td>
</tr>
<tr>
<td>后台流量</td>
<td>更稳定且可预测，不会受后台 Compaction 突发流量影响</td>
<td align="left"> 1. 写吞吐过高，Compaction 跟不上，会进一步加重读放大； 2. 由于外存总带宽有限，Compaction 会影响读写吞吐；3. 随着数据越来越多，Compaction 对正常写影响越来越大。</td>
<td>RocksDB 写入太过快会引起 write stall，即限制写入，以期尽快 Compaction 将数据下沉。</td>
</tr>
<tr>
<td>存储放大</td>
<td>有些 Page 没有用满</td>
<td align="left">同一个 Key 存多遍</td>
<td></td>
</tr>
<tr>
<td>并发控制</td>
<td> 1. 同一个 Key 只存在一个地方；2. 树结构容易加范围锁</td>
<td align="left">同一个 Key 会存多遍，一般使用 MVCC 进行控制</td>
<td> B+Tree（例如 innodb）在使用中日志记录相同键的多个版本，能够提供更强大的事务语义</td>
</tr>
</tbody></table>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p> 一般来说，存储索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><p><a href="https://www.cnblogs.com/xiaoxi/p/6894610.html">B+Tree 原理及 mysql 的索引分析</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/vincently/p/4526560.html">【经典数据结构】B 树与 B + 树</a>]</p>
</li>
<li><p><a href="https://www.talkwithtrend.com/Article/252785">DB 存储引擎：B-Trees 存储引擎详细分解</a></p>
</li>
<li><p><a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">磁盘 I/O 那些事</a></p>
</li>
<li><p><a href="https://developer.aliyun.com/article/983989">BTree 与 B+Tree 图文详解</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_33171970/article/details/88395278?spm=1001.2101.3001.6650.11&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-11-88395278-blog-78377026.t0_eslanding_v1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-11-88395278-blog-78377026.t0_eslanding_v1&amp;utm_relevant_index=14">B + 树的 Java 实现 (B+ Tree)</a></p>
</li>
<li><p><a href="https://www.javazhiyin.com/70714.html">B+Tree 实现图解</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=DqcZLulVJ0M">B+ tree creation example</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=pGOdeCpuwpI&amp;t=1s">B+ tree deletion| with example</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV16N411X7y8/?spm_id_from=333.788.recommend_more_video.3&amp;vd_source=3aa61749be95c9972786d32be208b4e0">基于 B+ Tree 的简单 KV 数据库</a></p>
</li>
<li><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>算法</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Protobuf 详解</title>
    <url>/2023/11/14/Google-Protobuf%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p><code>Protobuf</code> 是由 <code>Google</code> 设计的一种高效、轻量级的信息描述格式，起初是在 <code>Google</code> 内部使用，后面开源，它具有语言中立、平台中立、高效、可扩展等特性，它非常适合用来做数据存储、<code>RPC</code> 数据交换等。与 <code>json</code>、<code>xml</code> 相比，<code> Protobuf</code> 的编码长度更短、传输效率更高，其实严格意义上讲，<code>json</code>、<code>xml</code>、并非是一种「<strong>编码</strong>」，而只能称之为「<strong>格式</strong>」，<code>json</code>、<code>xml</code> 的内容本身都是字符形式，它们的编码采用的是 <code>ASCII</code> 编码。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>xml</th>
<th>json</th>
<th>protobuf</th>
</tr>
</thead>
<tbody><tr>
<td> 数据结构</td>
<td>结构一般复杂</td>
<td>结构简单</td>
<td>结构比较复杂</td>
</tr>
<tr>
<td>数据存储方式</td>
<td>文本</td>
<td>文本</td>
<td>二进制</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>大</td>
<td>一般</td>
<td>小</td>
</tr>
<tr>
<td>解析效率</td>
<td>慢</td>
<td>一般</td>
<td>快</td>
</tr>
<tr>
<td>跨语言支持</td>
<td>非常多</td>
<td>多</td>
<td>一般</td>
</tr>
<tr>
<td>开发成本</td>
<td>比较繁琐</td>
<td>非常简单</td>
<td>一般</td>
</tr>
<tr>
<td>学习成本</td>
<td>一般</td>
<td>低</td>
<td>一般</td>
</tr>
</tbody></table>
<p>一旦定义了要处理的数据的数据结构之后，就可以利用 <code>Protobuf</code> 的代码生成工具生成相关的代码。只需使用 <code>Protobuf</code> 对数据结构进行一次描述，即可利用各种不同语言 (<code>proto3</code> 支持 <code>C++、Java、Python、Go、Ruby、Objective-C、C#</code>) 或从各种不同流中对你的结构化数据轻松读写。</p>
<p>本文讲述 <code>Protobuf</code> 的底层编码原理，以便于了解 <code>Protobuf</code> 为什么编码长度短并且扩展性强，与此同时我们也将了解到它有哪些不足？</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h1><h2 id="2-1-关于版本"><a href="#2-1-关于版本" class="headerlink" title="2.1 关于版本"></a>2.1 关于版本</h2><p><code>Protobuf</code> 有两个大版本，<code>proto2</code> 和 <code>proto3</code>，同比于 <code>python2.x</code> 和 <code>python3.x</code> 版本。初学者建议直接学习 <code>proto3</code> 版本。</p>
<p><code>proto3</code> 相对于 <code>proto2</code> 而言，简而言之是支持了更多的语言（<code>Ruby、C#</code>等）、删除了一些复杂的语法和特性、引入了更多的约定等。</p>
<blockquote>
<p>与 json 开箱即用不一样的是，protobuf 需要依赖于工具包编译成 <code>java</code> 文件或者 <code>go</code> 文件等，所以需要关注 protobuf 的版本</p>
</blockquote>
<h2 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h2><h3 id="2-2-1-安装"><a href="#2-2-1-安装" class="headerlink" title="2.2.1 安装"></a>2.2.1 安装</h3><p>使用 <code>proto</code> 之前需要先安装编译器，<a href="https://developers.google.com/protocol-buffers/docs/downloads">官方下载地址</a>，具体安装步骤可自行搜索。可在控制台使用以下命令检查是否安装成功：</p>
<blockquote>
<p>mark.hct@ ~ % protoc –version<br>libprotoc 3.21.12</p>
</blockquote>
<blockquote>
<p> 也可以通过在 ideal 安装 <strong>Protobuf Support</strong>，之后通过 maven 来编译 proto 文件</p>
</blockquote>
<h3 id="2-2-2-proto文件"><a href="#2-2-2-proto文件" class="headerlink" title="2.2.2 proto文件"></a>2.2.2 proto 文件</h3><p>在 <code>proto</code> 文件中，需要定义程序中需要处理的结构化数据。其中结构化数据被称为 <code>Message</code>。<code>proto</code> 文件非常类似于 java 中的 bean。</p>
<blockquote>
<p><code>proto</code> 文件对应序列化理论中的 <code>IDL(Interface description language)</code> 接口描述语言</p>
</blockquote>
<p>定义一个 Test.proto 文件</p>
<figure class="highlight protobuf"><table><tbody><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">// PB协议版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/any.proto"</span>; <span class="comment">// 引用外部的message，可以是本地的，也可以是此处比较特殊的 Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test; <span class="comment">// 包名，其他 proto 在引用此 proto 的时候，就可以使用 test.protobuf.PersonTest 来使用，</span></span><br><span class="line"><span class="comment">// 注意：和下面的 java_package 是两种易混淆概念，同时定义的时候，java_package 具有较高的优先级</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">"test"</span>; <span class="comment">// 生成类的包名，注意：会在指定路径下按照该包名的定义来生成文件夹</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"PersonTestProtos"</span>; <span class="comment">// 生成类的类名，注意：下划线的命名会在编译的时候被自动改为驼峰命名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">PersonTest</span> {</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">1</span>; <span class="comment">// int 类型</span></span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>; <span class="comment">// string 类型</span></span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">  Sex sex = <span class="number">4</span>; <span class="comment">// 枚举类型</span></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phone = <span class="number">5</span>; <span class="comment">// 引用下面定义的 PhoneNumber 类型的 message</span></span><br><span class="line">  map&lt;<span class="type">string</span>, <span class="type">string</span>&gt; tags = <span class="number">6</span>; <span class="comment">// map 类型</span></span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">7</span>; <span class="comment">// 使用 google 的 any 类型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个枚举</span></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Sex</span> {</span><br><span class="line">    DEFAULT = <span class="number">0</span>;</span><br><span class="line">    MALE = <span class="number">1</span>;</span><br><span class="line">    Female = <span class="number">2</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个 message</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> {</span><br><span class="line">    <span class="type">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">PhoneType</span> {</span><br><span class="line">      MOBILE = <span class="number">0</span>;</span><br><span class="line">      HOME = <span class="number">1</span>;</span><br><span class="line">      WORK = <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="message语法说明（部分）"><a href="#message语法说明（部分）" class="headerlink" title="message语法说明（部分）"></a>message 语法说明（部分）</h4><p>1、 <code>proto3</code> 中，枚举的第一个常量名的编号必须为 <code>0</code>；</p>
<blockquote>
<p>由于 proto3 的默认值规则进行了调整，枚举的默认值为第一个，所以必须将第一个常量的标号设置为 0，但是这和业务有时是冲突的，此时，将第一个常量设置为 <code>xx_UNSPECIFIED=0</code>，如：<code>ENUM_TYPE_UNSPECIFIED = 0</code></p>
</blockquote>
<p>2、同一个 proto 文件中，多个枚举之间不允许定义相同的常量名</p>
<figure class="highlight protobuf"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">IDE1</span> {</span><br><span class="line">    IDEA = <span class="number">0</span>;</span><br><span class="line">    ECLIPSE = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">IDE2</span> {</span><br><span class="line">    IDEA = <span class="number">7</span>;</span><br><span class="line">    ECLIPSE = <span class="number">8</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>​		此时会报错，<code>IDEA is already defined in "xxx"</code></p>
<p>3、 Any 理解</p>
<p><code>google.protobuf.Any</code> 可以理解为 <code>java</code> 中的 <code>object</code>，但又和 <code>object</code> 不同。<code>Any</code> 不是所有的 <code>Message</code> 的父类，而 <code>object</code> 是所有类的父类。如以下示例代码：</p>
<p><code>Java Api</code> 的代码为：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiResult</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对应的 <code>proto</code> 定义为:</p>
<figure class="highlight protobuf"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">ApiResult</span> {</span><br><span class="line">    <span class="type">int32</span> code = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> error = <span class="number">2</span>;</span><br><span class="line">    google.protobuf.Any data = <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>protobuf</code> 提供了更多选项和数据类型，本文不做详细介绍，感兴趣可以参考<a href="https://developers.google.com/protocol-buffers/docs/proto3">这里</a></p>
<h3 id="2-2-3-编译"><a href="#2-2-3-编译" class="headerlink" title="2.2.3 编译"></a>2.2.3 编译</h3><p>从控制台进入 <code>proto</code> 文件所在路径，通过 <code>protoc</code> 进行编译得到对应的 <code>java</code> 文件拷贝到项目中使用。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">protoc -I=$path --java_out=$path $path/$file</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>参数说明：</p>
<ul>
<li>-I /-proto_path：指定.proto 文件所在的路径</li>
<li>–java_out：编译成 java 文件时，标明输出目标路径</li>
<li> $path/$file：指定需要编译的.proto 文件</li>
</ul>
</blockquote>
<h3 id="2-2-4-项目使用"><a href="#2-2-4-项目使用" class="headerlink" title="2.2.4 项目使用"></a>2.2.4 项目使用</h3><ul>
<li><p>对于 <code>protoc</code> 编译生成的 <code>java</code> 代码实现序列化和反序列化，需要在工程中添加 <code>protobuf-java</code> 的依赖</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.21.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>可以使用多种方式进行序列化和反序列化</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.protobuf.ByteString;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;</span><br><span class="line"><span class="keyword">import</span> test.PersonTestProtos.PersonTest.PhoneNumber.PhoneType;</span><br><span class="line"><span class="keyword">import</span> test.PersonTestProtos.PersonTest.Sex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ProtoTest.java v 0.1 2023/1/15 21:53 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtoTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">/** Step1：生成 personTest 对象 */</span></span><br><span class="line">            PersonTestProtos.PersonTest.<span class="type">Builder</span> <span class="variable">personBuilder</span> <span class="operator">=</span> PersonTestProtos.PersonTest.newBuilder();</span><br><span class="line">            <span class="comment">// personTest 赋值</span></span><br><span class="line">            personBuilder.setName(<span class="string">"cxk"</span>);</span><br><span class="line">            personBuilder.setEmail(<span class="string">"cxk@gmail.com"</span>);</span><br><span class="line">            personBuilder.setSex(Sex.MALE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内部的 PhoneNumber 构造器</span></span><br><span class="line">            PersonTestProtos.PersonTest.PhoneNumber.<span class="type">Builder</span> <span class="variable">phoneNumberBuilder</span> <span class="operator">=</span> PersonTestProtos.PersonTest.PhoneNumber.newBuilder();</span><br><span class="line">            <span class="comment">// PhoneNumber 赋值</span></span><br><span class="line">            phoneNumberBuilder.setType(PhoneType.MOBILE);</span><br><span class="line">            phoneNumberBuilder.setNumber(<span class="string">"138xxxx"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// personTest 设置 PhoneNumber</span></span><br><span class="line">            personBuilder.addPhone(phoneNumberBuilder);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成 personTest 对象</span></span><br><span class="line">            PersonTestProtos.<span class="type">PersonTest</span> <span class="variable">personTest</span> <span class="operator">=</span> personBuilder.build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** Step2：序列化和反序列化 */</span></span><br><span class="line">            <span class="comment">// 方式一 byte[]：</span></span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = personTest.toByteArray();</span><br><span class="line">            PersonTestProtos.<span class="type">PersonTest</span> <span class="variable">personTestResult1</span> <span class="operator">=</span> PersonTestProtos.PersonTest.parseFrom(bytes);</span><br><span class="line">            System.out.printf(<span class="string">"反序列化得到的信息，姓名：%s，性别：%d，手机号：%s%n"</span>, personTestResult1.getName(), personTest.getSexValue(),</span><br><span class="line">                    personTest.getPhone(<span class="number">0</span>).getNumber());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式二 ByteString：</span></span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">ByteString</span> <span class="variable">byteString</span> <span class="operator">=</span> personTest.toByteString();</span><br><span class="line">            System.out.println(byteString.toString());</span><br><span class="line">            <span class="comment">// 反序列化</span></span><br><span class="line">            PersonTestProtos.<span class="type">PersonTest</span> <span class="variable">personTestResult2</span> <span class="operator">=</span> PersonTestProtos.PersonTest.parseFrom(byteString);</span><br><span class="line">            System.out.printf(<span class="string">"反序列化得到的信息，姓名：%s，性别：%d，手机号：%s%n"</span>, personTestResult2.getName(), personTest.getSexValue(),</span><br><span class="line">                    personTest.getPhone(<span class="number">0</span>).getNumber());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式三 InputStream</span></span><br><span class="line">            <span class="comment">// 粘包,将一个或者多个protobuf 对象字节写入 stream</span></span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            personTest.writeDelimitedTo(byteArrayOutputStream);</span><br><span class="line">            <span class="comment">// 反序列化，从 steam 中读取一个或者多个 protobuf 字节对象</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">            PersonTestProtos.<span class="type">PersonTest</span> <span class="variable">personTestResult3</span> <span class="operator">=</span> PersonTestProtos.PersonTest.parseDelimitedFrom(byteArrayInputStream);</span><br><span class="line">            System.out.printf(<span class="string">"反序列化得到的信息，姓名：%s，性别：%d，手机号：%s%n"</span>, personTestResult3.getName(), personTest.getSexValue(),</span><br><span class="line">                    personTest.getPhone(<span class="number">0</span>).getNumber());</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h1><h2 id="3-1-protobuf数据结构"><a href="#3-1-protobuf数据结构" class="headerlink" title="3.1 protobuf数据结构"></a>3.1 protobuf 数据结构</h2><p>1、采用 <code>TLV</code> 存储方式，即 <code>Tag-Length-Value</code>（标识 - 长度 - 字段值）；<br>2、不需要分隔符就能分开字段，较少了分隔符的使用；<br>3、各字段存储得非常紧凑，存储空间利用率非常高；<br>4、若字段没有被设置字段值，那么该字段在序列化时的数据是完全不存在的，即不需要要编码；</p>
<p><img src="/2023/11/14/Google-Protobuf%E8%AF%A6%E8%A7%A3/image-20230115235320120.png" alt="image-20230115235320120"></p>
<blockquote>
<ul>
<li>Tag：字段标识号，用户表示字段；</li>
<li>Length：Value 的字段长度；</li>
<li>Value：消息字段经过编码后的值；</li>
</ul>
</blockquote>
<h2 id="3-2-protobuf数据组织"><a href="#3-2-protobuf数据组织" class="headerlink" title="3.2 protobuf数据组织"></a>3.2 protobuf 数据组织</h2><p>首先来看一个例子，假设客户端和服务端使用 <code>protobuf</code> 作为数据交换格式，<code>proto</code> 的具体定义为：</p>
<figure class="highlight protobuf"><table><tbody><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> pbTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span> {</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Request</code> 中包含了一个名称为 <code>age</code> 的字段，客户端和服务端双方都用同一份相同的 <code>proto</code> 文件是没有任何问题的，假设客户端自己将 <code>proto</code> 文件做了修改，修改后的 <code>proto</code> 文件如下：</p>
<figure class="highlight protobuf"><table><tbody><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> pbTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span> {</span><br><span class="line">    <span class="type">int32</span> age_test = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这种情形下，服务端不修改应用程序仍能够正确地解码，原因在于序列化后的 <code>Protobuf</code> 没有使用字段名称，而仅仅采用了字段编号，与 <code>json xml</code> 等相比，<code>protobuf</code> 不是一种完全自描述的协议格式，即接收端在没有 <code>proto</code> 文件定义的前提下是无法解码一个 <code>protobuf</code> 消息体。与此相对的，<code>json xml</code> 等协议格式是完全自描述的，拿到了 <code>json</code> 消息体，便可以知道这段消息体中有哪些字段，每个字段的值分别是什么，其实对于客户端和服务端通信双方来说，约定好了消息格式之后完全没有必要在每一条消息中都携带字段名称，<code>protobuf</code> 在通信数据中移除字段名称，这可以大大降低消息的长度，提高通信效率。对于不同数据类型采用不同的序列化方式（编码方式 &amp; 数据存储方式）如下表：</p>
<table>
<thead>
<tr>
<th>wire_type</th>
<th> 编码方式</th>
<th>编码长度</th>
<th>存储方式</th>
<th>代表的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td> 0</td>
<td>Vaint（负数时以 Zigzag 辅助编码）</td>
<td>变长 (1-10 个字节)</td>
<td>T - V</td>
<td>int32, int64, unit32, unit64, bool, enum, sint32, sint64 (负数时使用)</td>
</tr>
<tr>
<td>1</td>
<td>64-bit</td>
<td> 固定 8 个字节</td>
<td> T - V</td>
<td>fixed64, sfixed64, double</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimi</td>
<td> 变长</td>
<td> T - L - V</td>
<td>string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td>3</td>
<td>Start group</td>
<td> 已弃用</td>
<td>已弃用</td>
<td> Groups（已弃用）</td>
</tr>
<tr>
<td>4</td>
<td>End group</td>
<td> 已弃用</td>
<td>已弃用</td>
<td> Groups（已弃用）</td>
</tr>
<tr>
<td>5</td>
<td>32-bit</td>
<td> 固定 4 个字节</td>
<td> T - V</td>
<td>Fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<p>对于 <code>int32, int64, uint32</code> 等数据类型在序列化之后都会转为 <code>Varint</code> 编码，除去两种已标记为<code>已废弃(deprecated)</code> 的类型，目前 <code>Protobuf</code> 在序列化之后的消息类型 <code>(wire_type)</code> 总共有 4 种，<code>Protobuf </code>除了存储字段的值之外，还存储了字段的编号以及字段在通信线路上的格式类型 <code>(wire-type)</code>， 具体的存储方式为:</p>
<blockquote>
<p><strong>field_number &lt;&lt; 3 | wire_type</strong></p>
</blockquote>
<p>即将字段标号逻辑左移 3 位，然后与该字段的 <code>wire type</code> 的编号按位或，在上表中可以看到，<code>wire type </code>总共有 6 种类型，因此可以用 3 位二进制来标识，所以低 3 位实际上存储了其后所跟的数据的<code> wire type</code>，接收端可以利用这些信息，结合 <code>proto</code> 文件来解码消息结构体。<br>以上面 <code>proto</code> 为例来看一段 <code>Protobuf</code> 实际序列化之后的完整二进制数据，假设 <code>age</code> 为 5，由于 <code>age</code> 在 <code>proto</code> 文件中定义的是 int32 类型，因此序列化之后它的 <code>wire_type</code> 为 0，其字段编号为 1，因此按照上面的计算方式，即<code> 1 &lt;&lt; 3 | 0</code>，所以其类型和字段编号的信息只占 1 个字节，即<code> 00001000</code>，后面跟上字段值 5 的<code> Varint</code> 编码，所以整个结构体序列化之后为<code>（T - V格式）</code>：</p>
<img src="/2023/11/14/Google-Protobuf%E8%AF%A6%E8%A7%A3/image-20230116002742031.png" alt="image-20230116002742031" style="zoom: 50%;">

<p>有了字段编号和<code> wire type</code>，其后所跟的数据的长度便是确定的，因此 <code>Protobuf</code> 是一种非常紧密的数据组织格式，其不需要特别地加入额外的分隔符来分割一个消息字段，这可大大提升通信的效率，规避冗余的数据传输。</p>
<h2 id="3-3-Varint编码"><a href="#3-3-Varint编码" class="headerlink" title="3.3 Varint编码"></a>3.3 Varint 编码</h2><p>普通的 <code>int</code> 数据类型，无论值的大小，所占用的存储空间都是相等的，从这点这出发考虑根据数值大小来动态地占用存储空间，使得值比较小的数字占用较少的字节数，值相对比较大的数字占用比较多的字节数，这就是<strong>变长整型编码</strong>的基本思想，采用变长整型编码的数字，其占用的字节数不是完全一致的，为了达到这个目的，<code>Varint</code> 编码使用每个字节的最高有效位作为标志位，而剩余的 7 位以二进制补码的形式来存储数字值本身：</p>
<ul>
<li>当最高位有效位为 1 时，代表后面还跟有字节；</li>
<li>当最高位有效位为 0 时，代表该数字式最后的一个字节；</li>
</ul>
<p>在 <code>protobuf</code> 中，使用的 <code>Base128 Varint</code> 编码，之所以叫这个名字原因及时在这种方式中，使用 <code>7 bit</code> 来存储数字，<code>Base128 Varint</code> 采用的是小端序，即<strong>数字的低位存放在高位地址</strong>。</p>
<h3 id="编码案例1"><a href="#编码案例1" class="headerlink" title="编码案例1"></a>编码案例 1</h3><p><img src="/2023/11/14/Google-Protobuf%E8%AF%A6%E8%A7%A3/image-20230116234912915.png" alt="image-20230116234912915"></p>
<h3 id="编码案例2"><a href="#编码案例2" class="headerlink" title="编码案例2"></a>编码案例 2</h3><p><img src="/2023/11/14/Google-Protobuf%E8%AF%A6%E8%A7%A3/image-20230214140405012.png" alt="image-20230214140405012"></p>
<h3 id="解码案例"><a href="#解码案例" class="headerlink" title="解码案例"></a>解码案例</h3><img src="/2023/11/14/Google-Protobuf%E8%AF%A6%E8%A7%A3/image-20230117002739059.png" alt="image-20230117002739059" style="zoom: 67%;">

<h2 id="3-4-Zigzag编码"><a href="#3-4-Zigzag编码" class="headerlink" title="3.4 Zigzag编码"></a>3.4 Zigzag 编码</h2><p><code>Varint</code> 编码的实质在于去掉数字开头的 <code>0</code>，因此可以缩短数字所占的存储字节数，在上一章节中，说明了整数的 <code>Varint</code> 编码，但是如果数字为负数时，使用 <code>Varint</code> 编码会占用恒定的 <code>10个</code>字节，原因在于负数的符号位 <code>1</code>。对于负数，其从符号位开始的高位均为 <code>1</code>，在 <code>protobuf</code> 的具体实现中，会将此视为一个很大的无符号数。</p>
<p>究其原因在于 <code>protobuf</code> 的内部将 <code>int32</code> 类型的负数转换为 <code>uint64</code> 来处理，转换后的 <code>unit64</code> 数值的高位全是 <code>1</code>，相当于是一个 8 字节的很大的无符号数，因此采用 <code>Base128 Varint</code> 编码后将恒定占用 10 个字节的空间，可见 <code>Varint</code> 编码对于负数时毫无优势，甚至比普通的固定 <code>32</code> 为存储还要多占 <code>4</code> 个字。<code>Varint</code> 编码的实质在于设法移除数字开头为 <code>0</code> 的比特位，由于负数的高位都为 1，因此 <code>Varint</code> 编码在此场景下都会失效，<code>Zigzag</code> 编码便是为了解决这个问题，其大致思想是：<strong>首先对负数做一次变换，将其映射成一个正数，变换后便可以使用 Varint 编码进行压缩</strong>。这里关键的一点在于变换算法，其算法必须是可逆的，既可以根据变换后的值计算出原始值，否则无法解码，同时要求变换算法尽可能简单，以避免影响 <code>protobuf</code> 编码、解码的性能。</p>
<p>Zigzag 编码的计算方式为：</p>
<blockquote>
<p><code>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code></p>
</blockquote>
<h3 id="编码案例"><a href="#编码案例" class="headerlink" title="编码案例"></a>编码案例</h3><p><img src="/2023/11/14/Google-Protobuf%E8%AF%A6%E8%A7%A3/image-20230121004322599.png" alt="image-20230121004322599"></p>
<h2 id="3-5-定长编码"><a href="#3-5-定长编码" class="headerlink" title="3.5 定长编码"></a>3.5 定长编码</h2><p><code>double、float</code> 等数据结构的长度是确定的，当解析到这种类型的数据时，直接按照对应长度取数即可。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ol>
<li><code>Protobuf</code> 是一种高效的数据描述格式，具有平台无关、语言无关、可扩展等特点，适合做数据存储、RPC 的通信协议等场景；</li>
<li><code>Protobuf</code> 采用 <code>Varint</code> 编码和 <code>Zigzag</code> 编码来编码数据，其中 <code>Varint</code> 编码的思想是移除数字高位的 <code>0</code>，用变长的二进制位来描述一个数字，对于小数字， 其编码长度短，可提高数据传输效率，但由于它在每个字节的最高位额外采用了一个标志位来标记其后是否还跟有有效字节，因此对于大的正数，它会比使用普通的定长格式占用更多的空间，另外对于负数，直接采用 <code>Varint</code> 编码将恒定占 <code>10</code> 个字节，<code>Zigzag</code> 编码可将负数映射为无符号的正数，然后采用 <code>Varint</code> 编码进行数据压缩，在各种语言的 <code>Protobuf</code> 实现中，对于 <code>int32</code> 类型的数据，<code>Protobuf</code> 都会转为 <code>uint64</code> 而后使用 <code>Varint</code> 编码来处理，因此当字段可能为负数时，我们应使用 <code>sint32</code> 或 <code>sint64</code>，这样 <code>Protobuf</code> 会按照 <code>Zigzag</code> 编码将数据变换后再采用 <code>Varint</code> 编码进行压缩，从而缩短数据的二进制位数；</li>
<li><code>Protobuf</code> 不是完全自描述的信息描述格式，接收端需要有相应的解码器 (即 <code>proto</code> 定义) 才可解析数据格式，序列化后的 <code>Protobuf</code> 数据不携带字段名，只使用字段编号来标识一个字段，因此更改 <code>proto</code> 的字段名不会影响数据解析 (但这显然不是一种好的行为)，字段编号会被编码进二进制的消息结构中，因此我们应尽可能地使用小字段编号；</li>
<li><code>Protobuf</code> 是一种紧密的消息结构，编码后字段之间没有间隔，每个字段头由两部分组成: <strong>字段编号</strong>和 <code>wire_type</code>，字段头可确定数据段的长度，因此其字段之前无需加入间隔，也无需引入特定的数据来标记字段末尾，因此 <code>Protobuf</code> 的编码长度短，传输效率高；</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://colobu.com/2017/03/16/Protobuf3-language-guide/">Protobuf3 语法指南</a></li>
<li><a href="https://xie.infoq.cn/article/98ed0dbe753b394c04a655ab7">深入理解 ProtoBuf 原理与工程实践（概述）</a></li>
<li><a href="https://juejin.cn/post/6982167437185663007">实现自己的 Protobuf Any</a></li>
<li><a href="https://www.jianshu.com/p/cae40f8faf1e">Protobuf 使用指南</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/encoding">官方编码原理介绍</a></li>
<li><a href="https://sunyunqiang.com/blog/protobuf_encode/">Google Protobuf 编码原理</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>BigTable: A Distributed Storage System for Structured Data 翻译 &amp; 理解</title>
    <url>/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>Bigtable 是一个<strong>分布式的结构化数据存储系统</strong>，它被设计用来处理海量数据：通常是分布在数千台普通服务器上的 PB 级的数据。Google 的很多项目使用 Bigtable 存储数据，包括 Web 索引、<code>Google Earth</code>、<code>Google Finance</code>。这些应用对 Bigtable 提出的要求差异非常大，无论是在数据量上（从 URL 到网页到卫星图像）还是在响应速度上（从后端的批量处理到实时数据服务）。尽管应用需求差异很大，但是，针对 Google 的这些产品，Bigtable 还是成功的提供了一个灵活的、高性能的解决方案。本论文描述了 Bigtable 提供的简单的数据模型，利用这个模型，用户可以动态的控制数据的分布和格式；我们还将描述 Bigtable 的设计和实现。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>在过去两年半时间里，我们设计、实现并部署了一个分布式的结构化数据存储系统。在 Google，我们称之为 Bigtable。Bigtable 的设计目的是可靠地处理 PB 级别的数据，并且能够部署到上千台机器上。Bigtable 已经实现了下面的几个目标：适用性广泛、可扩展、高性能和高可用性。Bigtable 已经在超过 60 个 Google 的产品和项目上得到了应用，包括 <code>Google Analytics</code>、<code>Google Finance</code>、<code>Orkut</code>、<code>Personalized Search</code>、<code>Writely</code> 和 <code>Google Earth</code>。这些产品对 Bigtable 提出了不同的需求，有的需要高吞吐量的批处理，有的则需要及时响应，快速返回数据给最终用户。它们使用的 Bigtable 集群的配置也有很大的差异，有的集群只有几台服务器，而有的则需要上千台服务器、存储几百 TB 的数据。</p>
<p>在很多方面，Bigtable 和数据库很类似：它使用了很多数据库的实现策略。<strong>并行数据库</strong>和<strong>内存数据库</strong>已经具备可扩展性和高性能，但是 Bigtable 提供了一个和这些系统完全不同的接口。Bigtable 不支持完整的关系数据模型；与之相反，Bigtable 为客户提供了简单的数据模型，利用这个模型，客户可以动态控制数据的分布和格式（<code>也就是对BigTable而言，数据是没有格式的，用数据库领域的术语说，就是数据没有Schema，用户自己去定义Schema</code>），用户也可以自己推测底层存储数据的位置相关性 (<code>位置相关性可以这样理解，比如树状结构，具有相同前缀的数据的存放位置接近。在读取的时候，可以把这些数据一次读取出来</code>)。数据的下标是行和列的名字，名字可以是任意的字符串。Bigtable 将存储的数据都视为字符串，但是 Bigtable 本身不去解析这些字符串，客户程序通常会在把各种结构化或者半结构化的数据串行化到这些字符串里。通过仔细选择数据的模式，客户可以控制数据的位置相关性。最后，可以通过 BigTable 的模式参数来控制数据是存放在内存中、还是硬盘上。</p>
<p>第二节描述关于数据模型更多细节方面的东西；第三节概要介绍了客户端 API；第四节简要介绍了 BigTable 底层使用的 Google 的基础框架；第五节描述了 BigTable 实现的关键部分；第 6 节描述了我们为了提高 BigTable 的性能采用的一些精细的调优方法；第 7 节提供了 BigTable 的性能数据；第 8 节讲述了几个 Google 内部使用 BigTable 的例子；第 9 节是我们在设计和后期支持过程中得到一些经验和教训；最后，在第 10 节列出我们的相关研究工作，第 11 节是我们的结论。</p>
<h1 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2 数据模型"></a>2 数据模型</h1><p>Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序 Map。Map 的索引是行关键字、列关键字以及时间戳；Map 中的每个 value 都是一个未经解析的 byte 数组。</p>
<p>(row:string, column:string,time:int64)-&gt;string</p>
<p>我们在仔细分析了一个类似 Bigtable 的系统的种种潜在用途之后，决定使用这个数据模型。我们先举个具体的例子，这个例子促使我们做了很多设计决策；假设我们想要存储海量的网页及相关信息，这些数据可以用于很多不同的项目，我们姑且称这个特殊的表为 Webtable。在 Webtable 里，我们使用 URL 作为行关键字，使用网页的某些属性作为列名，网页的内容存在 “contents:” 列中，并用获取该网页的时间戳作为标识 (<code>即按照获取时间不同，存储了多个版本的网页数据</code>)，如图一所示。</p>
<p><img src="/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220824001213314.png" alt="image-20220824001213314"></p>
<p>图一：一个存储 Web 网页的例子的表的片断。行名是一个反向 URL。contents 列族存放的是网页的内容，anchor 列族存放引用该网页的锚链接文本（<a href="https://www.sxl.cn/content/blog/anchor/">关于 HTML 的 Anchor</a>）。CNN 的主页被 Sports Illustrater 和 MY-look 的主页引用，因此该行包含了名为 “anchor:cnnsi.com” 和 “anchor:my.look.ca” 的列。每个锚链接只有一个版本（注意时间戳标识了列的版本，t9 和 t8 分别标识了两个锚链接的版本）；而 contents 列则有三个版本，分别由时间戳 t3，t5，和 t6 标识。</p>
<h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><p>表中的行关键字可以是任意的字符串（目前支持最大 64KB 的字符串，但是对大多数用户，10-100 个字节就足够了）。对同一个行关键字的读或者写操作都是原子的（不管读或者写这一行里多少个不同列），这个设计决策能够使用户很容易理解程序在对同一个行进行并发更新操作时的行为。</p>
<p>Bigtable 通过行关键字的字典顺序来组织数据。<strong>表中的每个行都可以动态分区</strong>。每个分区叫做一个”Tablet”，<strong>Tablet 是数据分布和负载均衡调整的最小单位。</strong>这样做的结果是，当操作只读取行中很少几列的数据时效率很高，通常只需要很少几次机器间的通信即可完成。用户可以通过选择合适的行关键字，在数据访问时有效利用数据的位置相关性，从而更好的利用这个特性。举例来说，在 Webtable 里，通过反转 URL 中主机名的方式，可以把同一个域名下的网页聚集起来组织成连续的行。具体来说，我们可以把 <code>maps.google.com/index.html</code> 的数据存放在关键字 <code>com.google.maps/index.html</code> 下。把相同的域中的网页存储在连续的区域可以让基于主机和域名的分析更加有效。</p>
<h2 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h2><p>列关键字组成的集合叫做 “列族 “，<strong>列族是访问控制的基本单位</strong>。存放在同一列族下的所有数据通常都属于同一个类型（我们可以把同一个列族下的数据压缩在一起）。列族在使用之前必须先创建，然后才能在列族中任何的列关键字下存放数据；列族创建后，其中的任何一个列关键字下都可以存放数据。根据我们的设计意图，一张表中的列族不能太多（最多几百个），并且列族在运行期间很少改变。与之相对应的，一张表可以有无限多个列。</p>
<p>列关键字的命名语法如下：列族：限定词。 列族的名字必须是可打印的字符串，而限定词的名字可以是任意的字符串。比如，Webtable 有个列族 language，language 列族用来存放撰写网页的语言。我们在 language 列族中只使用一个列关键字，用来存放每个网页的语言标识 ID。Webtable 中另一个有用的列族是 anchor；这个列族的每一个列关键字代表一个锚链接，如图一所示。Anchor 列族的限定词是引用该网页的站点名；Anchor 列族每列的数据项存放的是链接文本。</p>
<p>访问控制、磁盘和内存的使用统计都是在列族层面进行的。在我们的 Webtable 的例子中，上述的控制权限能帮助我们管理不同类型的应用：我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）。</p>
<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>在 Bigtable 中，表的每一个数据项都可以包含同一份数据的不同版本；不同版本的数据通过时间戳来索引。Bigtable 时间戳的类型是 64 位整型。Bigtable 可以给时间戳赋值，用来表示精确到毫秒的 “实时” 时间；用户程序也可以给时间戳赋值。如果应用程序需要避免数据版本冲突，那么它必须自己生成具有唯一性的时间戳。数据项中，不同版本的数据按照时间戳倒序排序，即最新的数据排在最前面。</p>
<p>为了减轻多个版本数据的管理负担，我们对每一个列族配有两个设置参数，Bigtable 通过这两个参数可以对废弃版本的数据自动进行垃圾收集。用户可以指定只保存最后 <code>n</code> 个版本的数据，或者只保存 “足够新” 的版本的数据（比如，只保存最近 7 天的内容写入的数据）。</p>
<p>在 Webtable 的举例里，contents: 列存储的时间戳信息是网络爬虫抓取一个页面的时间。上面提及的垃圾收集机制可以让我们只保留最近三个版本的网页数据。</p>
<h1 id="3-API"><a href="#3-API" class="headerlink" title="3 API"></a>3 API</h1><p>Bigtable 提供了建立和删除表以及列族的 API 函数。Bigtable 还提供了修改集群、表和列族的元数据的 API，比如修改访问权限。</p>
<img src="/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220825215855752.png" alt="image-20220825215855752" style="zoom: 67%;">

<p>客户程序可以对 Bigtable 进行如下的操作：写入或者删除 Bigtable 中的值、从每个行中查找值、或者遍历表中的一个数据子集。图 2 中的Ｃ++ 代码使用 RowMutation 抽象对象进行了一系列的更新操作。（为了保持示例代码的简洁，我们忽略了一些细节相关代码）。调用 Apply 函数对 Webtable 进行了一个原子修改操作：它为 <a href="http://www.cnn.com增加了一个锚点,同时删除了另外一个锚点./">www.cnn.com 增加了一个锚点，同时删除了另外一个锚点。</a></p>
<img src="/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220825220750195.png" alt="image-20220825220750195" style="zoom:67%;">

<p>图 3 中的 C++ 代码使用 Scanner 抽象对象遍历一个行内的所有锚点。客户程序可以遍历多个列族，有几种方法可以对扫描输出的行、列和时间戳进行限制。例如，我们可以限制上面的扫描，让它只输出那些匹配正则表达式 <code>*.cnn.com</code> 的锚点，或者那些时间戳在当前时间前 10 天的锚点。</p>
<p>Bigtable 还支持一些其它的特性，利用这些特性，用户可以对数据进行更复杂的处理。首先，Bigtable 支持单行上的事务处理，利用这个功能，用户可以对存储在一个行关键字下的数据进行原子性的读 - 更新 - 写操作。虽然 Bigtable 提供了一个允许用户跨行批量写入数据的接口，但是，Bigtable 目前还不支持通用的跨行事务处理。其次，Bigtable 允许把数据项用做整数计数器。最后，Bigtable 允许用户在服务器的地址空间内执行脚本程序。脚本程序使用 Google 开发的 <code>Sawzall</code> 数据处理语言。虽然目前我们基于的 <code>Sawzall</code> 语言的 API 函数还不允许客户的脚本程序写入数据到 Bigtable，但是它允许多种形式的数据转换、基于任意表达式的数据过滤、以及使用多种操作符的进行数据汇总。</p>
<p>Bigtable 可以和 <code>MapReduce</code> 一起使用，<code>MapReduce</code> 是 Google 开发的大规模并行计算框架。我们已经开发了一些 Wrapper 类，通过使用这些 Wrapper 类，Bigtable 可以作为 MapReduce 框架的输入和输出。</p>
<h1 id="4-BigTable构件"><a href="#4-BigTable构件" class="headerlink" title="4 BigTable构件"></a>4 BigTable 构件</h1><p>Bigtable 是建立在其它的几个 Google 基础构件上的。BigTable 使用 Google 的分布式文件系统 (GFS) 存储日志文件和数据文件。BigTable 集群通常运行在一个共享的机器池中，池中的机器还会运行其它的各种各样的分布式应用程序，BigTable 的进程经常要和其它应用的进程共享机器。BigTable 依赖集群管理系统来调度任务、管理共享的机器上的资源、处理机器的故障、以及监视机器的状态。</p>
<p>BigTable 内部存储数据的文件是 Google SSTable 格式的。SSTable 是一个持久化的、排序的、不可更改的 Map 结构，而 Map 是一个 key-value 映射的数据结构，key 和 value 的值都是任意的 <code>Byte</code> 串。可以对 SSTable 进行如下的操作：查询与一个 key 值相关的 value，或者遍历某个 key 值范围内的所有的 KV 对。从内部看，SSTable 是一系列的数据块（通常每个块的大小是 64KB，这个大小是可以配置的）。SSTable 使用块索引（通常存储在 SSTable 的最后）来定位数据块；在打开 SSTable 的时候，索引被加载到内存。每次查找都可以通过一次磁盘搜索完成：首先使用二分查找法在内存中的索引里找到数据块的位置，然后再从硬盘读取相应的数据块。也可以选择把整个 SSTable 都放在内存中，这样就不必访问硬盘了。</p>
<p>BigTable 还依赖一个高可用的、序列化的分布式锁服务组件，叫做 <code>Chubby</code>。一个 <code>Chubby</code> 服务包括了 5 个活动的副本，其中的一个副本被选为 Master，并且处理请求。只有在大多数副本都是正常运行的，并且彼此之间能够互相通信的情况下，<code>Chubby</code> 服务才是可用的。当有副本失效的时候，<code>Chubby</code> 使用 <code>Paxos</code> 算法来保证副本的一致性。<code>Chubby</code> 提供了一个名字空间，里面包括了目录和小文件。每个目录或者文件可以当成一个锁，读写文件的操作都是原子的。<code>Chubby</code> 客户程序库提供对 <code>Chubby</code> 文件的一致性缓存。每个 <code>Chubby</code> 客户程序都维护一个与 <code>Chubby</code> 服务的会话。如果客户程序不能在租约到期的时间内重新签订会话的租约，这个会话就过期失效了。当一个会话失效时，它拥有的锁和打开的文件句柄都失效了。<code>Chubby</code> 客户程序可以在文件和目录上注册回调函数，当文件或目录改变、或者会话过期时，回调函数会通知客户程序。</p>
<p>Bigtable 使用 <code>Chubby</code> 完成以下的几个任务：确保在任何给定的时间内最多只有一个活动的 Master 副本；存储 BigTable 数据的自引导指令的位置（参考 5.1 节）；查找 Tablet 服务器，以及在 Tablet 服务器失效时进行善后（5.2 节）；存储 BigTable 的模式信息（每张表的列族信息）；以及存储访问控制列表。如果 <code>Chubby</code> 长时间无法访问，BigTable 就会失效。最近我们在使用 11 个 <code>Chubby</code> 服务实例的 14 个 BigTable 集群上测量了这个影响。由于 <code>Chubby</code> 不可用而导致 BigTable 中的部分数据不能访问的平均比率是 <code>0.0047%</code>（<code>Chubby</code> 不能访问的原因可能是 <code>Chubby</code> 本身失效或者网络问题）。单个集群里，受 <code>Chubby</code> 失效影响最大的百分比是 <code>0.0326%</code>。</p>
<h1 id="5-介绍"><a href="#5-介绍" class="headerlink" title="5 介绍"></a>5 介绍</h1><p>Bigtable 包括了三个主要的组件：链接到客户程序中的库、一个 Master 服务器和多个 Tablet 服务器。针对系统工作负载的变化情况，BigTable 可以动态的向集群中添加（或者删除）Tablet 服务器。</p>
<p>Master 服务器主要负责以下工作：为 Tablet 服务器分配 Tablets、检测新加入的或者过期失效的 Table 服务器、对 Tablet 服务器进行负载均衡、以及对保存在 GFS 上的文件进行垃圾收集。除此之外，它还处理对模式的相关修改操作，例如建立表和列族。</p>
<p>每个 Tablet 服务器都管理一个 Tablet 的集合（通常每个服务器有大约数十个至上千个 Tablet）。每个 Tablet 服务器负责处理它所加载的 Tablet 的读写操作，以及在 Tablets 过大时，对其进行分割。</p>
<p>和很多 Single-Master 类型的分布式存储系统类似，客户端读取的数据都不经过 Master 服务器：客户程序直接和 Tablet 服务器通信进行读写操作。由于 BigTable 的客户程序不必通过 Master 服务器来获取 Tablet 的位置信息，因此，大多数客户程序甚至完全不需要和 Master 服务器通信。在实际应用中，Master 服务器的负载是很轻的。</p>
<p>一个 BigTable 集群存储了很多表，每个表包含了一个 Tablet 的集合，而每个 Tablet 包含了某个范围内的行的所有相关数据。初始状态下，一个表只有一个 Tablet。随着表中数据的增长，它被自动分割成多个 Tablet，缺省情况下，每个 Tablet 的尺寸大约是 100MB 到 200MB。</p>
<h2 id="5-1-Tablet的位置"><a href="#5-1-Tablet的位置" class="headerlink" title="5.1 Tablet的位置"></a>5.1 Tablet 的位置</h2><p>使用一个三层的、类似Ｂ+ 树的结构存储 Tablet 的位置信息 (如图 4)。</p>
<img src="/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220904224021364.png" alt="image-20220904224021364" style="zoom: 67%;">

<p>第一层是一个存储在 Chubby 中的文件，它包含了 Root Tablet 的位置信息。Root Tablet 包含了一个特殊的 METADATA 表，表里有所有的 Tablet 的位置信息。METADATA 表的每个 Tablet 包含了一个用户 Tablet 的集合。Root Tablet 实际上是 METADATA 表的第一个 Tablet，只不过对它的处理比较特殊 — Root Tablet 永远不会被分割 — 这就保证了 Tablet 的位置信息存储结构不会超过三层。</p>
<p>在 METADATA 表里面，每个 Tablet 的位置信息都存放在一个行关键字下面，而这个行关键字是由 Tablet 所在的表的标识符和 Tablet 的最后一行编码而成的。METADATA 的每一行都存储了大约 1KB 的内存数据。在一个大小适中的、容量限制为 128MB 的 METADATA Tablet 中，采用这种三层结构的存储模式，可以标识 2^34 个 Tablet 的地址（如果每个 Tablet 存储 128MB 数据，那么一共可以存储 2^61 字节数据）。</p>
<p>客户程序使用的库会缓存 Tablet 的位置信息。如果客户程序没有缓存某个 Tablet 的地址信息，或者发现它缓存的地址信息不正确，客户程序就在树状的存储结构中递归的查询 Tablet 位置信息；如果客户端缓存是空的，那么寻址算法需要通过三次网络来回通信寻址，这其中包括了一次 Chubby 读操作；如果客户端缓存的地址信息过期了，那么寻址算法可能需要最多６次网络来回通信才能更新数据，因为只有在缓存中没有查到数据的时候才能发现数据过期（其中的三次通信发现缓存过期，另外三次更新缓存数据）(假设 METADATA 的 Tablet 没有被频繁的移动）。尽管 Tablet 的地址信息是存放在内存里的，对它的操作不必访问 GFS 文件系统，但是，通常我们会通过预取 Tablet 地址来进一步的减少访问的开销：每次需要从 METADATA 表中读取一个 Tablet 的元数据的时候，它都会多读取几个 Tablet 的元数据。</p>
<p>在 METADATA 表中还存储了次级信息 (secondary information)，包括每个 Tablet 的事件日志（例如，什么时候一个服务器开始为该 Tablet 提供服务）。这些信息有助于排查错误和性能分析。</p>
<h2 id="5-2-Tablet分配"><a href="#5-2-Tablet分配" class="headerlink" title="5.2 Tablet分配"></a>5.2 Tablet 分配</h2><p>在任何一个时刻，一个 Tablet 只能分配给一个 Tablet 服务器。Master 服务器记录了当前有哪些活跃的 Tablet 服务器、哪些 Tablet 分配给了哪些 Tablet 服务器、哪些 Tablet 还没有被分配。当一个 Tablet 还没有被分配、并且刚好有一个 Tablet 服务器有足够的空闲空间装载该 Tablet 时，Master 服务器会给这个 Tablet 服务器发送一个装载请求，把 Tablet 分配给这个服务器。</p>
<p>BigTable 使用 Chubby 跟踪记录 Tablet 服务器的状态。当一个 Tablet 服务器启动时，它在 Chubby 的一个指定目录下建立一个有唯一性名字的文件，并且获取该文件的独占锁。Master 服务器实时监控着这个目录（服务器目录），因此 Master 服务器能够知道有新的 Tablet 服务器加入了。如果 Tablet 服务器丢失了 Chubby 上的独占锁 — 比如由于网络断开导致 Tablet 服务器和 Chubby 的会话丢失 — 它就停止对 Tablet 提供服务。（Chubby 提供了一种高效的机制，利用这种机制，Tablet 服务器能够在不增加网络负担的情况下知道它是否还持有锁）。只要文件还存在，Tablet 服务器就会试图重新获得对该文件的独占锁；如果文件不存在了，那么 Tablet 服务器就不能再提供服务了，它会自行退出。当 Tablet 服务器终止时（比如，集群的管理系统将运行该 Tablet 服务器的主机从集群中移除），它会尝试释放它持有的文件锁，这样一来，Master 服务器就能尽快把 Tablet 分配到其它的 Tablet 服务器。</p>
<p>Master 服务器负责检查一个 Tablet 服务器是否已经不再为它的 Tablet 提供服务了，并且要尽快重新分配它加载的 Tablet。Master 服务器通过轮询 Tablet 服务器文件锁的状态来检测何时 Tablet 服务器不再为 Tablet 提供服务。如果一个 Tablet 服务器报告它丢失了文件锁，或者 Master 服务器最近几次尝试和它通信都没有得到响应，Master 服务器就会尝试获取该 Tablet 服务器文件的独占锁；如果 Master 服务器成功获取了独占锁，那么就说明 Chubby 是正常运行的，而 Tablet 服务器要么是宕机了、要么是不能和 Chubby 通信了，因此，Master 服务器就删除该 Tablet 服务器在 Chubby 上的服务器文件以确保它不再给 Tablet 提供服务。一旦 Tablet 服务器在 Chubby 上的服务器文件被删除了，Master 服务器就把之前分配给它的所有的 Tablet 放入未分配的 Tablet 集合中。为了确保 Bigtable 集群在 Master 服务器和 Chubby 之间网络出现故障的时候仍然可以使用，Master 服务器在它的 Chubby 会话过期后主动退出。但是不管怎样，如同我们前面所描述的，Master 服务器的故障不会改变现有 Tablet 在 Tablet 服务器上的分配状态。</p>
<p>当集群管理系统启动了一个 Master 服务器之后，Master 服务器首先要了解当前 Tablet 的分配状态，之后才能够修改分配状态。Master 服务器在启动的时候执行以下步骤：（1）Master 服务器从 Chubby 获取一个唯一的 Master 锁，用来阻止创建其它的 Master 服务器实例；（2）Master 服务器扫描 Chubby 的服务器文件锁存储目录，获取当前正在运行的服务器列表；（3）Master 服务器和所有的正在运行的 Tablet 表服务器通信，获取每个 Tablet 服务器上 Tablet 的分配信息；（4）Master 服务器扫描 METADATA 表获取所有的 Tablet 的集合。在扫描的过程中，当 Master 服务器发现了一个还没有分配的 Tablet，Master 服务器就将这个 Tablet 加入未分配的 Tablet 集合等待合适的时机分配。</p>
<p>可能会遇到一种复杂的情况：在 METADATA 表的 Tablet 还没有被分配之前是不能够扫描它的。因此，在开始扫描之前（步骤 4），如果在第三步的扫描过程中发现 Root Tablet 还没有分配，Master 服务器就把 Root Tablet 加入到未分配的 Tablet 集合。这个附加操作确保了 Root Tablet 会被分配。由于 Root Tablet 包括了所有 METADATA 的 Tablet 的名字，因此 Master 服务器扫描完 Root Tablet 以后，就得到了所有的 METADATA 表的 Tablet 的名字了。</p>
<p>保存现有 Tablet 的集合只有在以下事件发生时才会改变：建立了一个新表或者删除了一个旧表、两个 Tablet 被合并了、或者一个 Tablet 被分割成两个小的 Tablet。Master 服务器可以跟踪记录所有这些事件，因为除了最后一个事件外的两个事件都是由它启动的。Tablet 分割事件需要特殊处理，因为它是由 Tablet 服务器启动。在分割操作完成之后，Tablet 服务器通过在 METADATA 表中记录新的 Tablet 的信息来提交这个操作；当分割操作提交之后，Tablet 服务器会通知 Master 服务器。如果分割操作已提交的信息没有通知到 Master 服务器（可能两个服务器中有一个宕机了），Master 服务器在要求 Tablet 服务器装载已经被分割的子表的时候会发现一个新的 Tablet。通过对比 METADATA 表中 Tablet 的信息，Tablet 服务器会发现 Master 服务器要求其装载的 Tablet 并不完整，因此，Tablet 服务器会重新向 Master 服务器发送通知信息。</p>
<h2 id="5-3-Tablet服务"><a href="#5-3-Tablet服务" class="headerlink" title="5.3 Tablet服务"></a>5.3 Tablet 服务</h2><img src="/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220907194551761.png" alt="image-20220907194551761" style="zoom:67%;">

<p>如图 5 所示，Tablet 的持久化状态信息保存在 GFS 上。更新操作提交到 REDO 日志中。在这些更新操作中，最近的提交存放在一个排序的缓存中，我们称这个缓存为 memtable；较早的更新存放在一系列 SSTable 中。为了恢复一个 Tablet，Tablet 服务器首先从 METADATA 表中读取它的元数据。Tablet 的元数据包含了组成这个 Tablet 的 SSTable 的列表，以及一系列的 Redo Point，这些 Redo Point 指向可能含有该 Tablet 数据的已提交的日志记录。Tablet 服务器把 SSTable 的索引读进内存，之后通过重复 Redo Point 之后提交的更新来重建 memtable。</p>
<p>当对 Tablet 服务器进行写操作时，Tablet 服务器首先要检查这个操作格式是否正确、操作发起者是否有执行这个操作的权限。权限验证的方法是通过从一个 Chubby 文件里读取出来的具有写权限的操作者列表来进行验证（这个文件几乎一定会存放在 Chubby 客户缓存里）。成功的修改操作会记录在提交日志里。可以采用批量提交方式来提高包含大量小的修改操作的应用程序的吞吐量。当一个写操作提交后，写的内容插入到 memtable 里面。</p>
<p>当对 Tablet 服务器进行读操作时，Tablet 服务器会作类似的完整性和权限检查。一个有效的读操作在一个由一系列 SSTable 和 memtable 合并的视图里执行。由于 SSTable 和 memtable 是按字典排序的数据结构，因此可以高效生成合并视图。</p>
<p>当进行 Tablet 的合并和分割时，正在进行的读写操作能够继续进行。</p>
<h2 id="5-4-Compactions"><a href="#5-4-Compactions" class="headerlink" title="5.4 Compactions"></a>5.4 Compactions</h2><p>随着写操作的执行，memtable 的大小不断增加。当 memtable 的尺寸到达一个阈值的时候，这个 memtable 就会被冻结，然后创建一个新的 memtable；被冻结住 memtable 会被转换成 SSTable，然后写入 GFS。Minor Compaction 过程有两个目的：shrink（shrink 是数据库用语，表示空间收缩）Tablet 服务器使用的内存，以及在服务器灾难恢复过程中，减少必须从提交日志里读取的数据量。在 Compaction 过程中，正在进行的读写操作仍能继续。</p>
<p>每一次 Minor Compaction 都会创建一个新的 SSTable。如果 Minor Compaction 过程持续进行下去，读操作可能需要合并来自多个 SSTable 的更新；否则，我们通过定期在后台执行 Merging Compaction 过程合并文件，限制这类文件的数量。Merging Compaction 过程读取一些 SSTable 和 memtable 的内容，合并成一个新的 SSTable。只要 Merging Compaction 过程完成了，输入的这些 SSTable 和 memtable 就可以删除了。</p>
<p>合并所有的 SSTable 并生成一个新的 SSTable 的 Merging Compaction 过程叫作 Major Compaction。由非 Major Compaction 产生的 SSTable 可能含有特殊的删除条目，这些删除条目能够隐藏在旧的、但是依然有效的 SSTable 中已经删除的数据。而 Major Compaction 过程生成的 SSTable 不包含已经删除的信息或数据。Bigtable 循环扫描它所有的 Tablet，并且定期对它们执行 Major Compaction。Major Compaction 机制允许 Bigtable 回收已经删除的数据占有的资源，并且确保 BigTable 能及时清除已经删除的数据，这对存放敏感数据的服务是非常重要。</p>
<h1 id="6-优化"><a href="#6-优化" class="headerlink" title="6 优化"></a>6 优化</h1><p>上一章我们描述了 Bigtable 的实现，我们还需要很多优化工作才能使 Bigtable 到达用户要求的高性能、高可用性和高可靠性。本章描述了 Bigtable 实现的其它部分，为了更好的强调这些优化工作，我们将深入细节.</p>
<h2 id="局部性群组"><a href="#局部性群组" class="headerlink" title="局部性群组"></a>局部性群组</h2><p>客户程序可以将多个列族组合成一个局部性群族。对 Tablet 中的每个局部性群组都会生成一个单独的 SSTable。将通常不会一起访问的列族分割成不同的局部性群组可以提高读取操作的效率。例如，在 Webtable 表中，网页的元数据（比如语言和 Checksum）可以在一个局部性群组中，网页的内容可以在另外一个群组：当一个应用程序要读取网页的元数据的时候，它没有必要去读取所有的页面内容。</p>
<p>此外，可以以局部性群组为单位设定一些有用的调试参数。比如，可以把一个局部性群组设定为全部存储在内存中。Tablet 服务器依照惰性加载的策略将设定为放入内存的局部性群组的 SSTable 装载进内存。加载完成之后，访问属于该局部性群组的列族的时候就不必读取硬盘了。这个特性对于需要频繁访问的小块数据特别有用：在 Bigtable 内部，我们利用这个特性提高 METADATA 表中具有位置相关性的列族的访问速度。</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>客户程序可以控制一个局部性群组的 SSTable 是否需要压缩；如果需要压缩，那么以什么格式来压缩。每个 SSTable 的块（块的大小由局部性群组的优化参数指定）都使用用户指定的压缩格式来压缩。虽然分块压缩浪费了少量空间（相比于对整个 SSTable 进行压缩，分块压缩压缩率较低），但是，我们在只读取 SSTable 的一小部分数据的时候就不必解压整个文件了。很多客户程序使用了 “两遍” 的、可定制的压缩方式。第一遍采用 Bentley and McIlroy’s 方式，这种方式在一个很大的扫描窗口里对常见的长字符串进行压缩；第二遍是采用快速压缩算法，即在一个 16KB 的小扫描窗口中寻找重复数据。两个压缩的算法都很快，在现在的机器上，压缩的速率达到 100-200MB/s，解压的速率达到 400-1000MB/s。</p>
<p>虽然我们在选择压缩算法的时候重点考虑的是速度而不是压缩的空间，但是这种两遍的压缩方式在空间压缩率上的表现也是令人惊叹。比如，在 Webtable 的例子里，我们使用这种压缩方式来存储网页内容。在一次测试中，我们在一个压缩的局部性群组中存储了大量的网页。针对实验的目的，我们没有存储每个文档所有版本的数据，我们仅仅存储了一个版本的数据。该模式的空间压缩比达到了 10:1。这比传统的 Gzip 在压缩 HTML 页面时 3:1 或者 4:1 的空间压缩比好的多；“两遍” 的压缩模式如此高效的原因是由于 Webtable 的行的存放方式：从同一个主机获取的页面都存在临近的地方。利用这个特性，Bentley-McIlroy 算法可以从来自同一个主机的页面里找到大量的重复内容。不仅仅是 Webtable，其它的很多应用程序也通过选择合适的行名来将相似的数据聚簇在一起，以获取较高的压缩率。当我们在 Bigtable 中存储同一份数据的多个版本的时候，压缩效率会更高。</p>
<h2 id="通过缓存提高读操作的性能"><a href="#通过缓存提高读操作的性能" class="headerlink" title="通过缓存提高读操作的性能"></a>通过缓存提高读操作的性能</h2><p>为了提高读操作的性能，Tablet 服务器使用二级缓存的策略。扫描缓存是第一级缓存，主要缓存 Tablet 服务器通过 SSTable 接口获取的 Key-Value 对；Block 缓存是二级缓存，缓存的是从 GFS 读取的 SSTable 的 Block。对于经常要重复读取相同数据的应用程序来说，扫描缓存非常有效；对于经常要读取刚刚读过的数据附近的数据的应用程序来说，Block 缓存更有用（例如，顺序读，或者在一个热点的行的局部性群组中随机读取不同的列)。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>如 5.3 节所述，一个读操作必须读取构成 Tablet 状态的所有 SSTable 的数据。如果这些 SSTable 不在内存中，那么就需要多次访问硬盘。我们通过允许客户程序对特定局部性群组的 SSTable 指定 Bloom 过滤器，来减少硬盘访问的次数。我们可以使用 Bloom 过滤器查询一个 SSTable 是否包含了特定行和列的数据。对于某些特定应用程序，我们只付出了少量的、用于存储 Bloom 过滤器的内存的代价，就换来了读操作显著减少的磁盘访问的次数。使用 Bloom 过滤器也隐式的达到了当应用程序访问不存在的行或列时，大多数时候我们都不需要访问硬盘的目的。</p>
<h2 id="Commit日志的实现"><a href="#Commit日志的实现" class="headerlink" title="Commit日志的实现"></a>Commit 日志的实现</h2><p>如果我们把对每个 Tablet 的操作的 Commit 日志都存在一个单独的文件的话，那么就会产生大量的文件，并且这些文件会并行的写入 GFS。根据 GFS 服务器底层文件系统实现的方案，要把这些文件写入不同的磁盘日志文件时，会有大量的磁盘 Seek 操作。另外，由于批量提交中操作的数目一般比较少，因此，对每个 Tablet 设置单独的日志文件也会给批量提交本应具有的优化效果带来很大的负面影响。为了避免这些问题，我们设置每个 Tablet 服务器一个 Commit 日志文件，把修改操作的日志以追加方式写入同一个日志文件，因此一个实际的日志文件中混合了对多个 Tablet 修改的日志记录。</p>
<p>使用单个日志显著提高了普通操作的性能，但是将恢复的工作复杂化了。当一个 Tablet 服务器宕机时，它加载的 Tablet 将会被移到很多其它的 Tablet 服务器上：每个 Tablet 服务器都装载很少的几个原来的服务器的 Tablet。当恢复一个 Tablet 的状态的时候，新的 Tablet 服务器要从原来的 Tablet 服务器写的日志中提取修改操作的信息，并重新执行。然而，这些 Tablet 修改操作的日志记录都混合在同一个日志文件中的。一种方法是：新的 Tablet 服务器读取完整的 Commit 日志文件，然后只重复执行它需要恢复的 Tablet 的相关修改操作。使用这种方法，假如有 100 台 Tablet 服务器，每台都加载了失效的 Tablet 服务器上的一个 Tablet，那么，这个日志文件就要被读取 100 次（每个服务器读取一次）。</p>
<p>为了避免多次读取日志文件，我们首先把日志按照关键字（table，row name，log sequence number）排序。排序之后，对同一个 Tablet 的修改操作的日志记录就连续存放在了一起，因此，我们只要一次磁盘 Seek 操作、之后顺序读取就可以了。为了并行排序，我们先将日志分割成 64MB 的段，之后在不同的 Tablet 服务器对段进行并行排序。这个排序工作由 Master 服务器来协同处理，并且在一个 Tablet 服务器表明自己需要从 Commit 日志文件恢复 Tablet 时开始执行。</p>
<p>在向 GFS 中写 Commit 日志的时候可能会引起系统颠簸，原因是多种多样的（比如，写操作正在进行的时候，一个 GFS 服务器宕机了；或者连接三个 GFS 副本所在的服务器的网络拥塞或者过载了）。为了确保在 GFS 负载高峰时修改操作还能顺利进行，每个 Tablet 服务器实际上有两个日志写入线程，每个线程都写自己的日志文件，并且在任何时刻，只有一个线程是工作的。如果一个线程的在写入的时候效率很低，Tablet 服务器就切换到另外一个线程，修改操作的日志记录就写入到这个线程对应的日志文件中。每个日志记录都有一个序列号，因此，在恢复的时候，Tablet 服务器能够检测出并忽略掉那些由于线程切换而导致的重复的记录。</p>
<h2 id="Tablet恢复提速"><a href="#Tablet恢复提速" class="headerlink" title="Tablet恢复提速"></a>Tablet 恢复提速</h2><p>当 Master 服务器将一个 Tablet 从一个 Tablet 服务器移到另外一个 Tablet 服务器时，源 Tablet 服务器会对这个 Tablet 做一次 Minor Compaction。这个 Compaction 操作减少了 Tablet 服务器的日志文件中没有归并的记录，从而减少了恢复的时间。Compaction 完成之后，该服务器就停止为该 Tablet 提供服务。在卸载 Tablet 之前，源 Tablet 服务器还会再做一次（通常会很快）Minor Compaction，以消除前面在一次压缩过程中又产生的未归并的记录。第二次 Minor Compaction 完成以后，Tablet 就可以被装载到新的 Tablet 服务器上了，并且不需要从日志中进行恢复。</p>
<h2 id="利用不变性"><a href="#利用不变性" class="headerlink" title="利用不变性"></a>利用不变性</h2><p>我们在使用 Bigtable 时，除了 SSTable 缓存之外的其它部分产生的 SSTable 都是不变的，我们可以利用这一点对系统进行简化。例如，当从 SSTable 读取数据的时候，我们不必对文件系统访问操作进行同步。这样一来，就可以非常高效的实现对行的并行操作。memtable 是唯一一个能被读和写操作同时访问的可变数据结构。为了减少在读操作时的竞争，我们对内存表采用 COW (Copy-on-write) 机制，这样就允许读写操作并行执行。</p>
<p>因为 SSTable 是不变的，因此，我们可以把永久删除被标记为 “删除” 的数据的问题，转换成对废弃的 SSTable 进行垃圾收集的问题了。每个 Tablet 的 SSTable 都在 METADATA 表中注册了。Master 服务器采用 “标记 - 删除” 的垃圾回收方式删除 SSTable 集合中废弃的 SSTable，METADATA 表则保存了 Root SSTable 的集合。</p>
<p>最后，SSTable 的不变性使得分割 Tablet 的操作非常快捷。我们不必为每个分割出来的 Tablet 建立新的 SSTable 集合，而是共享原来的 Tablet 的 SSTable 集合。</p>
<h1 id="7-性能评估"><a href="#7-性能评估" class="headerlink" title="7 性能评估"></a>7 性能评估</h1><p>为了测试 Bigtable 的性能和可扩展性，我们建立了一个包括 N 台 Tablet 服务器的 Bigtable 集群，这里 N 是可变的。每台 Tablet 服务器配置了 1GB 的内存，数据写入到一个包括 1786 台机器、每台机器有 2 个 IDE 硬盘的 GFS 集群上。我们使用 N 台客户机生成工作负载测试 Bigtable。（我们使用和 Tablet 服务器相同数目的客户机以确保客户机不会成为瓶颈。） 每台客户机配置 2GZ 双核 Opteron 处理器，配置了足以容纳所有进程工作数据集的物理内存，以及一张 Gigabit 的以太网卡。这些机器都连入一个两层的、树状的交换网络里，在根节点上的带宽加起来有大约 100-200Gbps。所有的机器采用相同的设备，因此，任何两台机器间网络来回一次的时间都小于 1ms。</p>
<p>Tablet 服务器、Master 服务器、测试机、以及 GFS 服务器都运行在同一组机器上。每台机器都运行一个 GFS 的服务器。其它的机器要么运行 Tablet 服务器、要么运行客户程序、要么运行在测试过程中，使用这组机器的其它的任务启动的进程。</p>
<p>R 是测试过程中，Bigtable 包含的不同的列关键字的数量。我们精心选择 R 的值，保证每次基准测试对每台 Tablet 服务器读 / 写的数据量都在 1GB 左右。</p>
<p>在序列写的基准测试中，我们使用的列关键字的范围是 0 到 R-1。这个范围又被划分为 10N 个大小相同的区间。核心调度程序把这些区间分配给 N 个客户端，分配方式是：只要客户程序处理完上一个区间的数据，调度程序就把后续的、尚未处理的区间分配给它。这种动态分配的方式有助于减少客户机上同时运行的其它进程对性能的影响。我们在每个列关键字下写入一个单独的字符串。每个字符串都是随机生成的、因此也没有被压缩。另外，不同列关键字下的字符串也是不同的，因此也就不存在跨行的压缩。随机写入基准测试采用类似的方法，除了行关键字在写入前先做 Hash，Hash 采用按 R 取模的方式，这样就保证了在整个基准测试持续的时间内，写入的工作负载均匀的分布在列存储空间内。</p>
<p>序列读的基准测试生成列关键字的方式与序列写相同，不同于序列写在列关键字下写入字符串，序列读是读取列关键字下的字符串（这些字符串由之前序列写基准测试程序写入）。同样的，随机读的基准测试和随机写是类似的。</p>
<p>扫描基准测试和序列读类似，但是使用的是 BigTable 提供的、从一个列范围内扫描所有的 value 值的 API。由于一次 RPC 调用就从一个 Tablet 服务器取回了大量的 Value 值，因此，使用扫描方式的基准测试程序可以减少 RPC 调用的次数。</p>
<p>随机读（内存）基准测试和随机读类似，除了包含基准测试数据的局部性群组被设置为 “in-memory”，因此，读操作直接从 Tablet 服务器的内存中读取数据，不需要从 GFS 读取数据。针对这个测试，我们把每台 Tablet 服务器存储的数据从 1GB 减少到 100MB，这样就可以把数据全部加载到 Tablet 服务器的内存中了。</p>
<img src="/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220913231536661.png" alt="image-20220913231536661" style="zoom: 50%;">

<p>图 6 中有两个视图，显示了我们的基准测试的性能；图中的数据和曲线是读 / 写 1000-byte value 值时取得的。图中的表格显示了每个 Tablet 服务器每秒钟进行的操作的次数；图中的曲线显示了每秒种所有的 Tablet 服务器上操作次数的总和。</p>
<h2 id="单个Tablet服务器的性能"><a href="#单个Tablet服务器的性能" class="headerlink" title="单个Tablet服务器的性能"></a>单个 Tablet 服务器的性能</h2><p>我们首先分析下单个 Tablet 服务器的性能。随机读的性能比其它操作慢一个数量级或以上 。每个随机读操作都要通过网络从 GFS 传输 64KB 的 SSTable 到 Tablet 服务器，而我们只使用其中大小是 1000 byte 的一个 value 值。Tablet 服务器每秒大约执行 1200 次读操作，也就是每秒大约从 GFS 读取 75MB 的数据。这个传输带宽足以占满 Tablet 服务器的 CPU 时间，因为其中包括了网络协议栈的消耗、SSTable 解析、以及 BigTable 代码执行；这个带宽也足以占满我们系统中网络的链接带宽。大多数采用这种访问模式 BigTable 应用程序会减小 Block 的大小，通常会减到 8KB。</p>
<p>内存中的随机读操作速度快很多，原因是，所有 1000-byte 的读操作都是从 Tablet 服务器的本地内存中读取数据，不需要从 GFS 读取 64KB 的 Block。</p>
<p>随机写和序列写操作的性能比随机读要好些，原因是每个 Tablet 服务器直接把写入操作的内容追加到一个 Commit 日志文件的尾部，并且采用批量提交的方式，通过把数据以流的方式写入到 GFS 来提高性能。随机写和序列写在性能上没有太大的差异，这两种方式的写操作实际上都是把操作内容记录到同一个 Tablet 服务器的 Commit 日志文件中。</p>
<p>序列读的性能好于随机读，因为每取出 64KB 的 SSTable 的 Block 后，这些数据会缓存到 Block 缓存中，后续的 64 次读操作直接从缓存读取数据。</p>
<p>扫描的性能更高，这是由于客户程序每一次 RPC 调用都会返回大量的 value 的数据，所以，RPC 调用的消耗基本抵消了。</p>
<h2 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h2><p>随着我们将系统中的 Tablet 服务器从 1 台增加到 500 台，系统的整体吞吐量有了梦幻般的增长，增长的倍率超过了 100。比如，随着 Tablet 服务器的数量增加了 500 倍，内存中的随机读操作的性能增加了 300 倍。之所以会有这样的性能提升，主要是因为这个基准测试的瓶颈是单台 Tablet 服务器的 CPU。</p>
<p>尽管如此，性能的提升还不是线性的。在大多数的基准测试中我们看到，当 Tablet 服务器的数量从 1 台增加到 50 台时，每台服务器的吞吐量会有一个明显的下降。这是由于多台服务器间的负载不均衡造成的，大多数情况下是由于其它的程序抢占了 CPU。 我们负载均衡的算法会尽量避免这种不均衡，但是基于两个主要原因，这个算法并不能完美的工作：一个是尽量减少 Tablet 的移动导致重新负载均衡能力受限（如果 Tablet 被移动了，那么在短时间内（一般是 1 秒内）这个 Tablet 是不可用的），另一个是我们的基准测试程序产生的负载会有波动。</p>
<p>随机读基准测试的测试结果显示，随机读的性能随 Tablet 服务器数量增加的提升幅度最小（整体吞吐量只提升了 100 倍，而服务器的数量却增加了 500 倍）。这是因为每个 1000-byte 的读操作都会导致一个 64KB 大的 Block 在网络上传输。这样的网络传输量消耗了我们网络中各种共享的 1GB 的链路，结果导致随着我们增加服务器的数量，每台服务器上的吞吐量急剧下降。</p>
<h1 id="8-实际应用"><a href="#8-实际应用" class="headerlink" title="8 实际应用"></a>8 实际应用</h1><img src="/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220913233916878.png" alt="image-20220913233916878" style="zoom:67%;">

<p>截止到 2006 年 8 月，Google 内部一共有 388 个非测试用的 Bigtable 集群运行在各种各样的服务器集群上，合计大约有 24500 个 Tablet 服务器。表 1 显示了每个集群上 Tablet 服务器的大致分布情况。这些集群中，许多用于开发目的，因此会有一段时期比较空闲。通过观察一个由 14 个集群、8069 个 Tablet 服务器组成的集群组，我们看到整体的吞吐量超过了每秒 1200000 次请求，发送到系统的 RPC 请求导致的网络负载达到了 741MB/s，系统发出的 RPC 请求网络负载大约是 16GB/s。</p>
<p><img src="/2023/08/22/BigTable-A-Distributed-Storage-System-for-Structured-Data%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220913234111723.png" alt="image-20220913234111723"></p>
<p>表 2 提供了一些目前正在使用的表的相关数据。一些表存储的是用户相关的数据，另外一些存储的则是用于批处理的数据；这些表在总的大小、 每个数据项的平均大小、从内存中读取的数据的比例、表的 Schema 的复杂程度上都有很大的差别。本节的其余部分，我们将主要描述三个产品研发团队如何使用 Bigtable 的。</p>
<h2 id="8-1Google-Analytics"><a href="#8-1Google-Analytics" class="headerlink" title="8.1Google Analytics"></a>8.1Google Analytics</h2><p>Google Analytics 是用来帮助 Web 站点的管理员分析他们网站的流量模式的服务。它提供了整体状况的统计数据，比如每天的独立访问的用户数量、每天每个 URL 的浏览次数；它还提供了用户使用网站的行为报告，比如根据用户之前访问的某些页面，统计出几成的用户购买了商品。</p>
<p>为了使用这个服务，Web 站点的管理员只需要在他们的 Web 页面中嵌入一小段 JavaScript 脚本就可以了。这个 Javascript 程序在页面被访问的时候调用。它记录了各种 Google Analytics 需要使用的信息，比如用户的标识、获取的网页的相关信息。Google Analytics 汇总这些数据，之后提供给 Web 站点的管理员。</p>
<p>我们粗略的描述一下 Google Analytics 使用的两个表。Row Click 表（大约有 200TB 数据）的每一行存放了一个最终用户的会话。行的名字是一个包含 Web 站点名字以及用户会话创建时间的元组。这种模式保证了对同一个 Web 站点的访问会话是顺序的，会话按时间顺序存储。这个表可以压缩到原来尺寸的 14%。</p>
<p>Summary 表（大约有 20TB 的数据）包含了关于每个 Web 站点的、各种类型的预定义汇总信息。一个周期性运行的 MapReduce 任务根据 Raw Click 表的数据生成 Summary 表的数据。每个 MapReduce 工作进程都从 Raw Click 表中提取最新的会话数据。系统的整体吞吐量受限于 GFS 的吞吐量。这个表的大小能够压缩到原有尺寸的 29%。</p>
<h2 id="8-2-Google-Earth"><a href="#8-2-Google-Earth" class="headerlink" title="8.2 Google Earth"></a>8.2 Google Earth</h2><p>Google 通过一组服务为用户提供了高分辨率的地球表面卫星图像，访问的方式可以使通过基于 Web 的 Google Maps 访问接口（maps.google.com），也可以通过 Google Earth 定制的客户端软件访问。这些软件产品允许用户浏览地球表面的图像：用户可以在不同的分辨率下平移、查看和注释这些卫星图像。这个系统使用一个表存储预处理数据，使用另外一组表存储用户数据。</p>
<p>数据预处理流水线使用一个表存储原始图像。在预处理过程中，图像被清除，图像数据合并到最终的服务数据中。这个表包含了大约 70TB 的数据，所以需要从磁盘读取数据。图像已经被高效压缩过了，因此存储在 Bigtable 后不需要再压缩了。</p>
<p>Imagery 表的每一行都代表了一个单独的地理区域。行都有名称，以确保毗邻的区域存储在了一起。Imagery 表中有一个列族用来记录每个区域的数据源。这个列族包含了大量的列：基本上每个列对应一个原始图片的数据。由于每个地理区域都是由很少的几张图片构成的，因此这个列族是非常稀疏的。</p>
<p>数据预处理流水线高度依赖运行在 Bigtable 上的 MapReduce 任务传输数据。在运行某些 MapReduce 任务的时候，整个系统中每台 Tablet 服务器的数据处理速度是 1MB/s。</p>
<p>这个服务系统使用一个表来索引 GFS 中的数据。这个表相对较小（大约是 500GB），但是这个表必须在保证较低的响应延时的前提下，针对每个数据中心，每秒处理几万个查询请求。 因此，这个表必须在上百个 Tablet 服务器上存储数据，并且使用 in-memory 的列族。</p>
<h2 id="8-3-个性化查询"><a href="#8-3-个性化查询" class="headerlink" title="8.3 个性化查询"></a>8.3 个性化查询</h2><p>个性化查询（<a href="http://www.google.com/psearch%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E6%9C%8D%E5%8A%A1%EF%BC%9B%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%82%B9%E5%87%BB%EF%BC%8C%E6%B6%89%E5%8F%8A%E5%88%B0%E5%90%84%E7%A7%8DGoogle%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%AF%94%E5%A6%82Web%E6%9F%A5%E8%AF%A2%E3%80%81%E5%9B%BE%E5%83%8F%E5%92%8C%E6%96%B0%E9%97%BB%E3%80%82%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E6%B5%8F%E8%A7%88%E4%BB%96%E4%BB%AC%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%8C%E9%87%8D%E5%A4%8D%E4%BB%96%E4%BB%AC%E4%B9%8B%E5%89%8D%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%82%B9%E5%87%BB%EF%BC%9B%E7%94%A8%E6%88%B7%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9A%E5%88%B6%E5%9F%BA%E4%BA%8EGoogle%E5%8E%86%E5%8F%B2%E4%BD%BF%E7%94%A8%E4%B9%A0%E6%83%AF%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E3%80%82">www.google.com/psearch）是一个双向服务；这个服务记录用户的查询和点击，涉及到各种 Google 的服务，比如 Web 查询、图像和新闻。用户可以浏览他们查询的历史，重复他们之前的查询和点击；用户也可以定制基于 Google 历史使用习惯模式的个性化查询结果。</a></p>
<p>个性化查询使用 Bigtable 存储每个用户的数据。每个用户都有一个唯一的用户 id，每个用户 id 和一个列名绑定。一个单独的列族被用来存储各种类型的行为（比如，有个列族可能是用来存储所有的 Web 查询的）。每个数据项都被用作 Bigtable 的时间戳，记录了相应的用户行为发生的时间。个性化查询使用以 Bigtable 为存储的 MapReduce 任务生成用户的数据图表。这些用户数据图表用来个性化当前的查询结果。</p>
<p>个性化查询的数据会复制到几个 Bigtable 的集群上，这样就增强了数据可用性，同时减少了由客户端和 Bigtable 集群间的 “距离” 造成的延时。个性化查询的开发团队最初建立了一个基于 Bigtable 的、“客户侧” 的复制机制为所有的复制节点提供一致性保障。现在的系统则使用了内建的复制子系统。</p>
<p>个性化查询存储系统的设计允许其它的团队在它们自己的列中加入新的用户数据，因此，很多 Google 服务使用个性化查询存储系统保存用户级的配置参数和设置。在多个团队之间分享数据的结果是产生了大量的列族。为了更好的支持数据共享，我们加入了一个简单的配额机制限制用户在共享表中使用的空间；配额也为使用个性化查询系统存储用户级信息的产品团体提供了隔离机制。</p>
<h1 id="9-经验教训"><a href="#9-经验教训" class="headerlink" title="9 经验教训"></a>9 经验教训</h1><p>在设计、实现、维护和支持 Bigtable 的过程中，我们得到了很多有用的经验和一些有趣的教训。</p>
<p>一个教训是，我们发现，很多类型的错误都会导致大型分布式系统受损，这些错误不仅仅是通常的网络中断、或者很多分布式协议中设想的 fail-stop 类型的错误（fail-stop failture：指一旦系统 fail 就 stop，不输出任何数据；fail-fast failture，指 fail 不马上 stop，在短时间内 return 错误信息，然后再 stop）。比如，我们遇到过下面这些类型的错误导致的问题：内存数据损坏、网络中断、时钟偏差、机器挂起、扩展的和非对称的网络分区、我们使用的其它系统的 Bug（比如 Chubby）、GFS 配额溢出、计划内和计划外的硬件维护。我们在解决这些问题的过程中学到了很多经验，我们通过修改协议来解决这些问题。比如，我们在我们的 RPC 机制中加入了 Checksum。我们在设计系统的部分功能时，不对其它部分功能做任何的假设，这样的做法解决了其它的一些问题。比如，我们不再假设一个特定的 Chubby 操作只返回错误码集合中的一个值。</p>
<p>另外一个教训是，我们明白了在彻底了解一个新特性会被如何使用之后，再决定是否添加这个新特性是非常重要的。比如，我们开始计划在我们的 API 中支持通常方式的事务处理。但是由于我们还不会马上用到这个功能，因此，我们并没有去实现它。现在，Bigtable 上已经有了很多的实际应用，我们可以检查它们真实的需求；我们发现，大多是应用程序都只是需要单个行上的事务功能。有些应用需要分布式的事务功能，分布式事务大多数情况下用于维护二级索引，因此我们增加了一个特殊的机制去满足这个需求。新的机制在通用性上比分布式事务差很多，但是它更有效（特别是在更新操作的涉及上百行数据的时候），而且非常符合我们的 “跨数据中心” 复制方案的优化策略。</p>
<p>还有一个具有实践意义的经验：我们发现系统级的监控对 Bigtable 非常重要（比如，监控 Bigtable 自身以及使用 Bigtable 的客户程序）。比如，我们扩展了我们的 RPC 系统，因此对于一个 RPC 调用的例子，它可以详细记录代表了 RPC 调用的很多重要操作。这个特性允许我们检测和修正很多的问题，比如 Tablet 数据结构上的锁的内容、在修改操作提交时对 GFS 的写入非常慢的问题、以及在 METADATA 表的 Tablet 不可用时，对 METADATA 表的访问挂起的问题。关于监控的用途的另外一个例子是，每个 Bigtable 集群都在 Chubby 中注册了。这可以帮助我们跟踪所有的集群状态、监控它们的大小、检查集群运行的我们软件的版本、监控集群流入数据的流量，以及检查是否有引发集群高延时的潜在因素。</p>
<p>对我们来说，最宝贵的经验是简单设计的价值。考虑到我们系统的代码量（大约 100000 行生产代码），以及随着时间的推移，新的代码以各种难以预料的方式加入系统，我们发现简洁的设计和编码给维护和调试带来的巨大好处。这方面的一个例子是我们的 Tablet 服务器成员协议。我们第一版的协议很简单：Master 服务器周期性的和 Tablet 服务器签订租约，Tablet 服务器在租约过期的时候 Kill 掉自己的进程。不幸的是，这个协议在遇到网络问题时会大大降低系统的可用性，也会大大增加 Master 服务器恢复的时间。我们多次重新设计这个协议，直到它能够很好的处理上述问题。但是，更不幸的是，最终的协议过于复杂了，并且依赖一些 Chubby 很少被用到的特性。我们发现我们浪费了大量的时间在调试一些古怪的问题，有些是 Bigtable 代码的问题，有些事 Chubby 代码的问题。最后，我们只好废弃了这个协议，重新制订了一个新的、更简单、只使用 Chubby 最广泛使用的特性的协议。</p>
<h1 id="10-相关工作"><a href="#10-相关工作" class="headerlink" title="10 相关工作"></a>10 相关工作</h1><p>Boxwood 项目的有些组件在某些方面和 Chubby、GFS 以及 Bigtable 类似，因为它也提供了诸如分布式协议、锁、分布式 Chunk 存储以及分布式 B-tree 存储。Boxwood 与 Google 的某些组件尽管功能类似，但是 Boxwood 的组件提供更底层的服务。Boxwood 项目的目的是提供创建类似文件系统、数据库等高级服务的基础构件，而 Bigtable 的目的是直接为客户程序的数据存储需求提供支持。</p>
<p>现在有不少项目已经攻克了很多难题，实现了在广域网上的分布式数据存储或者高级服务，通常是 “Internet 规模” 的。这其中包括了分布式的 Hash 表，这项工作由一些类似 CAN、Chord、Tapestry 和 Pastry 的项目率先发起。这些系统的主要关注点和 Bigtable 不同，比如应对各种不同的传输带宽、不可信的协作者、频繁的更改配置等；另外，去中心化和 Byzantine 灾难冗余 (Byzantine，即拜占庭式的风格，也就是一种复杂诡秘的风格。Byzantine Fault 表示：对于处理来说，当发错误时处理器并不停止接收输出，也不停止输出，错就错了，只管算，对于这种错误来说，这样可真是够麻烦了，因为用户根本不知道错误发生了，也就根本谈不上处理错误了。在多处理器的情况下，这种错误可能导致运算正确结果的处理器也产生错误的结果，这样事情就更麻烦了，所以一定要避免处理器产生这种错误。) 也不是 Bigtable 的目的。</p>
<p>就提供给应用程序开发者的分布式数据存储模型而言，我们相信，分布式 B-Tree 或者分布式 Hash 表提供的 Key-value pair 方式的模型有很大的局限性。Key-value pair 模型是很有用的组件，但是它们不应该是提供给开发者唯一的组件。我们选择的模型提供的组件比简单的 Key-value pair 丰富的多，它支持稀疏的、半结构化的数据。另外，它也足够简单，能够高效的处理平面文件；它也是透明的（通过局部性群组），允许我们的使用者对系统的重要行为进行调整。</p>
<p>有些数据库厂商已经开发出了并行的数据库系统，能够存储海量的数据。Oracle 的 RAC 使用共享磁盘存储数据（Bigtable 使用 GFS），并且有一个分布式的锁管理系统（Bigtable 使用 Chubby）。IBM 并行版本的 DB2 基于一种类似于 Bigtable 的、不共享任何东西的架构（a shared-nothing architecture）。每个 DB2 的服务器都负责处理存储在一个关系型数据库中的表中的行的一个子集。这些产品都提供了一个带有事务功能的完整的关系模型。</p>
<p>Bigtable 的局部性群组提供了类似于基于列的存储方案在压缩和磁盘读取方面具有的性能；这些以列而不是行的方式组织数据的方案包括 C-Store、商业产品 Sybase IQ、SenSage、KDB+，以及 MonetDB/X100 的 ColumnDM 存储层。另外一种在平面文件中提供垂直和水平数据分区、并且提供很好的数据压缩率的系统是 AT&amp;T 的 Daytona 数据库。局部性群组不支持 Ailamaki 系统中描述的 CPU 缓存级别的优化。</p>
<p>Bigtable 采用 memtable 和 SSTable 存储对表的更新的方法与 Log-Structured Merge Tree 存储索引数据更新的方法类似。这两个系统中，排序的数据在写入到磁盘前都先存放在内存中，读取操作必须从内存和磁盘中合并数据产生最终的结果集。</p>
<p>C-Store 和 Bigtable 有很多相似点：两个系统都采用 Shared-nothing 架构，都有两种不同的数据结构，一种用于当前的写操作，另外一种存放 “长时间使用” 的数据，并且提供一种机制在两个存储结构间搬运数据。两个系统在 API 接口函数上有很大的不同：C-Store 操作更像关系型数据库，而 Bigtable 提供了低层次的读写操作接口，并且设计的目标是能够支持每台服务器每秒数千次操作。C-Store 同时也是个 “读性能优化的关系型数据库”，而 Bigtable 对读和写密集型应用都提供了很好的性能。</p>
<p>Bigtable 也必须解决所有的 Shared-nothing 数据库需要面对的、类型相似的一些负载和内存均衡方面的难题。我们的问题在某种程度上简单一些：（1）我们不需要考虑同一份数据可能有多个拷贝的问题，同一份数据可能由于视图或索引的原因以不同的形式表现出来；（2）我们让用户决定哪些数据应该放在内存里、哪些放在磁盘上，而不是由系统动态的判断；（3）我们的系统中没有复杂的查询执行或优化工作。</p>
<h1 id="11-结论"><a href="#11-结论" class="headerlink" title="11 结论"></a>11 结论</h1><p>我们已经讲述完了 Bigtable，Google 的一个分布式的结构化数据存储系统。Bigtable 的集群从 2005 年 4 月开始已经投入使用了，在此之前，我们花了大约 7 人年设计和实现这个系统。截止到 2006 年 4 月，已经有超过 60 个项目使用 Bigtable 了。我们的用户对 Bigtable 提供的高性能和高可用性很满意，随着时间的推移，他们可以根据自己的系统对资源的需求增加情况，通过简单的增加机器，扩展系统的承载能力。</p>
<p>由于 Bigtable 提供的编程接口并不常见，一个有趣的问题是：我们的用户适应新的接口有多难？新的使用者有时不太确定使用 Bigtable 接口的最佳方法，特别是在他们已经习惯于使用支持通用事务的关系型数据库的接口的情况下。但是，Google 内部很多产品都成功的使用了 Bigtable 的事实证明了，我们的设计在实践中行之有效。</p>
<p>我们现在正在对 Bigtable 加入一些新的特性，比如支持二级索引，以及支持多 Master 节点的、跨数据中心复制的 Bigtable 的基础构件。我们现在已经开始将 Bigtable 部署为服务供其它的产品团队使用，这样不同的产品团队就不需要维护他们自己的 Bigtable 集群了。随着服务集群的扩展，我们需要在 Bigtable 系统内部处理更多的关于资源共享的问题了。</p>
<p>最后，我们发现，建设 Google 自己的存储解决方案带来了很多优势。通过为 Bigtable 设计我们自己的数据模型，使我们的系统极具灵活性。另外，由于我们全面控制着 Bigtable 的实现过程，以及 Bigtable 使用到的其它的 Google 的基础构件，这就意味着我们在系统出现瓶颈或效率低下的情况时，能够快速的解决这些问题。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a href="https://blog.csdn.net/OpenNaive/article/details/7532589">谷歌技术” 三宝” 之 BigTable</a></li>
<li><a href="https://dzone.com/articles/understanding-hbase-and-bigtab">Understanding HBase and BigTable</a></li>
<li><a href="https://spongecaptain.cool/post/paper/bigtable/">Bigtable 论文阅读</a></li>
<li><a href="https://markhe1222.github.io/2022/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/">理解并实现 LSM Tree</a></li>
</ul>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>存储</tag>
        <tag>GFS</tag>
        <tag>BigTable</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS 系列: HDFS 架构详解</title>
    <url>/2023/02/16/HDFS%E7%B3%BB%E5%88%97-HDFS%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p><code>HDFS（Hadoop Distributed File System）</code>是基于 <a href="https://markhe1222.github.io/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/">GFS</a> 的思想来实现的可扩展的分布式文件系统，支持海量数据的存储。<code>HDFS</code> 可以运行在低成本的硬件之上，具有高容错、高可靠性、高可拓展性、高吞吐率等特点，非常适合大规模数据集的应用。</p>
<blockquote>
<p>项目代码: <a href="https://github.com/apache/hadoop">https://github.com/apache/hadoop</a></p>
</blockquote>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="2-HDFS架构图"><a href="#2-HDFS架构图" class="headerlink" title="2 HDFS架构图"></a>2 HDFS 架构图</h1><p><img src="/2023/02/16/HDFS%E7%B3%BB%E5%88%97-HDFS%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/image-20230218225540375.png" alt="image-20230218225540375"></p>
<p><code>HDFS</code> 是一个主从体系 <code>(Master/Slave)</code> 结构的分布式系统，一个集群由一个 <code>Namenode（NN）</code>和多个 <code>Datanode（DN）</code>组成，用户可以通过 <code>HDFS Client</code> 与 <code>NN</code> 和 <code>DN</code> 交互以访问文件系统。</p>
<h1 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="3 基本概念"></a>3 基本概念</h1><h2 id="3-1-数据块（Block）"><a href="#3-1-数据块（Block）" class="headerlink" title="3.1 数据块（Block）"></a>3.1 数据块（Block）</h2><p><code>HDFS</code> 中文件处理的最小单元（概念可以与 <code>Linux</code> 系统中的 <code>ext2、ext3</code> 相同）。存储在 <code>HDFS</code> 的文件会比较大，为了减少最小化寻址开销，所以 <code>Block</code> 也更大，默认是 <code>128M</code>。<code>Block</code> 一般会以文件的形式存储在 <code>DN</code> 的磁盘上。</p>
<p>在 <code>HDFS</code> 中，为了保证数据的安全性，会将数据块进行冗余备份并保存到不同的 <code>DN</code> 上（一个数据块默认保存 3 份），所以数据块的一个副本丢失也不会影响数据块的访问。</p>
<h2 id="3-2-名字节点（Namenode）"><a href="#3-2-名字节点（Namenode）" class="headerlink" title="3.2 名字节点（Namenode）"></a>3.2 名字节点（Namenode）</h2><p>名字节点（<code>Namenode</code>，<code>NN</code>）是 <code>HDFS</code> 主从结构中的主节点<code>（Master）</code>。主要管理文件系统的以下元数据：</p>
<ul>
<li>命名空间<code>（Namespace）</code></li>
<li>文件系统的目录树</li>
<li>文件 / 目录信息</li>
<li>文件的数据块索引</li>
</ul>
<p>这些元数据都会在 <code>NN</code> 的本地磁盘上永久保存为两个文件的形式，即：<strong>空间镜像文件</strong>和<strong>编辑日志文件</strong>。</p>
<p><code>NN</code> 还维护数据块与数据节点的映射关系，但是不保存在本地磁盘中，而是在 <code>NN</code> 启动时动态创建的。当 <code>HDFS Client</code> 的请求过来时，会先从 <code>NN</code> 上读取以上信息，再进行文件数据的读写。</p>
<p>可以将 <code>NN</code> 视为一个逻辑上的节点（逻辑上只有单节点，实际上可能不止一个节点）。当 <code>NN</code> 出现故障无法服务时，集群会启用备用 <code>NN</code>，由于 <code>Active NN</code> 的内存元数据与 <code>Standby NN</code> 的数据是完全同步，此时 <code>Standby NN</code> 状态会切换为 <code>Active</code>，不影响集群整体的对外服务。</p>
<h2 id="3-2-数据节点（Datanode）"><a href="#3-2-数据节点（Datanode）" class="headerlink" title="3.2 数据节点（Datanode）"></a>3.2 数据节点（Datanode）</h2><p>数据节点（<code>Datanode</code>，<code>DN</code>）是 <code>HDFS</code> 主从结构中的从节点<code>（Slave）</code>。数据存储节点，根据 <code>HDFS Client</code> 的请求或者 <code>NN</code> 的调度，实际执行数据的读取和写入，可以认为是一个物理节点。</p>
<p><code>DN</code> 作为从节点，会不断地向 <code>NN</code> 发送心跳<code>（Heart Beat）</code>、数据块汇报<code>（Block Report）</code>、缓存汇报<code>（Cache Report）</code>等信息。</p>
<h2 id="3-3-客户端（Client）"><a href="#3-3-客户端（Client）" class="headerlink" title="3.3 客户端（Client）"></a>3.3 客户端（Client）</h2><p><code>HDFS</code> 提供了多种客户端接口：</p>
<ul>
<li>命令行</li>
<li>浏览器</li>
<li>代码 <code>API</code></li>
</ul>
<p>用户可以通过这些接口很方便使用 <code>HDFS</code>。</p>
<h2 id="3-4-通信协议"><a href="#3-4-通信协议" class="headerlink" title="3.4 通信协议"></a>3.4 通信协议</h2><p><code>HDFS</code> 节点间的通信接口主要有两种：</p>
<ul>
<li><code>Hadoop RPC</code>：<code>HDFS</code> 基于 <code>Hadoop RPC</code> 框架实现的接口；</li>
<li>流式接口：<code>HDFS</code> 基于 <code>TCP/HTTP</code> 实现的接口；</li>
</ul>
<h1 id="4-主要流程"><a href="#4-主要流程" class="headerlink" title="4 主要流程"></a>4 主要流程</h1><h2 id="4-1-读流程"><a href="#4-1-读流程" class="headerlink" title="4.1 读流程"></a>4.1 读流程</h2><p><img src="/2023/02/16/HDFS%E7%B3%BB%E5%88%97-HDFS%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/image-20230218231515060.png" alt="image-20230218231515060"></p>
<ol>
<li><code>HDFS Client</code> 收到用户读请求后，会创建一个数据流对象进行具体的数据读取流程；</li>
<li>数据流向 <code>NN</code> 发送下载文件请求，<code>NN</code> 查询目标文件元数据，找到文件所在的 <code>DD</code> 和对应的数据块 <code>Block</code> 列表后返回；</li>
<li>数据流对象会根据文件的元数据，挑选一台多个副本距离较近的 <code>DD</code>，请求读取数据；</li>
<li><code>DD</code> 收到读取请求后，开始传输数据给数据流对象（从磁盘阵列读取数据输入流中，切分为多个数据包<code>（Packet）</code>为单位进行校验）；</li>
<li><code>Client</code> 接受数据，先缓存在本地，待数据流接受完成后，关闭数据流，写入目标文件；</li>
</ol>
<h2 id="4-2-写流程"><a href="#4-2-写流程" class="headerlink" title="4.2 写流程"></a>4.2 写流程</h2><p><img src="/2023/02/16/HDFS%E7%B3%BB%E5%88%97-HDFS%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/image-20230219182600487.png" alt="image-20230219182600487"></p>
<ol>
<li><code>HDFS Client</code> 收到用户读请求后，会创建一个数据流对象进行具体的数据写入流程；</li>
<li>数据流对象向 <code>NN</code> 请求上传文件，<code>NN</code> 会先检查目标文件的父目录以及目标文件是否存在；</li>
<li><code>NN</code> 返回是否可以上传；</li>
<li>数据流对象请求 <code>NN</code> 上传第一个 <code>Block</code>；</li>
<li><code>NN</code> 返回数据写入的数据块信息；</li>
<li>数据流对象申请与 <code>DD</code> 建立数据传输通道， <code>DD</code> 按照网络具体逐级申请建立数据 <code>pipeline</code>；</li>
<li>应答</li>
<li>数据流对象收到 <code>NN</code> 返回后，开始具体的数据写入，客户端的数据会实现缓存在数据流对象中，之后这些数据会被切分成多个数据包<code>（Packet）</code>，依次写入数据节点；</li>
<li>第一个 <code>Block</code> 数据传输完了以后，重复 <code>4~8</code>，写入后续的 <code>Block</code>；</li>
</ol>
<blockquote>
<ul>
<li>多个 <code>DN</code> 可以并行写</li>
<li>若一个 <code>DN</code> 阻塞，则整体写入流程会阻塞；</li>
<li>文件都是追加写，不是随机写；</li>
</ul>
</blockquote>
<h2 id="4-3-Datanode启动流程"><a href="#4-3-Datanode启动流程" class="headerlink" title="4.3 Datanode启动流程"></a>4.3 Datanode 启动流程</h2><img src="/2023/02/16/HDFS%E7%B3%BB%E5%88%97-HDFS%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/image-20230220111939944.png" alt="image-20230220111939944" style="zoom:67%;">

<p><code>DN</code> 启动后会 <code>NN</code> 进行交互，主要包括三个部分：</p>
<ol>
<li>握手；</li>
<li>注册；</li>
<li>数据块以及缓存汇报；</li>
</ol>
<blockquote>
<ol>
<li><code>DN</code> 启动时，先会请求 <code>NN</code> 的版本号以及存储信息等，确认 <code>NN</code> 的版本号是否与 <code>DN</code> 当前的版本是否一致；</li>
<li><code>DN</code> 与 <code>NN</code> 成功握手后，<code>DN</code> 会向 <code>NN</code> 申请节点注册，<code>NN</code> 收到请求，判断 <code>DN</code> 是否属于集群，并检查版本号是否一致；</li>
<li>注册成功后，<code>DN</code> 需要将本地存储的所有数据块和已经缓存的数据块上报给 <code>NN</code>，<code>NN</code> 根据这些信息在内存中建立数据库与 <code>DN</code> 之间的映射关系；</li>
<li>完成以上所有步骤，<code>DN</code> 完成启动。后续需要定期向 <code>NN</code> 发送心跳，<code>NN</code> 根据心跳判断 <code>DN</code> 的状态并决定 <code>DN</code> 是否能够对外提供服务。同时 <code>DN</code> 与 <code>NN</code> 之间的交互信息都是通过心跳来携带传输。</li>
</ol>
</blockquote>
<h2 id="4-5-HA切换流程"><a href="#4-5-HA切换流程" class="headerlink" title="4.5 HA切换流程"></a>4.5 HA 切换流程</h2><img src="/2023/02/16/HDFS%E7%B3%BB%E5%88%97-HDFS%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/image-20230219200106434.png" alt="image-20230219200106434" style="zoom:67%;">

<p><code>HDFS</code> 的高可用<code>（High Availability，HA）</code>是解决 <code>NN</code> 可能出现单点故障的问题。在 <code>HA</code> 的 <code>HDFS</code> 集群中，同时运行两个 <code>NN（Active、Standby）</code>，其中 <code>Active NN</code> 与 <code>Standby NN</code> 的状态要求实时同步，即：要求两个 <code>NN</code> 的命名空间<code>（Namespace）</code>一致并且 <code>Block</code> 与 <code>DN</code> 之间的映射关系也一致。</p>
<ul>
<li>为了保证 <code>Namespace</code> 的一致性，两个 <code>NN</code> 需要与一组独立运行的节点<code>（JournalNodes，JNS）</code>通信，<code>Active NN</code> 定期将 <code>namespace</code> 的操作记录在 <code>editlog</code>，并写入 <code>JNS</code> 多数节点中。<code>Standby NN</code> 监听 <code>JNS</code>，如果返现 <code>JNS</code> 的 <code>editlog</code> 有更新，会进行同步更新与当前的命名空间合并。</li>
<li>对于 <code>Block</code> 与 <code>DN</code> 映射关系的一致性，要求 <code>HDFS</code> 中所有的 <code>DN</code> 同时向 <code>Active NN</code> 和 <code>Standby NN</code> 发送 <code>Heatbeat</code> 以及 <code>Block Report</code>。</li>
</ul>
<p>通过 <code>ZK</code> 的 <code>FailoverController</code> 实时监控 <code>HA</code> 的状态（<code>NN</code> 状态，系统运行状态、硬件状态等），当 <code>Active NN</code> 处于不可服务状态时，<code>FailoverController</code> 则会自动触发主备切换。此外 <code>HDFS</code> 还支持手动切换主备<code>（DFSHAAdmin）</code>。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p><img src="/2023/02/16/HDFS%E7%B3%BB%E5%88%97-HDFS%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/image-20230218192128445.png" alt="image-20230218192128445"></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://markhe1222.github.io/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/">GFS</a></li>
<li><a href="https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html">HDFS Architecture Guide</a></li>
</ul>
]]></content>
      <categories>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>存储</tag>
        <tag>大数据</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 通关笔记</title>
    <url>/2020/07/22/GitHub%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><code>Git</code> 几乎是现在版本管理的标配。用了好几年的 <code>Git</code>，但是有一些功能还是用的比较少，发现 <code>Github</code> 上有个叫 <code>githug</code> 的小游戏，对 <code>Git</code> 入门和复习有很大的帮助。这里附上通关的笔记。</p>
<p><code>Githug</code> 地址：<code>https://github.com/Gazler/githug</code></p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h4 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h4><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> ~]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">No githug directory found, <span class="keyword">do</span> you wish to create one? [<span class="type">yn</span>]  y</span><br><span class="line">Welcome to Githug!</span><br></pre></td></tr></tbody></table></figure>

<h4 id="1-10"><a href="#1-10" class="headerlink" title="1 - 10"></a>1 - 10</h4><h5 id="1"><a href="#1" class="headerlink" title="1:"></a>1:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: init</span><br><span class="line">Level: <span class="number">1</span></span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">A new directory, `git_hug`, has been created; initialize an empty repository <span class="keyword">in</span> it.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">ecssync@ecssync git_hug]<span class="variable">$</span> git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/ecssync/git_hug/.git/</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2"><a href="#2" class="headerlink" title="2:"></a>2:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: config</span><br><span class="line">Level: <span class="number">2</span></span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span> up your git name and email, this is important so that your commits can be identified.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git config user.name mark</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git config user.email mark.he.<span class="number">1314</span>@gmail.com</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is your name? mark</span><br><span class="line">What is your email? mark.he.<span class="number">1314</span>@gmail.com</span><br><span class="line">Your config has the following name: mark</span><br><span class="line">Your config has the following email: mark.he.<span class="number">1314</span>@gmail.com</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3"><a href="#3" class="headerlink" title="3:"></a>3:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: add</span><br><span class="line">Level: <span class="number">3</span></span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">There is a file <span class="keyword">in</span> your folder called `README`, you should add it to your staging area</span><br><span class="line">Note: You <span class="built_in">start</span> each level with a new repo. Don<span class="string">'t look for files from the previous one.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git add README</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug play</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="4"><a href="#4" class="headerlink" title="4:"></a>4:</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: commit</span><br><span class="line">Level: 4</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">The `README` file has been added to your staging area, now commit it.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ git commit</span><br><span class="line">[master (root-commit) 19c35e0] commit</span><br><span class="line"> Committer: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line"></span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br><span class="line">[ecssync@ecssync git_hug]$ githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="5"><a href="#5" class="headerlink" title="5:"></a>5:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: clone</span><br><span class="line">Level: <span class="number">5</span></span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">Clone the repository at https://github.com/Gazler/cloneme.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git clone https://github.com/Gazler/cloneme.git</span><br><span class="line">Cloning into <span class="string">'cloneme'</span>...</span><br><span class="line">remote: Enumerating objects: <span class="number">7</span>, done.</span><br><span class="line">remote: Total <span class="number">7</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack<span class="literal">-reused</span> <span class="number">7</span></span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), done.</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6"><a href="#6" class="headerlink" title="6:"></a>6:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: clone_to_folder</span><br><span class="line">Level: <span class="number">6</span></span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">Clone the repository at https://github.com/Gazler/cloneme to `my_cloned_repo`.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git clone https://github.com/Gazler/cloneme.git my_cloned_repo</span><br><span class="line">Cloning into <span class="string">'my_cloned_repo'</span>...</span><br><span class="line">remote: Enumerating objects: <span class="number">7</span>, done.</span><br><span class="line">remote: Total <span class="number">7</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack<span class="literal">-reused</span> <span class="number">7</span></span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), done.</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="7"><a href="#7" class="headerlink" title="7:"></a>7:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: ignore</span><br><span class="line">Level: <span class="number">7</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">The text editor <span class="string">'vim'</span> creates files ending <span class="keyword">in</span> `.swp` (swap files) <span class="keyword">for</span> all files that are currently open.  We don<span class="string">'t want them creeping into the repository.  Make this repository ignore those swap files which are ending in `.swp`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ecssync@ecssync git_hug]$ vim .gitignore</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ cat .gitignore</span></span><br><span class="line"><span class="string">.profile.yml</span></span><br><span class="line"><span class="string">.gitignore</span></span><br><span class="line"><span class="string">*.swp</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug play</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="8"><a href="#8" class="headerlink" title="8:"></a>8:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: include</span><br><span class="line">Level: <span class="number">8</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Notice a few files with the <span class="string">'.a'</span> extension.  We want git to ignore all but the <span class="string">'lib.a'</span> file.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> vim .gitignore</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> <span class="built_in">cat</span> .gitignore</span><br><span class="line">.profile.yml</span><br><span class="line">.gitignore</span><br><span class="line">*.a</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="9"><a href="#9" class="headerlink" title="9:"></a>9:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: status</span><br><span class="line">Level: <span class="number">9</span></span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">There are some files <span class="keyword">in</span> this repository, one of the files is untracked, which file is it?</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Initial commit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git rm --cached &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   Guardfile</span></span><br><span class="line"><span class="comment">#       new file:   README</span></span><br><span class="line"><span class="comment">#       new file:   config.rb</span></span><br><span class="line"><span class="comment">#       new file:   deploy.rb</span></span><br><span class="line"><span class="comment">#       new file:   setup.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       database.yml</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the full file name of the untracked file? database.yml</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="10"><a href="#10" class="headerlink" title="10:"></a>10:</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: number_of_files_committed</span><br><span class="line">Level: 10</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">There are some files in this repository, how many of the files will be committed?</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Changes to be committed:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       new file:   rubyfile1.rb</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      modified:   rubyfile4.rb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Changes not staged for commit:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       modified:   rubyfile5.rb</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Untracked files:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       rubyfile6.rb</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      rubyfile7.rb</span></span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">How many changes are going to be committed? 2</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h4 id="11-20"><a href="#11-20" class="headerlink" title="11 - 20:"></a>11 - 20:</h4><h5 id="11"><a href="#11" class="headerlink" title="11:"></a>11:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: <span class="built_in">rm</span></span><br><span class="line">Level: <span class="number">11</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">A file has been removed from the working tree, however the file was not removed from the repository.  Find out what this file was and remove it.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add/rm &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       deleted:    deleteme.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git <span class="built_in">rm</span> deleteme.rb</span><br><span class="line"><span class="built_in">rm</span> <span class="string">'deleteme.rb'</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="12"><a href="#12" class="headerlink" title="12:"></a>12:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: rm_cached</span><br><span class="line">Level: <span class="number">12</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">A file has accidentally been added to your staging area, find out which file and remove it from the staging area.  *NOTE* <span class="keyword">Do</span> not remove the file from the file system, only from git.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Initial commit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git rm --cached &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   deleteme.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git <span class="built_in">rm</span> <span class="literal">--cached</span> deleteme.rb</span><br><span class="line"><span class="built_in">rm</span> <span class="string">'deleteme.rb'</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Initial commit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       deleteme.rb</span></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="13"><a href="#13" class="headerlink" title="13:"></a>13:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: stash</span><br><span class="line">Level: <span class="number">13</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You<span class="string">'ve made some changes and want to work on them later. You should save them, but don'</span>t commit them.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   lyrics.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git stash</span><br><span class="line">Saved working directory and index state WIP on master: <span class="number">0206059</span> Add some lyrics</span><br><span class="line">HEAD is now at <span class="number">0206059</span> Add some lyrics</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="14"><a href="#14" class="headerlink" title="14:"></a>14:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: rename</span><br><span class="line">Level: <span class="number">14</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">We have a file called `oldfile.txt`. We want to rename it to `newfile.txt` and stage this change.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">oldfile.txt</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git <span class="built_in">mv</span> oldfile.txt newfile.txt</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       renamed:    oldfile.txt -&gt; newfile.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="15"><a href="#15" class="headerlink" title="15:"></a>15:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: restructure</span><br><span class="line">Level: <span class="number">15</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">You added some files to your repository, but now realize that your project needs to be restructured.  Make a new folder named `src` and <span class="keyword">using</span> Git move all of the .html files into this folder.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">about.html  contact.html  index.html</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> mkdir src</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git <span class="built_in">mv</span> *.html src</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       renamed:    about.html -&gt; src/about.html</span></span><br><span class="line"><span class="comment">#       renamed:    contact.html -&gt; src/contact.html</span></span><br><span class="line"><span class="comment">#       renamed:    index.html -&gt; src/index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="16"><a href="#16" class="headerlink" title="16:"></a>16:</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: log</span><br><span class="line">Level: 16</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You will be asked for the hash of most recent commit.  You will need to investigate the logs of the repository for this.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ git log</span><br><span class="line">commit c2e4b191f112fc2c3d5f8372dcf28dd8b2ae34b9</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul 21 14:13:16 2020 +0800</span><br><span class="line"></span><br><span class="line">    THIS IS THE COMMIT YOU ARE LOOKING FOR!</span><br><span class="line">[ecssync@ecssync git_hug]$ githug play</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the hash of the most recent commit? c2e4b191f112fc2c3d5f8372dcf28dd8b2ae34b9</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="17"><a href="#17" class="headerlink" title="17:"></a>17:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: tag</span><br><span class="line">Level: <span class="number">17</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">We have a git repo and we want to tag the current commit with `new_tag`.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git tag new_tag</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="18"><a href="#18" class="headerlink" title="18:"></a>18:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name: push_tags</span><br><span class="line">Level: <span class="number">18</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">There are tags <span class="keyword">in</span> the repository that aren<span class="string">'t pushed into remote repository. Push them now.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">From /tmp/d20200721-9363-o8bjo9/</span></span><br><span class="line"><span class="string"> * [new branch]      master     -&gt; origin/master</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git tag</span></span><br><span class="line"><span class="string">tag_to_be_pushed</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git push --tags</span></span><br><span class="line"><span class="string">Total 0 (delta 0), reused 0 (delta 0)</span></span><br><span class="line"><span class="string">To /tmp/d20200721-9363-o8bjo9/.git</span></span><br><span class="line"><span class="string"> * [new tag]         tag_to_be_pushed -&gt; tag_to_be_pushed</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="19"><a href="#19" class="headerlink" title="19:"></a>19:</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: commit_amend</span><br><span class="line">Level: 19</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">The `README` file has been committed, but it looks like the file `forgotten_file.rb` was missing from the commit.  Add the file and amend your previous commit to include it.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Untracked files:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       forgotten_file.rb</span></span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line">[ecssync@ecssync git_hug]$ git log</span><br><span class="line">commit 16fd6b783380c4588d9741d7d83bd009d2ecb79c</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul 21 14:20:04 2020 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit</span><br><span class="line">[ecssync@ecssync git_hug]$ git add forgotten_file.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ git commit --amend</span><br><span class="line">[master a1903b5] Initial commit</span><br><span class="line"> Committer: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line"></span><br><span class="line">*****[commit with VIM]*****</span><br><span class="line"></span><br><span class="line"> 2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br><span class="line"> create mode 100644 forgotten_file.rb</span><br><span class="line">[ecssync@ecssync git_hug]$ git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="20"><a href="#20" class="headerlink" title="20:"></a>20:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Name: commit_in_future</span><br><span class="line">Level: <span class="number">20</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Commit your changes with the future date (e.g. tomorrow).</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> date</span><br><span class="line">Tue Jul <span class="number">21</span> <span class="number">14</span>:<span class="number">25</span>:<span class="number">28</span> CST <span class="number">2020</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git commit <span class="literal">--date</span>=<span class="string">"Tue Jul 22 14:25:28 CST 2020"</span></span><br><span class="line">[<span class="type">master</span> (<span class="type">root</span>-<span class="type">commit</span>) <span class="type">c31abea</span>] tomorrow</span><br><span class="line"> Committer: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line"></span><br><span class="line">*****[<span class="type">commit</span> <span class="type">with</span> <span class="type">VIM</span>]*****</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span><br><span class="line"> create mode <span class="number">100644</span> README</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h4 id="21-30"><a href="#21-30" class="headerlink" title="21 - 30:"></a>21 - 30:</h4><h5 id="21"><a href="#21" class="headerlink" title="21:"></a>21:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: reset</span><br><span class="line">Level: <span class="number">21</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">There are two files to be committed.  The goal was to add each file as a separate commit, however both were added by accident.  Unstage the file `to_commit_second.rb` <span class="keyword">using</span> the reset <span class="keyword">command</span> (don<span class="string">'t commit anything).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git status</span></span><br><span class="line"><span class="string"># On branch master</span></span><br><span class="line"><span class="string"># Changes to be committed:</span></span><br><span class="line"><span class="string">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#       new file:   to_commit_first.rb</span></span><br><span class="line"><span class="string">#       new file:   to_commit_second.rb</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git reset to_commit_second.rb</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="22"><a href="#22" class="headerlink" title="22:"></a>22:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: reset_soft</span><br><span class="line">Level: <span class="number">22</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You committed too soon. Now you want to undo the last commit, <span class="keyword">while</span> keeping the index.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log</span><br><span class="line">commit <span class="number">5</span>dfd6a61b26fc982515684782de6794dd9d23412</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">25</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Premature commit</span><br><span class="line"></span><br><span class="line">commit <span class="number">1</span>f3668c9fe9c22bacd703d46485d6329ffa1fc41</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">25</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git reset <span class="literal">-h</span></span><br><span class="line">usage: git reset [--<span class="type">mixed</span> | --<span class="type">soft</span> | --<span class="type">hard</span> | --<span class="type">merge</span> | --<span class="type">keep</span>] [-<span class="type">q</span>] [&lt;<span class="type">commit</span>&gt;]</span><br><span class="line">   or: git reset [-<span class="type">q</span>] &lt;tree<span class="literal">-ish</span>&gt; [--] &lt;paths&gt;...</span><br><span class="line">   or: git reset <span class="literal">--patch</span> [&lt;<span class="type">tree</span>-<span class="type">ish</span>&gt;] [--] [&lt;<span class="type">paths</span>&gt;<span class="type">...</span>]</span><br><span class="line"></span><br><span class="line">    <span class="literal">-q</span>, <span class="literal">--quiet</span>           be quiet, only report errors</span><br><span class="line">    <span class="literal">--mixed</span>               reset HEAD and index</span><br><span class="line">    <span class="literal">--soft</span>                reset only HEAD</span><br><span class="line">    <span class="literal">--hard</span>                reset HEAD, index and working tree</span><br><span class="line">    <span class="literal">--merge</span>               reset HEAD, index and working tree</span><br><span class="line">    <span class="literal">--keep</span>                reset HEAD but keep local changes</span><br><span class="line">    <span class="literal">-p</span>, <span class="literal">--patch</span>           <span class="built_in">select</span> hunks interactively</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git reset <span class="literal">--soft</span> HEAD^<span class="number">1</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   newfile.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log</span><br><span class="line">commit <span class="number">1</span>f3668c9fe9c22bacd703d46485d6329ffa1fc41</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">25</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="23"><a href="#23" class="headerlink" title="23:"></a>23:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: checkout_file</span><br><span class="line">Level: <span class="number">23</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">A file has been modified, but you don<span class="string">'t want to keep the modification.  Checkout the `config.rb` file from the last commit.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git status</span></span><br><span class="line"><span class="string"># On branch master</span></span><br><span class="line"><span class="string"># Changes not staged for commit:</span></span><br><span class="line"><span class="string">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="string">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#       modified:   config.rb</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">no changes added to commit (use "git add" and/or "git commit -a")</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git checkout -- config.rb</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="24"><a href="#24" class="headerlink" title="24:"></a>24:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: remote</span><br><span class="line">Level: <span class="number">24</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">This project has a remote repository.  Identify it.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git remote</span><br><span class="line">my_remote_repo</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line">my_remote_repo  https://github.com/Gazler/githug (fetch)</span><br><span class="line">my_remote_repo  https://github.com/Gazler/githug (push)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the name of the remote repository? my_remote_repo</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="25"><a href="#25" class="headerlink" title="25:"></a>25:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: remote_url</span><br><span class="line">Level: <span class="number">25</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">The remote repositories have a url associated to them.  Please enter the url of remote_location.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line">my_remote_repo  https://github.com/Gazler/githug (fetch)</span><br><span class="line">my_remote_repo  https://github.com/Gazler/githug (push)</span><br><span class="line">remote_location https://github.com/githug/not_a_repo (fetch)</span><br><span class="line">remote_location https://github.com/githug/not_a_repo (push)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the url of the remote repository? https://github.com/githug/not_a_repo</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="26"><a href="#26" class="headerlink" title="26:"></a>26:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: pull</span><br><span class="line">Level: <span class="number">26</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You need to pull changes from your origin repository.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git pull <span class="literal">-h</span></span><br><span class="line">usage: git pull [-<span class="type">n</span> | --<span class="type">no</span>-<span class="type">stat</span>] [--[<span class="type">no</span>-]<span class="type">commit</span>] [--[<span class="type">no</span>-]<span class="type">squash</span>] [--[<span class="type">no</span>-]<span class="type">ff</span>] [-<span class="type">s</span> <span class="type">strategy</span>]... [&lt;<span class="type">fetch</span>-<span class="type">options</span>&gt;] &lt;repo&gt; &lt;head&gt;...</span><br><span class="line"></span><br><span class="line">Fetch one or more remote refs and merge it/them into the current HEAD.</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git pull origin master</span><br><span class="line">From https://github.com/pull<span class="literal">-this</span>/thing<span class="literal">-to-pull</span></span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="27"><a href="#27" class="headerlink" title="27:"></a>27:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: remote_add</span><br><span class="line">Level: <span class="number">27</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Add a remote repository called `origin` with the url https://github.com/githug/githug</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git remote add origin https://github.com/githug/githug</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="28"><a href="#28" class="headerlink" title="28:"></a>28:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: push</span><br><span class="line">Level: <span class="number">28</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">Your local master branch has diverged from the remote origin/master branch. Rebase your commit onto origin/master and push it to remote.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git rebase origin/master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: First commit</span><br><span class="line">Applying: Second commit</span><br><span class="line">Applying: Third commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Your branch is ahead of 'origin/master' by 3 commits.</span></span><br><span class="line"><span class="comment">#   (use "git push" to publish your local commits)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git push origin master</span><br><span class="line">Counting objects: <span class="number">7</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up to 8 threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), <span class="number">575</span> bytes | <span class="number">0</span> bytes/s, done.</span><br><span class="line">Total <span class="number">6</span> (delta <span class="number">2</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To /tmp/d20200721<span class="literal">-10098-1wufgfl</span>/.git</span><br><span class="line">   <span class="number">95</span>ea39b..<span class="number">34</span>ef860  master -&gt; master</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="29"><a href="#29" class="headerlink" title="29:"></a>29:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: <span class="built_in">diff</span></span><br><span class="line">Level: <span class="number">29</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">There have been modifications to the `app.rb` file since your last commit.  Find out which line has changed.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   app.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git <span class="built_in">diff</span> app.rb</span><br><span class="line"><span class="built_in">diff</span> <span class="literal">--git</span> a/app.rb b/app.rb</span><br><span class="line">index <span class="number">4</span>f703ca..<span class="number">3</span>bfa839 <span class="number">100644</span></span><br><span class="line"><span class="literal">---</span> a/app.rb</span><br><span class="line">+++ b/app.rb</span><br><span class="line"><span class="selector-tag">@</span><span class="selector-tag">@</span> <span class="literal">-23</span>,<span class="number">7</span> +<span class="number">23</span>,<span class="number">7</span> <span class="selector-tag">@</span><span class="selector-tag">@</span> get <span class="string">'/yet_another'</span> <span class="keyword">do</span></span><br><span class="line">   erb :success</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> get <span class="string">'/another_page'</span> <span class="keyword">do</span></span><br><span class="line">-  @message = get_response(<span class="string">'data.json'</span>)</span><br><span class="line">+  @message = get_response(<span class="string">'server.json'</span>)</span><br><span class="line">   erb :another</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the number of the line which has changed? <span class="number">26</span></span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="30"><a href="#30" class="headerlink" title="30:"></a>30:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: blame</span><br><span class="line">Level: <span class="number">30</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Someone has put a password inside the file `config.rb` find out who it was.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   config.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git blame config.rb</span><br><span class="line">^<span class="number">5</span>e8863d (Gary Rennie       <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">05</span>:<span class="number">24</span> +<span class="number">0000</span>  <span class="number">1</span>) <span class="class"><span class="keyword">class</span> <span class="title">Config</span></span></span><br><span class="line"><span class="class">70<span class="title">d00535</span> (<span class="title">Bruce</span> <span class="title">Banner</span>      2012-03-08 23:07:41 +0000  2)   <span class="title">attr_accessor</span> :<span class="title">name</span>, :<span class="title">password</span></span></span><br><span class="line"><span class="class">97<span class="title">bdd0cc</span> (<span class="title">Spider</span> <span class="title">Man</span>        2012-03-08 23:08:15 +0000  3)   <span class="title">def</span> <span class="title">initialize</span>(<span class="title">name</span>, <span class="title">password</span> = <span class="title">nil</span>, <span class="title">options</span> =</span> {})</span><br><span class="line">^<span class="number">5</span>e8863d (Gary Rennie       <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">05</span>:<span class="number">24</span> +<span class="number">0000</span>  <span class="number">4</span>)     @name = name</span><br><span class="line"><span class="number">97</span>bdd0cc (Spider <span class="built_in">Man</span>        <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">15</span> +<span class="number">0000</span>  <span class="number">5</span>)     @password = password || <span class="string">"i&lt;3evil"</span></span><br><span class="line"><span class="number">00000000</span> (Not Committed Yet <span class="number">2020</span><span class="literal">-07-21</span> <span class="number">14</span>:<span class="number">42</span>:<span class="number">38</span> +<span class="number">0800</span>  <span class="number">6</span>)</span><br><span class="line"><span class="number">09409480</span> (Spider <span class="built_in">Man</span>        <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">06</span>:<span class="number">18</span> +<span class="number">0000</span>  <span class="number">7</span>)     <span class="keyword">if</span> options<span class="function">[:<span class="type">downcase</span>]</span></span><br><span class="line"><span class="number">09409480</span> (Spider <span class="built_in">Man</span>        <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">06</span>:<span class="number">18</span> +<span class="number">0000</span>  <span class="number">8</span>)       @name.downcase!</span><br><span class="line"><span class="number">09409480</span> (Spider <span class="built_in">Man</span>        <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">06</span>:<span class="number">18</span> +<span class="number">0000</span>  <span class="number">9</span>)     <span class="keyword">end</span></span><br><span class="line"><span class="number">70</span>d00535 (Bruce Banner      <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">07</span>:<span class="number">41</span> +<span class="number">0000</span> <span class="number">10</span>)</span><br><span class="line">ffd39c2d (Gary Rennie       <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">58</span> +<span class="number">0000</span> <span class="number">11</span>)     <span class="keyword">if</span> options<span class="function">[:<span class="type">upcase</span>]</span></span><br><span class="line">ffd39c2d (Gary Rennie       <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">58</span> +<span class="number">0000</span> <span class="number">12</span>)       @name.upcase!</span><br><span class="line">ffd39c2d (Gary Rennie       <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">58</span> +<span class="number">0000</span> <span class="number">13</span>)     <span class="keyword">end</span></span><br><span class="line">ffd39c2d (Gary Rennie       <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">58</span> +<span class="number">0000</span> <span class="number">14</span>)</span><br><span class="line">^<span class="number">5</span>e8863d (Gary Rennie       <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">05</span>:<span class="number">24</span> +<span class="number">0000</span> <span class="number">15</span>)   <span class="keyword">end</span></span><br><span class="line">^<span class="number">5</span>e8863d (Gary Rennie       <span class="number">2012</span><span class="literal">-03-08</span> <span class="number">23</span>:<span class="number">05</span>:<span class="number">24</span> +<span class="number">0000</span> <span class="number">16</span>) <span class="keyword">end</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Who made the commit with the password? Spider <span class="built_in">Man</span></span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h4 id="31-40"><a href="#31-40" class="headerlink" title="31 - 40:"></a>31 - 40:</h4><h5 id="31"><a href="#31" class="headerlink" title="31:"></a>31:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: branch</span><br><span class="line">Level: <span class="number">31</span></span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">You want to work on a piece of code that has the potential to <span class="keyword">break</span> things, create the branch test_code.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git checkout <span class="literal">-b</span> test_code</span><br><span class="line">Switched to a new branch <span class="string">'test_code'</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="32"><a href="#32" class="headerlink" title="32:"></a>32:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: checkout</span><br><span class="line">Level: <span class="number">32</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Create and <span class="keyword">switch</span> to a new branch called my_branch.  You will need to create a branch like you did <span class="keyword">in</span> the previous level.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git checkout <span class="literal">-b</span> my_branch</span><br><span class="line">Switched to a new branch <span class="string">'my_branch'</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="33"><a href="#33" class="headerlink" title="33:"></a>33:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: checkout_tag</span><br><span class="line">Level: <span class="number">33</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You need to fix a bug <span class="keyword">in</span> the version <span class="number">1.2</span> of your app. Checkout the tag `v1.<span class="number">2</span>`.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git tag</span><br><span class="line">v1.<span class="number">0</span></span><br><span class="line">v1.<span class="number">2</span></span><br><span class="line">v1.<span class="number">5</span></span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git checkout v1.<span class="number">2</span></span><br><span class="line">Note: checking out <span class="string">'v1.2'</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make <span class="keyword">in</span> this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you want to create a new branch to retain commits you create, you may</span><br><span class="line"><span class="keyword">do</span> so (now or later) by <span class="keyword">using</span> -b with the checkout <span class="keyword">command</span> again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout <span class="literal">-b</span> new_branch_name</span><br><span class="line"></span><br><span class="line">HEAD is now at <span class="number">6844746</span>... Some more changes</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="34"><a href="#34" class="headerlink" title="34:"></a>34:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: checkout_tag_over_branch</span><br><span class="line">Level: <span class="number">34</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You need to fix a bug <span class="keyword">in</span> the version <span class="number">1.2</span> of your app. Checkout the tag `v1.<span class="number">2</span>` (Note: There is also a branch named `v1.<span class="number">2</span>`).</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch</span><br><span class="line">* master</span><br><span class="line">  v1.<span class="number">2</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git tag</span><br><span class="line">v1.<span class="number">0</span></span><br><span class="line">v1.<span class="number">2</span></span><br><span class="line">v1.<span class="number">5</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git checkout tags/v1.<span class="number">2</span></span><br><span class="line">Note: checking out <span class="string">'tags/v1.2'</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make <span class="keyword">in</span> this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you want to create a new branch to retain commits you create, you may</span><br><span class="line"><span class="keyword">do</span> so (now or later) by <span class="keyword">using</span> -b with the checkout <span class="keyword">command</span> again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout <span class="literal">-b</span> new_branch_name</span><br><span class="line"></span><br><span class="line">HEAD is now at <span class="number">4</span>cc8649... Some more changes</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="35"><a href="#35" class="headerlink" title="35:"></a>35:</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: branch_at</span><br><span class="line">Level: 35</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">You forgot to branch at the previous commit and made a commit on top of it. Create branch test_branch at the commit before the last.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">[ecssync@ecssync git_hug]$ git branch</span><br><span class="line">* master</span><br><span class="line">[ecssync@ecssync git_hug]$ git log</span><br><span class="line">commit 33da42e002d4b7fdf3f77865a957b947652d7fda</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul 21 14:47:51 2020 +0800</span><br><span class="line"></span><br><span class="line">    Updating file1 again</span><br><span class="line"></span><br><span class="line">commit 580d1a83c099498c4f92b494edc86646931365b5</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul 21 14:47:50 2020 +0800</span><br><span class="line"></span><br><span class="line">    Updating file1</span><br><span class="line"></span><br><span class="line">commit df106ed800fd05f171152f92cd40268b7eb933b0</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul 21 14:47:50 2020 +0800</span><br><span class="line"></span><br><span class="line">    Adding file1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ecssync@ecssync git_hug]$ git branch test_branch HEAD^1</span><br><span class="line">[ecssync@ecssync git_hug]$ git branch</span><br><span class="line">* master</span><br><span class="line">  test_branch</span><br><span class="line">[ecssync@ecssync git_hug]$ git log</span><br><span class="line">commit 33da42e002d4b7fdf3f77865a957b947652d7fda</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul 21 14:47:51 2020 +0800</span><br><span class="line"></span><br><span class="line">    Updating file1 again</span><br><span class="line"></span><br><span class="line">commit 580d1a83c099498c4f92b494edc86646931365b5</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul 21 14:47:50 2020 +0800</span><br><span class="line"></span><br><span class="line">    Updating file1</span><br><span class="line"></span><br><span class="line">commit df106ed800fd05f171152f92cd40268b7eb933b0</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul 21 14:47:50 2020 +0800</span><br><span class="line"></span><br><span class="line">    Adding file1</span><br><span class="line">[ecssync@ecssync git_hug]$ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="36"><a href="#36" class="headerlink" title="36:"></a>36:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: delete_branch</span><br><span class="line">Level: <span class="number">36</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You have created too many branches <span class="keyword">for</span> your project. There is an old branch <span class="keyword">in</span> your repo called <span class="string">'delete_me'</span>, you should delete it.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch</span><br><span class="line">  delete_me</span><br><span class="line">* master</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch <span class="literal">-d</span> delete_me</span><br><span class="line">Deleted branch delete_me (was b60afe2).</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch</span><br><span class="line">* master</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="37"><a href="#37" class="headerlink" title="37:"></a>37:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: push_branch</span><br><span class="line">Level: <span class="number">37</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You<span class="string">'ve made some changes to a local branch and want to share it, but aren'</span>t yet ready to merge it with the <span class="string">'master'</span> branch.  Push only <span class="string">'test_branch'</span> to the remote repository</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch</span><br><span class="line">* master</span><br><span class="line">  other_branch</span><br><span class="line">  test_branch</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Your branch is ahead of 'origin/master' by 1 commit.</span></span><br><span class="line"><span class="comment">#   (use "git push" to publish your local commits)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git push origin test_branch</span><br><span class="line">Counting objects: <span class="number">7</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up to 8 threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), <span class="number">562</span> bytes | <span class="number">0</span> bytes/s, done.</span><br><span class="line">Total <span class="number">6</span> (delta <span class="number">3</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To /tmp/d20200721<span class="literal">-10878-18gcglj</span>/.git</span><br><span class="line"> * [<span class="type">new</span> <span class="type">branch</span>]      test_branch -&gt; test_branch</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="38"><a href="#38" class="headerlink" title="38:"></a>38:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: merge</span><br><span class="line">Level: <span class="number">38</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">We have a file <span class="keyword">in</span> the branch <span class="string">'feature'</span>; Let<span class="string">'s merge it to the master branch.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git merge feature</span></span><br><span class="line"><span class="string">Updating e12277f..cc8ea5a</span></span><br><span class="line"><span class="string">Fast-forward</span></span><br><span class="line"><span class="string"> file2 | 0</span></span><br><span class="line"><span class="string"> 1 file changed, 0 insertions(+), 0 deletions(-)</span></span><br><span class="line"><span class="string"> create mode 100644 file2</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git status</span></span><br><span class="line"><span class="string"># On branch master</span></span><br><span class="line"><span class="string">nothing to commit, working directory clean</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="39"><a href="#39" class="headerlink" title="39:"></a>39:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: fetch</span><br><span class="line">Level: <span class="number">39</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Looks like a new branch was pushed into our remote repository. Get the changes without merging them with the local repository</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git fetch origin</span><br><span class="line">remote: Counting objects: <span class="number">3</span>, done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">remote: Total <span class="number">2</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">From /tmp/d20200721<span class="literal">-10967-4l6fg4</span>/</span><br><span class="line"> * [<span class="type">new</span> <span class="type">branch</span>]      new_branch -&gt; origin/new_branch</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="40"><a href="#40" class="headerlink" title="40:"></a>40:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: rebase</span><br><span class="line">Level: <span class="number">40</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">We are <span class="keyword">using</span> a git rebase workflow and the feature branch is ready to go into master. Let<span class="string">'s rebase the feature branch onto our master branch.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git branch</span></span><br><span class="line"><span class="string">  feature</span></span><br><span class="line"><span class="string">* master</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git checkout feature</span></span><br><span class="line"><span class="string">Switched to branch '</span>feature<span class="string">'</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git rebase master</span></span><br><span class="line"><span class="string">First, rewinding head to replay your work on top of it...</span></span><br><span class="line"><span class="string">Applying: add feature</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="41-50"><a href="#41-50" class="headerlink" title="41 - 50:"></a>41 - 50:</h4><h5 id="41"><a href="#41" class="headerlink" title="41:"></a>41:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: rebase_onto</span><br><span class="line">Level: <span class="number">41</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You have created your branch from `wrong_branch` and already made some commits, and you realise that you needed to create your branch from `master`. Rebase your commits onto `master` branch so that you don<span class="string">'t have `wrong_branch` commits.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git branch</span></span><br><span class="line"><span class="string">  master</span></span><br><span class="line"><span class="string">* readme-update</span></span><br><span class="line"><span class="string">  wrong_branch</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git log</span></span><br><span class="line"><span class="string">commit ed867debbb0cbf7ce83112f7f72a43744c407cd7</span></span><br><span class="line"><span class="string">Author: ecssync &lt;ecssync@ecssync.local&gt;</span></span><br><span class="line"><span class="string">Date:   Tue Jul 21 15:01:12 2020 +0800</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Add `Install` header in readme</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">commit 385b5fb15c9e65e9c85aa910cf21ec71a78d43c2</span></span><br><span class="line"><span class="string">Author: ecssync &lt;ecssync@ecssync.local&gt;</span></span><br><span class="line"><span class="string">Date:   Tue Jul 21 15:01:12 2020 +0800</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Add `About` header in readme</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">commit 6cf72f834392c2d061d0580d6c70614d78b77713</span></span><br><span class="line"><span class="string">Author: ecssync &lt;ecssync@ecssync.local&gt;</span></span><br><span class="line"><span class="string">Date:   Tue Jul 21 15:01:12 2020 +0800</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Add app name in readme</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">commit b0cacccc9ed0a9b46d7b463533035354d3275196</span></span><br><span class="line"><span class="string">Author: ecssync &lt;ecssync@ecssync.local&gt;</span></span><br><span class="line"><span class="string">Date:   Tue Jul 21 15:01:12 2020 +0800</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Wrong changes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">commit a7bfef30ddb70443802f742f219cc492a0bbddb0</span></span><br><span class="line"><span class="string">Author: ecssync &lt;ecssync@ecssync.local&gt;</span></span><br><span class="line"><span class="string">Date:   Tue Jul 21 15:01:12 2020 +0800</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Create authors file</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git rebase --onto master wrong_branch readme-update</span></span><br><span class="line"><span class="string">First, rewinding head to replay your work on top of it...</span></span><br><span class="line"><span class="string">Applying: Add app name in readme</span></span><br><span class="line"><span class="string">Applying: Add `About` header in readme</span></span><br><span class="line"><span class="string">Applying: Add `Install` header in readme</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="42"><a href="#42" class="headerlink" title="42:"></a>42:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: repack</span><br><span class="line">Level: <span class="number">42</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Optimise how your repository is packaged ensuring that redundant packs are removed.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git <span class="built_in">gc</span></span><br><span class="line">Counting objects: <span class="number">3</span>, done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="43"><a href="#43" class="headerlink" title="43:"></a>43:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: cherry<span class="literal">-pick</span></span><br><span class="line">Level: <span class="number">43</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">Your new feature isn<span class="string">'t worth the time and you'</span>re going to delete it. But it has one commit that fills <span class="keyword">in</span> `README` file, and you want this commit to be on the master as well.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch</span><br><span class="line">* master</span><br><span class="line">  <span class="built_in">new-feature</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git checkout <span class="built_in">new-feature</span></span><br><span class="line">Switched to branch <span class="string">'new-feature'</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log</span><br><span class="line">commit ea2a47c19b85fc321e2737ddc49db3deeba3a1b5</span><br><span class="line">Author: Andrey &lt;aslushnikov@gmail.com&gt;</span><br><span class="line">Date:   Wed Mar <span class="number">28</span> <span class="number">02</span>:<span class="number">28</span>:<span class="number">35</span> <span class="number">2012</span> +<span class="number">0400</span></span><br><span class="line"></span><br><span class="line">    some small fixes</span><br><span class="line"></span><br><span class="line">commit <span class="number">4</span>a1961bce62840eaef9c4392fe5cc799e38c9b7b</span><br><span class="line">Author: Andrey &lt;aslushnikov@gmail.com&gt;</span><br><span class="line">Date:   Wed Mar <span class="number">28</span> <span class="number">02</span>:<span class="number">27</span>:<span class="number">18</span> <span class="number">2012</span> +<span class="number">0400</span></span><br><span class="line"></span><br><span class="line">    Fixed feature</span><br><span class="line"></span><br><span class="line">commit ca32a6dac7b6f97975edbe19a4296c2ee7682f68</span><br><span class="line">Author: Andrey &lt;aslushnikov@gmail.com&gt;</span><br><span class="line">Date:   Wed Mar <span class="number">28</span> <span class="number">02</span>:<span class="number">25</span>:<span class="number">51</span> <span class="number">2012</span> +<span class="number">0400</span></span><br><span class="line"></span><br><span class="line">    Filled <span class="keyword">in</span> README.md with proper input</span><br><span class="line"></span><br><span class="line">commit <span class="number">58</span>a8c8edcfdd00c6d8cce9aada8f987a1677571f</span><br><span class="line">Author: Andrey &lt;aslushnikov@gmail.com&gt;</span><br><span class="line">Date:   Wed Mar <span class="number">28</span> <span class="number">02</span>:<span class="number">24</span>:<span class="number">41</span> <span class="number">2012</span> +<span class="number">0400</span></span><br><span class="line"></span><br><span class="line">    Added a stub <span class="keyword">for</span> the feature</span><br><span class="line"></span><br><span class="line">commit ea3dbcc5e2d2359698c3606b0ec44af9f76def54</span><br><span class="line">Author: Andrey &lt;aslushnikov@gmail.com&gt;</span><br><span class="line">Date:   Wed Mar <span class="number">28</span> <span class="number">02</span>:<span class="number">20</span>:<span class="number">32</span> <span class="number">2012</span> +<span class="number">0400</span></span><br><span class="line"></span><br><span class="line">    Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git cherry<span class="literal">-pick</span> ca32a6dac7b6f97975edbe19a4296c2ee7682f68</span><br><span class="line">[<span class="type">master</span> <span class="number">5</span><span class="type">c78d26</span>] Filled <span class="keyword">in</span> README.md with proper input</span><br><span class="line"> Author: Andrey &lt;aslushnikov@gmail.com&gt;</span><br><span class="line">...</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">2</span> deletions(-)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="44"><a href="#44" class="headerlink" title="44:"></a>44:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: grep</span><br><span class="line">Level: <span class="number">44</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Your project<span class="string">'s deadline approaches, you should evaluate how many TODOs are left in your code</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git grep '</span>TODO<span class="string">' | wc -l</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">How many items are there in your todolist? 4</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="45"><a href="#45" class="headerlink" title="45:"></a>45:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: rename_commit</span><br><span class="line">Level: <span class="number">45</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">Correct the typo <span class="keyword">in</span> the message of your first (non<span class="literal">-root</span>) commit.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log</span><br><span class="line">commit ae9e2f844acb4388bf45d6ee614a22678e5efc61</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">49</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Second commit</span><br><span class="line"></span><br><span class="line">commit ccb0fabfe03aeba0035a0f39e93f1fe17c94edb0</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">49</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    First coommit</span><br><span class="line"></span><br><span class="line">commit <span class="number">240</span>aa55faa57f8d626a3bc68398d6c8ac2216977</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">49</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git rebase <span class="literal">-i</span> HEAD~<span class="number">2</span></span><br><span class="line">[<span class="type">detached</span> <span class="type">HEAD</span> <span class="type">f845aac</span>] First commit</span><br><span class="line"></span><br><span class="line"> <span class="string">"reword"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span><br><span class="line"> create mode <span class="number">100644</span> file1</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log</span><br><span class="line">commit <span class="number">372</span>dd8f04d9997d96e36d4c9eb67ae2867ca6b2d</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">49</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Second commit</span><br><span class="line"></span><br><span class="line">commit f845aac2ddf901e1fabfe13086f89046e8724fa5</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">49</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    First commit</span><br><span class="line"></span><br><span class="line">commit <span class="number">240</span>aa55faa57f8d626a3bc68398d6c8ac2216977</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">49</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="46"><a href="#46" class="headerlink" title="46:"></a>46:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: squash</span><br><span class="line">Level: <span class="number">46</span></span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You have committed several times but would like all those changes to be one commit.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git rebase <span class="literal">-i</span> HEAD~<span class="number">4</span></span><br><span class="line">[<span class="type">detached</span> <span class="type">HEAD</span> <span class="number">3</span><span class="type">d3b91a</span>] Adding README</span><br><span class="line"> Committer: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">... ...</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">3</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> README</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br><span class="line"></span><br><span class="line"><span class="comment">##############################vim editor##############################</span></span><br><span class="line">pick c4fef0e Adding README</span><br><span class="line">squash <span class="number">5</span>caa017 Updating README (squash this commit into Adding README)</span><br><span class="line">squash <span class="number">7</span>bc5942 Updating README (squash this commit into Adding README)</span><br><span class="line">squash <span class="number">9100103</span> Updating README (squash this commit into Adding README)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase a7aa916..9100103 onto a7aa916</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#  p, pick = use commit</span></span><br><span class="line"><span class="comment">#  r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment">#  e, edit = use commit, but stop for amending</span></span><br><span class="line"><span class="comment">#  s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment">#  f, fixup = like "squash", but discard this commit's log message</span></span><br><span class="line"><span class="comment">#  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br><span class="line"><span class="comment">##############################vim editor##############################</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log</span><br><span class="line">commit <span class="number">3</span>d3b91a9e2d2186f6f416bf536e014cbdcec457c</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">21</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Adding README</span><br><span class="line"></span><br><span class="line">    Updating README (squash this commit into Adding README)</span><br><span class="line"></span><br><span class="line">    Updating README (squash this commit into Adding README)</span><br><span class="line"></span><br><span class="line">    Updating README (squash this commit into Adding README)</span><br><span class="line"></span><br><span class="line">commit a7aa9161d36432580de6548d854f79a1116d2f32</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">21</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Initial Commit</span><br><span class="line">    </span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="47"><a href="#47" class="headerlink" title="47:"></a>47:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: merge_squash</span><br><span class="line">Level: <span class="number">47</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">Merge all commits from the long<span class="literal">-feature-branch</span> as a single commit.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch</span><br><span class="line">  long<span class="literal">-feature-branch</span></span><br><span class="line">* master</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git merge <span class="literal">--squash</span> long<span class="literal">-feature-branch</span></span><br><span class="line">Squash commit <span class="literal">--</span> not updating HEAD</span><br><span class="line">Automatic merge went well; stopped before committing as requested</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   file3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">"X"</span></span><br><span class="line">[<span class="type">master</span> <span class="number">77</span><span class="type">ceea7</span>] X</span><br><span class="line"> Committer: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">3</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> file3</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="48"><a href="#48" class="headerlink" title="48:"></a>48:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: reorder</span><br><span class="line">Level: <span class="number">48</span></span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You have committed several times but <span class="keyword">in</span> the wrong order. Please reorder your commits.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line"><span class="comment">#############################vim editor##############################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">pick <span class="number">15176</span>e9 First commit</span><br><span class="line">pick <span class="number">676</span>c1a4 Third commit</span><br><span class="line">pick de1362e Second commit</span><br><span class="line">      ⬇️</span><br><span class="line">pick <span class="number">15176</span>e9 First commit</span><br><span class="line">pick de1362e Second commit   </span><br><span class="line">pick <span class="number">676</span>c1a4 Third commit</span><br><span class="line"><span class="comment">##############################vim editor##############################</span></span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log</span><br><span class="line">commit <span class="number">4</span>d61dc7ea9f0717626a0169b135a7461a8a4e388</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">34</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Third commit</span><br><span class="line"></span><br><span class="line">commit f5ef4d3b972f3317fe5ef530d0b2114955cea0ed</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">34</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Second commit</span><br><span class="line"></span><br><span class="line">commit <span class="number">15176</span>e90ef0de866d9c89795ccc225a119998258</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">34</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    First commit</span><br><span class="line"></span><br><span class="line">commit <span class="number">8</span>ee2035dfaf0814aaa1517a904ffc82163f2b313</span><br><span class="line">Author: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line">Date:   Tue Jul <span class="number">21</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">34</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Initial Setup</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="49"><a href="#49" class="headerlink" title="49:"></a>49:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: bisect</span><br><span class="line">Level: <span class="number">49</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">A bug was introduced somewhere along the way.  You know that running `ruby prog.rb <span class="number">5</span>` should output <span class="number">15</span>.  You can also run `make test`.  What are the first <span class="number">7</span> chars of the hash of the commit that introduced the bug.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log <span class="literal">--pretty</span>=oneline</span><br><span class="line"><span class="number">12628</span>f463f4c722695bf0e9d603c9411287885db Another Commit</span><br><span class="line"><span class="number">979576184</span>c5ec9667cf7593cf550c420378e960f Another Commit</span><br><span class="line"><span class="number">028763</span>b396121e035f672ef5af75d2dcb1cc8146 Another Commit</span><br><span class="line"><span class="number">888386</span>c77c957dc52f3113f2483663e3132559d4 Another Commit</span><br><span class="line">bb736ddd9b83d6296d23444a2ab3b0d2fa6dfb81 Another Commit</span><br><span class="line"><span class="number">18</span>ed2ac1522a014412d4303ce7c8db39becab076 Another Commit</span><br><span class="line"><span class="number">5</span>db7a7cb90e745e2c9dbdd84810ccc7d91d92e72 Another Commit</span><br><span class="line"><span class="number">7</span>c03a99ba384572c216769f0273b5baf3ba83694 Another Commit</span><br><span class="line"><span class="number">9</span>f54462abbb991b167532929b34118113aa6c52e Another Commit</span><br><span class="line"><span class="number">5</span>d1eb75377072c5c6e5a1b0ac4159181ecc4edff Another Commit</span><br><span class="line">fdbfc0d403e5ac0b2659cbfa2cbb061fcca0dc2a Another Commit</span><br><span class="line">a530e7ed25173d0800cfe33cc8915e5929209b8e Another Commit</span><br><span class="line">ccddb96f824a0e929f5fecf55c0f4479552246f3 Another Commit</span><br><span class="line"><span class="number">2</span>e1735d5bef6db0f3e325051a179af280f05573a Another Commit</span><br><span class="line">ffb097e3edfa828afa565eeceee6b506b3f2a131 Another Commit</span><br><span class="line">e060c0d789288fda946f91254672295230b2de9d Another Commit</span><br><span class="line"><span class="number">49774</span>ea84ae3723cc4fac75521435cc04d56b657 Another Commit</span><br><span class="line"><span class="number">8</span>c992afff5e16c97f4ef82d58671a3403d734086 Another Commit</span><br><span class="line"><span class="number">80</span>a9b3d94237f982b6c9052e6d56b930f18a4ef5 Another Commit</span><br><span class="line">f608824888b83bbedc1f658be7496ffea467a8fb First commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git bisect HEAD f608824888b83bbedc1f658be7496ffea467a8fb</span><br><span class="line">usage: git bisect [<span class="type">help</span>|<span class="type">start</span>|<span class="type">bad</span>|<span class="type">good</span>|<span class="type">skip</span>|<span class="type">next</span>|<span class="type">reset</span>|<span class="type">visualize</span>|<span class="type">replay</span>|<span class="type">log</span>|<span class="type">run</span>]</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git bisect <span class="built_in">start</span>  HEAD f608824888b83bbedc1f658be7496ffea467a8fb</span><br><span class="line">Bisecting: <span class="number">9</span> revisions left to test after this (roughly <span class="number">3</span> steps)</span><br><span class="line">[<span class="type">fdbfc0d403e5ac0b2659cbfa2cbb061fcca0dc2a</span>] Another Commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> make test</span><br><span class="line">ruby prog.rb <span class="number">5</span> | ruby test.rb</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git bisect good fdbfc0d403e5ac0b2659cbfa2cbb061fcca0dc2a</span><br><span class="line">Bisecting: <span class="number">4</span> revisions left to test after this (roughly <span class="number">2</span> steps)</span><br><span class="line">[<span class="number">18</span><span class="type">ed2ac1522a014412d4303ce7c8db39becab076</span>] Another Commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git bisect run make test</span><br><span class="line">running make test</span><br><span class="line">ruby prog.rb <span class="number">5</span> | ruby test.rb</span><br><span class="line">make: *** [<span class="type">test</span>] Error <span class="number">1</span></span><br><span class="line">Bisecting: <span class="number">2</span> revisions left to test after this (roughly <span class="number">1</span> step)</span><br><span class="line">[<span class="number">9</span><span class="type">f54462abbb991b167532929b34118113aa6c52e</span>] Another Commit</span><br><span class="line">running make test</span><br><span class="line">ruby prog.rb <span class="number">5</span> | ruby test.rb</span><br><span class="line">Bisecting: <span class="number">0</span> revisions left to test after this (roughly <span class="number">1</span> step)</span><br><span class="line">[<span class="number">5</span><span class="type">db7a7cb90e745e2c9dbdd84810ccc7d91d92e72</span>] Another Commit</span><br><span class="line">running make test</span><br><span class="line">ruby prog.rb <span class="number">5</span> | ruby test.rb</span><br><span class="line"><span class="number">18</span>ed2ac1522a014412d4303ce7c8db39becab076 is the first bad commit</span><br><span class="line">commit <span class="number">18</span>ed2ac1522a014412d4303ce7c8db39becab076</span><br><span class="line">Author: Robert Bittle &lt;guywithnose@gmail.com&gt;</span><br><span class="line">Date:   Mon Apr <span class="number">23</span> <span class="number">06</span>:<span class="number">52</span>:<span class="number">10</span> <span class="number">2012</span> <span class="literal">-0400</span></span><br><span class="line"></span><br><span class="line">    Another Commit</span><br><span class="line"></span><br><span class="line">:<span class="number">100644</span> <span class="number">100644</span> <span class="number">917</span>e70054c8f4a4a79a8e805c0e1601b455ad236 <span class="number">7562257</span>b8e6446686ffc43a2386c50c254365020 M      prog.rb</span><br><span class="line">bisect run success</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What are the first <span class="number">7</span> characters of the hash of the commit that introduced the bug? <span class="number">18</span>ed2ac1522a014412d4303ce7c8db39becab076</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="50"><a href="#50" class="headerlink" title="50:"></a>50:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: stage_lines</span><br><span class="line">Level: <span class="number">50</span></span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You<span class="string">'ve made changes within a single file that belong to two different features, but neither of the changes are yet staged. Stage only the changes belonging to the first feature.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git diff</span></span><br><span class="line"><span class="string">diff --git a/feature.rb b/feature.rb</span></span><br><span class="line"><span class="string">index 1a271e9..4a80dda 100644</span></span><br><span class="line"><span class="string">--- a/feature.rb</span></span><br><span class="line"><span class="string">+++ b/feature.rb</span></span><br><span class="line"><span class="string">@@ -1 +1,3 @@</span></span><br><span class="line"><span class="string"> this is the class of my feature</span></span><br><span class="line"><span class="string">+This change belongs to the first feature</span></span><br><span class="line"><span class="string">+This change belongs to the second feature   ----------&gt; remove</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git add -e feature.rb</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git diff</span></span><br><span class="line"><span class="string">diff --git a/feature.rb b/feature.rb</span></span><br><span class="line"><span class="string">index 3bccd0e..4a80dda 100644</span></span><br><span class="line"><span class="string">--- a/feature.rb</span></span><br><span class="line"><span class="string">+++ b/feature.rb</span></span><br><span class="line"><span class="string">@@ -1,2 +1,3 @@</span></span><br><span class="line"><span class="string"> this is the class of my feature</span></span><br><span class="line"><span class="string"> This change belongs to the first feature</span></span><br><span class="line"><span class="string">+This change belongs to the second feature</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git status</span></span><br><span class="line"><span class="string"># On branch master</span></span><br><span class="line"><span class="string"># Changes to be committed:</span></span><br><span class="line"><span class="string">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#       modified:   feature.rb</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Changes not staged for commit:</span></span><br><span class="line"><span class="string">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="string">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#       modified:   feature.rb</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="51-56"><a href="#51-56" class="headerlink" title="51 - 56:"></a>51 - 56:</h4><h5 id="51"><a href="#51" class="headerlink" title="51:"></a>51:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: find_old_branch</span><br><span class="line">Level: <span class="number">51</span></span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You have been working on a branch but got distracted by a major issue and forgot the name of it. <span class="keyword">Switch</span> back to that branch.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch</span><br><span class="line">  blowup_sun_for_ransom</span><br><span class="line">  cure_common_cold</span><br><span class="line">* kill_the_batman</span><br><span class="line">  solve_world_hunger</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git reflog</span><br><span class="line"><span class="number">894</span>a16d HEAD<span class="selector-tag">@</span>{<span class="number">0</span>}: commit: commit another todo</span><br><span class="line"><span class="number">6876</span>e5b HEAD<span class="selector-tag">@</span>{<span class="number">1</span>}: checkout: moving from solve_world_hunger to kill_the_batman</span><br><span class="line"><span class="number">324336</span>a HEAD<span class="selector-tag">@</span>{<span class="number">2</span>}: commit: commit todo</span><br><span class="line"><span class="number">6876</span>e5b HEAD<span class="selector-tag">@</span>{<span class="number">3</span>}: checkout: moving from blowup_sun_for_ransom to solve_world_hunger</span><br><span class="line"><span class="number">6876</span>e5b HEAD<span class="selector-tag">@</span>{<span class="number">4</span>}: checkout: moving from kill_the_batman to blowup_sun_for_ransom</span><br><span class="line"><span class="number">6876</span>e5b HEAD<span class="selector-tag">@</span>{<span class="number">5</span>}: checkout: moving from cure_common_cold to kill_the_batman</span><br><span class="line"><span class="number">6876</span>e5b HEAD<span class="selector-tag">@</span>{<span class="number">6</span>}: commit (initial): initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git checkout solve_world_hunger</span><br><span class="line">Switched to branch <span class="string">'solve_world_hunger'</span></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="52"><a href="#52" class="headerlink" title="52:"></a>52:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: revert</span><br><span class="line">Level: <span class="number">52</span></span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You have committed several times but want to undo the middle commit.</span><br><span class="line">All commits have been pushed, so you can<span class="string">'t change existing history.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">A:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git log --pretty=oneline</span></span><br><span class="line"><span class="string">b2803390aa23abd6ff45faf62b117f002b612218 Second commit</span></span><br><span class="line"><span class="string">1d140556c1ca8af6e70a8e98abc5e83491dc9f80 Bad commit</span></span><br><span class="line"><span class="string">46445b467625aac78ef3ab499d79f7b7229c199f First commit</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git revert 1d140556c1ca8af6e70a8e98abc5e83491dc9f80 --no-edit</span></span><br><span class="line"><span class="string">[master a77bae5] Revert "Bad commit"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> delete mode 100644 file3</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ git log --pretty=oneline</span></span><br><span class="line"><span class="string">a77bae5a86c856cbb8f417b6c6f8c9f7ddf8c538 Revert "Bad commit"</span></span><br><span class="line"><span class="string">b2803390aa23abd6ff45faf62b117f002b612218 Second commit</span></span><br><span class="line"><span class="string">1d140556c1ca8af6e70a8e98abc5e83491dc9f80 Bad commit</span></span><br><span class="line"><span class="string">46445b467625aac78ef3ab499d79f7b7229c199f First commit</span></span><br><span class="line"><span class="string">[ecssync@ecssync git_hug]$ githug</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">*                                    Githug                                    *</span></span><br><span class="line"><span class="string">********************************************************************************</span></span><br><span class="line"><span class="string">Congratulations, you have solved the level!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="53"><a href="#53" class="headerlink" title="53:"></a>53:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: restore</span><br><span class="line">Level: <span class="number">53</span></span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You decided to delete your latest commit by running `git reset <span class="literal">--hard</span> HEAD^`.  (Not a smart thing to <span class="keyword">do</span>.)  You then change your mind, and want that commit back.  Restore the deleted commit.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log <span class="literal">--pretty</span>=oneline</span><br><span class="line"><span class="number">5</span>d4f0fe4f22a0b4fa72084b16bce2accab6b5ce4 First commit</span><br><span class="line"><span class="number">70</span>fec1926947443bd760b8e8c79fbb86d3b462fe Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git reflog</span><br><span class="line"><span class="number">5</span>d4f0fe HEAD<span class="selector-tag">@</span>{<span class="number">0</span>}: reset: moving to HEAD^</span><br><span class="line">d7de144 HEAD<span class="selector-tag">@</span>{<span class="number">1</span>}: commit: Restore this commit</span><br><span class="line"><span class="number">5</span>d4f0fe HEAD<span class="selector-tag">@</span>{<span class="number">2</span>}: commit: First commit</span><br><span class="line"><span class="number">70</span>fec19 HEAD<span class="selector-tag">@</span>{<span class="number">3</span>}: commit (initial): Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git reset <span class="literal">--hard</span> d7de144</span><br><span class="line">HEAD is now at d7de144 Restore this commit</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git log <span class="literal">--pretty</span>=oneline</span><br><span class="line">d7de144da5c4f506ab085a7a34e8a21c0b5c0db3 Restore this commit</span><br><span class="line"><span class="number">5</span>d4f0fe4f22a0b4fa72084b16bce2accab6b5ce4 First commit</span><br><span class="line"><span class="number">70</span>fec1926947443bd760b8e8c79fbb86d3b462fe Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git reflog</span><br><span class="line">d7de144 HEAD<span class="selector-tag">@</span>{<span class="number">0</span>}: reset: moving to d7de144</span><br><span class="line"><span class="number">5</span>d4f0fe HEAD<span class="selector-tag">@</span>{<span class="number">1</span>}: reset: moving to HEAD^</span><br><span class="line">d7de144 HEAD<span class="selector-tag">@</span>{<span class="number">2</span>}: commit: Restore this commit</span><br><span class="line"><span class="number">5</span>d4f0fe HEAD<span class="selector-tag">@</span>{<span class="number">3</span>}: commit: First commit</span><br><span class="line"><span class="number">70</span>fec19 HEAD<span class="selector-tag">@</span>{<span class="number">4</span>}: commit (initial): Initial commit</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span></span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="54"><a href="#54" class="headerlink" title="54:"></a>54:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: conflict</span><br><span class="line">Level: <span class="number">54</span></span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You need to merge mybranch into the current branch (master). But there may be some incorrect changes <span class="keyword">in</span> mybranch which may cause conflicts. Solve any <span class="built_in">merge-conflicts</span> you come across and finish the merge.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git branch</span><br><span class="line">* master</span><br><span class="line">  mybranch</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git merge mybranch</span><br><span class="line">Auto<span class="literal">-merging</span> poem.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> poem.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># You have unmerged paths.</span></span><br><span class="line"><span class="comment">#   (fix conflicts and run "git commit")</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unmerged paths:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to mark resolution)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       both modified:      poem.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git <span class="built_in">diff</span></span><br><span class="line"><span class="built_in">diff</span> <span class="literal">--cc</span> poem.txt</span><br><span class="line">index <span class="number">3</span>cb65be,<span class="number">1</span>db9aa5..<span class="number">0000000</span></span><br><span class="line"><span class="literal">---</span> a/poem.txt</span><br><span class="line">+++ b/poem.txt</span><br><span class="line"><span class="selector-tag">@</span><span class="selector-tag">@</span><span class="selector-tag">@</span> <span class="literal">-1</span>,<span class="number">5</span> <span class="literal">-1</span>,<span class="number">4</span> +<span class="number">1</span>,<span class="number">8</span> <span class="selector-tag">@</span><span class="selector-tag">@</span><span class="selector-tag">@</span></span><br><span class="line">  Humpty dumpty</span><br><span class="line">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"> +Categorized shoes by color</span><br><span class="line">++=======</span><br><span class="line">+ Sat on a wall</span><br><span class="line">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mybranch</span><br><span class="line">  Humpty dumpty</span><br><span class="line">  Had a great fall</span><br><span class="line">-</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> vim poem.txt</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git status <span class="literal">-s</span></span><br><span class="line">UU poem.txt</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git add .</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">"Merge from mybranch"</span></span><br><span class="line">[<span class="type">master</span> <span class="type">f9adf97</span>] Merge from mybranch</span><br><span class="line"> Committer: ecssync &lt;ecssync@ecssync.local&gt;</span><br><span class="line"> ... ...</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="55"><a href="#55" class="headerlink" title="55:"></a>55:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Q:</span><br><span class="line"></span><br><span class="line">Name: submodule</span><br><span class="line">Level: <span class="number">55</span></span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You want to include the files from the following repo: `https://github.com/jackmaney/githug<span class="literal">-include-me</span>` into a the folder `./githug<span class="literal">-include-me</span>`. <span class="keyword">Do</span> this without manually cloning the repo or copying the files from the repo into this repo.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> git submodule add https://github.com/jackmaney/githug<span class="literal">-include-me</span></span><br><span class="line">Cloning into <span class="string">'githug-include-me'</span>...</span><br><span class="line">remote: Enumerating objects: <span class="number">9</span>, done.</span><br><span class="line">remote: Total <span class="number">9</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack<span class="literal">-reused</span> <span class="number">9</span></span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">9</span>/<span class="number">9</span>), done.</span><br><span class="line">[<span class="type">ecssync</span>@<span class="type">ecssync</span> <span class="type">git_hug</span>]<span class="variable">$</span> githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></tbody></table></figure>

<h5 id="56"><a href="#56" class="headerlink" title="56:"></a>56:</h5><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">Name: contribute</span><br><span class="line">Level: <span class="number">56</span></span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">This is the final level, the goal is to contribute to this repository by making a pull request on GitHub.  Please note that this level is designed to encourage you to add a valid contribution to Githug, not testing your ability to create a pull request.  Contributions that are likely to be accepted are levels, bug fixes and improved documentation.</span><br></pre></td></tr></tbody></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote>
<p><a href="https://wiki.jikexueyuan.com/project/githug-walkthrough/levels.html">https://wiki.jikexueyuan.com/project/githug-walkthrough/levels.html</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS 系列：图解 HDFS</title>
    <url>/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习 <code>HDFS</code>，看到一篇很有意思的文章，通过漫画的形式来讲解 <code>HDFS</code> 的原理，可以很好地帮助初学者入门。</p>
<p>为什么市面上大多数的教材和技术书籍，要讲内容将的晦涩难懂，入门体验非常差。希望能多一些这种漫画的风趣幽默，并且通俗易懂的书出现，寓教于乐才是学习的高境界。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="漫画"><a href="#漫画" class="headerlink" title="漫画"></a>漫画</h1><h2 id="1-写数据"><a href="#1-写数据" class="headerlink" title="1 写数据"></a>1 写数据</h2><p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast.jpeg" alt="img"></p>
<p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209220809400.jpeg" alt="img"></p>
<p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209220903614.jpeg" alt="img"></p>
<h2 id="2-读数据"><a href="#2-读数据" class="headerlink" title="2 读数据"></a>2 读数据</h2><p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209221028578.jpeg" alt="img"></p>
<h2 id="3-容错"><a href="#3-容错" class="headerlink" title="3 容错"></a>3 容错</h2><p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209221103836.jpeg" alt="img"></p>
<p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209221137547.jpeg" alt="img"></p>
<p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209221235394.jpeg" alt="img"></p>
<p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209221255039.jpeg" alt="img"></p>
<h2 id="4-副本布局"><a href="#4-副本布局" class="headerlink" title="4 副本布局"></a>4 副本布局</h2><p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209221313685.jpeg" alt="img"></p>
<p><img src="/2023/02/09/HDFS%E7%B3%BB%E5%88%97-%E5%9B%BE%E8%A7%A3HDFS/SouthEast-20230209221339122.jpeg" alt="img"></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://www.mail-archive.com/common-user@hadoop.apache.org/msg15171.html">HDFS Explained as Comics</a></li>
<li><a href="https://blog.csdn.net/hudiefenmu/article/details/37655491">HDFS 原理讲解漫画 之一 系统构成和写数据过程</a></li>
<li><a href="https://blog.csdn.net/hudiefenmu/article/details/37694503">HDFS 原理讲解漫画 之二 读数据和容错</a></li>
<li><a href="https://blog.csdn.net/hudiefenmu/article/details/37820789">HDFS 原理讲解漫画 之三 容错和副本布局策略</a></li>
</ul>
]]></content>
      <categories>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>存储</tag>
        <tag>大数据</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 技术路线</title>
    <url>/2020/05/10/Java%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>总结了一些 java 后端技术栈，记录备用。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<p>脑图</p>
<p><img src="/2020/05/10/Java%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF/java-path.jpg" alt="java技术路线"></p>
]]></content>
      <categories>
        <category>Architect</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 枚举详解</title>
    <url>/2020/06/02/Java%E6%9E%9A%E4%B8%BE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="1-为什么要用枚举"><a href="#1-为什么要用枚举" class="headerlink" title="1 为什么要用枚举"></a>1 为什么要用枚举</h3><p>一般情况下，我们可以用常量来进行一些类型的定义。以开发流程的状态为列，开发流程一般分为：<code>design</code>, <code>develop</code>,<code>test</code>,<code>release</code> 几个阶段，可以使用几个静态常量来定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Development</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DESIGN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEVELOP</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TEST</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RELEASE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<p>这种定义其实也是可以的，但是会存在一些隐患。比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkStatus</span><span class="params">(<span class="type">int</span> status)</span>{</span><br><span class="line">...</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p>这个方法的本意是根据数据的数字来判断 <code>Development</code> 的状态，但是如果输入 <code>0~4</code> 范围以外的 <code>int</code> 编译器也不会抛出任何的警告。</p>
<p>但是枚举可以使用更强更严谨的约束，可以帮我们规避掉这个风险，并且代码也更加简洁，有更好的可读性。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DevelopEnum</span> {</span><br><span class="line">    Plan, Develop, Test, Release;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们在编写的时候，编译器此时就可以帮我们检查问题，防止我们疏忽造成问题。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkStatus</span><span class="params">(DevelopEnum status)</span> {</span><br><span class="line">...</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-枚举的基本实现原理"><a href="#2-枚举的基本实现原理" class="headerlink" title="2 枚举的基本实现原理"></a>2 枚举的基本实现原理</h3><p>实际上，枚举本身也是一个类，我们可以通过编译上面的 <code>DevelopEnum.java</code> 文件，可以得到一个 <code>DevelopEnum.clsss</code> 文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Mark:enumeration mark$ ls</span><br><span class="line">Check.java       DevelopEnum.java Development.java</span><br><span class="line">Mark:enumeration mark$ javac DevelopEnum.java </span><br><span class="line">Mark:enumeration mark$ ls</span><br><span class="line">Check.java        DevelopEnum.class DevelopEnum.java  Development.java</span><br></pre></td></tr></tbody></table></figure>

<p>将 <code>DevelopEnum.class</code> 反编译可得到一下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Mark:enumeration mark$ javap DevelopEnum.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">"DevelopEnum.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">interview</span>.enumeration.DevelopEnum <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;interview.enumeration.DevelopEnum&gt; {</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> interview.enumeration.DevelopEnum Plan;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> interview.enumeration.DevelopEnum Develop;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> interview.enumeration.DevelopEnum Test;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> interview.enumeration.DevelopEnum Release;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> interview.enumeration.DevelopEnum[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> interview.enumeration.DevelopEnum <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">static</span> {};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可知，编译器帮我生成了一个 <code>DevelopEnum</code> 的类，该类继承自 <code>java.lang.Enum</code> ，并且该类是无法被继承的 <code>final</code> ; 还生成了 4 个 <code>DevelopEnum</code> 的实例对象，分别对应枚举中定义的 4 个变量，这也说明了，我使用的枚举变量其实是 <code>DevelopEnum</code> 的对象；同时编译器生成了 2 个 <code>static</code> 方法，分别是 <code>values()</code> 和 <code>valueOf()</code>; 最后还有一个空的静态代码块 <code>static {}</code>。</p>
<p>其中 <code>values()</code> 和 <code>valueOf()</code>：</p>
<p>查看了一下 <code>Enum.java</code> 其中只有 <code>valueOf()</code> 并没有 <code>values()</code>，所以 <code>values()</code> 应该是编译器为我们生成的。作用分别为：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">DevelopEnum[] developEnums = DevelopEnum.values();        System.out.println(Arrays.toString(developEnums));<span class="comment">// [Plan, Develop, Test, Release]</span></span><br><span class="line"><span class="type">DevelopEnum</span> <span class="variable">value</span> <span class="operator">=</span> DevelopEnum.valueOf(<span class="string">"Plan"</span>);</span><br><span class="line">System.out.println(value); <span class="comment">// Plan</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-枚举常用方法"><a href="#3-枚举常用方法" class="headerlink" title="3 枚举常用方法"></a>3 枚举常用方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="type">DevelopEnum</span> <span class="variable">d1</span> <span class="operator">=</span> DevelopEnum.Plan;</span><br><span class="line">    <span class="type">DevelopEnum</span> <span class="variable">d2</span> <span class="operator">=</span> DevelopEnum.Develop;</span><br><span class="line">    <span class="type">DevelopEnum</span> <span class="variable">d3</span> <span class="operator">=</span> DevelopEnum.Test;</span><br><span class="line">    <span class="type">DevelopEnum</span> <span class="variable">d4</span> <span class="operator">=</span> DevelopEnum.Release;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ordinal() 返回枚举的序列号，从0开始</span></span><br><span class="line">    System.out.println(d1.ordinal()); <span class="comment">// 0</span></span><br><span class="line">    System.out.println(d2.ordinal()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compareTo() 枚举常量的比较</span></span><br><span class="line">    System.out.println(d1.compareTo(d2)); <span class="comment">// -1</span></span><br><span class="line">    System.out.println(d2.compareTo(d1)); <span class="comment">// 1 </span></span><br><span class="line">    System.out.println(d3.compareTo(d3)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//name() 获取枚举常量的名称</span></span><br><span class="line">    System.out.println(d1.name()); <span class="comment">// Plan</span></span><br><span class="line">    System.out.println(d2.name()); <span class="comment">// Develop</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-枚举的自定义扩充"><a href="#4-枚举的自定义扩充" class="headerlink" title="4 枚举的自定义扩充"></a>4 枚举的自定义扩充</h3><p>上面的例子是比较简单的<strong>单值</strong>用法，很多情况下我们需要<strong>多值</strong>用法， 我们就前面的例子继续拓展。通过前面的学习我们也知道枚举本身是一个类，所以我们也可以在枚举的定义中加入属性、构造函数、方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DevelopEnumNew</span> {</span><br><span class="line">    Plan(<span class="string">"plan"</span>, <span class="number">000</span>),</span><br><span class="line">    Develop(<span class="string">"develop"</span>, <span class="number">111</span>),</span><br><span class="line">    Test(<span class="string">"test"</span>, <span class="number">222</span>),</span><br><span class="line">    Release(<span class="string">"release"</span>, <span class="number">333</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String stage;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    DevelopEnumNew(String stage, Integer code) {</span><br><span class="line">        <span class="built_in">this</span>.stage = stage;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStage</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getCodeByStageName</span><span class="params">(String stage)</span>{</span><br><span class="line">        <span class="keyword">for</span> (DevelopEnumNew enums : DevelopEnumNew.values()) {</span><br><span class="line">            <span class="keyword">if</span> (enums.stage.equals(stage)) {</span><br><span class="line">                <span class="keyword">return</span> enums.getCode();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>既然是类，那自然也可以和接口 (<code>interface</code>) 结合使用，举个例子：</p>
<p><strong>a. 当不使用枚举时：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">checkStatus</span><span class="params">(String status)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"Plan"</span>.equals(status)) {</span><br><span class="line">        result = <span class="string">"Status: "</span> + <span class="string">"Plan"</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Develop"</span>.equals(status)) {</span><br><span class="line">        result = <span class="string">"Status: "</span> + <span class="string">"Develop"</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Test"</span>.equals(status)) {</span><br><span class="line">        result = <span class="string">"Status: "</span> + <span class="string">"Test"</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Release"</span>.equals(status)) {</span><br><span class="line">        result = <span class="string">"Status: "</span> + <span class="string">"Release"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>b. 使用枚举时：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">checkStatus</span><span class="params">(DevelopEnum status)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">switch</span> (status) {</span><br><span class="line">        <span class="keyword">case</span> Plan:</span><br><span class="line">            result = <span class="string">"Status: "</span> + <span class="string">"Plan"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Develop:</span><br><span class="line">            result = <span class="string">"Status: "</span> + <span class="string">"Develop"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Test:</span><br><span class="line">            result = <span class="string">"Status: "</span> + <span class="string">"Test"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Release:</span><br><span class="line">            result = <span class="string">"Status: "</span> + <span class="string">"Release"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>c. 使用枚举 + 接口时：</strong></p>
<p>接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">logging</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>枚举：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">DevelopEnumImpl</span> <span class="keyword">implements</span> <span class="title class_">logging</span> {</span><br><span class="line">    Plan {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">log</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Plan"</span>;</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    Develop {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">log</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Develop"</span>;</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    Test {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">log</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Test"</span>;</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    Release {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">log</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Release"</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>用法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">checkStatusImpl</span><span class="params">(String status)</span> {</span><br><span class="line">    <span class="keyword">return</span> DevelopEnumImpl.valueOf(status).log();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对比可知，明显枚举 + 接口的方法具有更强的拓展性，并且代码也更加优雅。如果想要对条件继续扩充的话，可以再定义新的借口，再到枚举中添加代码，而不用对主逻辑的代码进行改动。</p>
<h3 id="5-枚举的集合类"><a href="#5-枚举的集合类" class="headerlink" title="5 枚举的集合类"></a>5 枚举的集合类</h3><h4 id="a-EnumSet"><a href="#a-EnumSet" class="headerlink" title="a. EnumSet"></a>a. EnumSet</h4><p><code>EnumSet</code> 是枚举类型专用的 <code>Set</code> 集合。<code>EnumSet</code> 不允许使用 <code>null</code> 元素，如果再 <code>EnumSet</code> 当中插入 <code>null</code>，则会跑出 <code>NullPointerException</code>，但是如果判断 <code>EnumSet</code> 当中是否存在 <code>null</code> 元素是否存在，或者删除 <code>null</code> 元素则不会抛异常。<code>EnumSet</code> 不是线程安全的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">isDev</span><span class="params">(Dev dev)</span>{</span><br><span class="line">    EnumSet&lt;DevelopEnum&gt; enums = EnumSet.of(DevelopEnum.Plan, DevelopEnum.Develop);</span><br><span class="line">    <span class="keyword">if</span> (enums.contains(dev.getName())) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="b-EnumMap"><a href="#b-EnumMap" class="headerlink" title="b. EnumMap"></a>b. EnumMap</h4><p><code>EnumMap</code> 是枚举的专属集合，其 <code>Key</code> 要求必须为 <code>Enum</code> 类型。注意 <code>EnumMap</code> 的 <code>Key</code> 不能为 <code>null</code>，因为 <code>EnumMap</code> 继承了 <code>AbstractMap</code>，所以 <code>EnumMap</code> 也有一般 <code>map</code> 的方法。还有个不同的地方是，在 <code>new EnumMap&lt;&gt;(enum.class);&nbsp;</code>需要传入类型信息，即 <code>Class</code> 对象。</p>
<p>假设 PM 要统计所有项目的开发状态：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">EnumMap&lt;DevelopEnum, Integer&gt; enumIntegerEnumMap = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(DevelopEnum.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Project project: projects) {</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> enumIntegerEnumMap.get(project.getDevStatus);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != num) {</span><br><span class="line">        enumIntegerEnumMap.put(project.getDevStatus, num+<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        enumIntegerEnumMap.put(project.getDevStatus, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-枚举的设计模式应用"><a href="#6-枚举的设计模式应用" class="headerlink" title="6 枚举的设计模式应用"></a>6 枚举的设计模式应用</h3><h4 id="a-单例模式"><a href="#a-单例模式" class="headerlink" title="a. 单例模式"></a>a. 单例模式</h4><h4 id="b-策略模式"><a href="#b-策略模式" class="headerlink" title="b. 策略模式"></a>b. 策略模式</h4>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP 匹配算法</title>
    <url>/2022/06/14/KMP%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>好几次遇到关于 KMP 匹配算法的使用，但是每次看到以后都忘了，所以这里做个记录。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<p>在 B 站看到三哥的 2 个视频，算是讲 KMP 最简单通俗的视频了：</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1kJ411u7pt">KMP 算法原理和流程</a></li>
<li><a href="https://www.bilibili.com/video/BV1iJ411u74L?t=350">如何创建 next 数组 (前缀)</a></li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> {</span><br><span class="line">        <span class="keyword">if</span> (haystack == <span class="literal">null</span> || needle == <span class="literal">null</span> || haystack.length() &lt; needle.length()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((haystack.length() == <span class="number">0</span> &amp;&amp; needle.length() == <span class="number">0</span>) || (haystack.length() &gt; <span class="number">0</span> &amp;&amp; needle.length() == <span class="number">0</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// KMP的核心，先创建next数组</span></span><br><span class="line">        <span class="type">int</span>[] next = genNext(needle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.length(); i++) {</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) {</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) {</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == needle.length()) {</span><br><span class="line">                <span class="keyword">return</span> i - (j - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] genNext(String needle) {</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        }</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; needle.length(); i++) {</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) {</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i) == needle.charAt(j)) {</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java AQS 详解</title>
    <url>/2021/07/15/Java-AQS%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>AbstractQueuedSynchroizer 简称 AQS，是一个抽象的队列式同步框架，提供了阻塞锁和 FIFO 队列实现同步操作，用来构建锁和同步器。JUC 包中的同步类基本都是基于 AQS 同步器来实现的，如 ReentrantLock，Semaphore 等。</p>
<p>AQS 采用了模板方法设计模式，支持通过子类重写相应的方法实现不同的同步器。在 AQS 中，有一个 state 变量，表示同步状态 (同步状态可以看作是一种资源，对同步状态的获取可以看作是对同步资源的竞争)，AQS 提供了多种获取同步状态的方式，包括独占式获取、共享式获取以及超时获取等。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1 核心思想"></a>1 核心思想</h1><p>假设，有四个线程由于业务需求需要同时占用某资源，但该资源在同一个时刻只能被其中唯一线程所独占。那么此时应该如何标识该资源已经被独占，同时剩余无法获取该资源的线程应该如何竞争？</p>
<p><img src="/2021/07/15/Java-AQS%E8%AF%A6%E8%A7%A3/AQS.png" alt="AQS"></p>
<p>这里就涉及到了关于共享资源的竞争与同步关系。对于不同的场景来说，实现的思路可能会有不同。AQS 正是为了解决这个问题而被设计出来的。AQS 是一个集同步状态管理、线程阻塞、线程释放及队列管理功能于一身的同步框架。其核心思想是当多个线程竞争资源时会将未成功竞争到资源的线程构造为 Node 节点放置到一个双向 FIFO 队列中。被放入到该队列中的线程会保持阻塞直至被前驱节点唤醒。值得注意的是该队列中只有队首节点有资格被唤醒竞争锁。</p>
<p>AQS 使用一个 int 成员变量 state 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The synchronization state.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></tbody></table></figure>

<p>状态变量 state 通过 procted 类型的 getState，setState，compareAndSetState 方法操作，改变同步状态。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment">   * This operation has memory semantics of a {<span class="doctag">@code</span> volatile} read.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> {</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment">   * This operation has memory semantics of a {<span class="doctag">@code</span> volatile} write.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> {</span><br><span class="line">      state = newState;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment">   * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment">   * This operation has memory semantics of a {<span class="doctag">@code</span> volatile} read</span></span><br><span class="line"><span class="comment">   * and write.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment">   *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//原子地(CAS操作)将同步状态值设置为给定值update, 如果当前同步状态的值等于expect(期望值)</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> {</span><br><span class="line">      <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="2-CLH锁队列"><a href="#2-CLH锁队列" class="headerlink" title="2 CLH锁队列"></a>2 CLH 锁队列</h1><p>同步队列被称为 CLH 队列，是 Craig，Landin，Hagersten 的合称。AQS 通过内置的 FIFO 同步双向队列来完成资源获取线程的排队工作，内部通过节点 head <code>实际上是虚拟节点，真正的第一个线程在head.next的位置</code>和 tail 记录队首和队尾元素，队列元素类型为 Node。</p>
<p><img src="/2021/07/15/Java-AQS%E8%AF%A6%E8%A7%A3/CLH.png" alt="CLH"></p>
<p>CLH 是虚拟的双向队列，底层是双向链表，包括 head 节点和 tail 结点，仅存在结点之间的关联关系。AQS 将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点 (Node) 来实现锁的分配。</p>
<ul>
<li>如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程</li>
<li>当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</li>
</ul>
<h2 id="Node-数据结构分析"><a href="#Node-数据结构分析" class="headerlink" title="Node 数据结构分析"></a>Node 数据结构分析</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">// 结点的数据结构  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">       <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">       <span class="comment">// 表示该节点等待模式为共享式，通常记录于nextWaiter，</span></span><br><span class="line">   		<span class="comment">// 通过判断nextWaiter的值可以判断当前结点是否处于共享模式</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">   </span><br><span class="line">       <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">       <span class="comment">// 表示节点处于独占式模式，与SHARED相对</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    		<span class="comment">//waitStatus的不同状态，具体内容见下文的表格</span></span><br><span class="line">       <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">       <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">        * unconditionally propagate</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 记录前置结点</span></span><br><span class="line">       <span class="keyword">volatile</span> Node prev;</span><br><span class="line">			<span class="comment">// 记录后置结点</span></span><br><span class="line">       <span class="keyword">volatile</span> Node next;</span><br><span class="line">			<span class="comment">// 记录当前的线程</span></span><br><span class="line">       <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">        * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">        * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">        * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">        * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">        * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">        * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">        * mode.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">   		<span class="comment">// 用于记录共享模式(SHARED), 也可以用来记录CONDITION队列</span></span><br><span class="line">       Node nextWaiter;</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// 通过nextWaiter的记录值判断当前结点的模式是否为共享模式</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> {</span><br><span class="line">           <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取当前结点的前置结点</span></span><br><span class="line">       <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException {</span><br><span class="line">           <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">           <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">   		<span class="comment">// 用于初始化时创建head结点或者创建SHARED结点</span></span><br><span class="line">       Node() {    </span><br><span class="line">       }</span><br><span class="line">			<span class="comment">// 在addWaiter方法中使用，用于创建一个新的结点</span></span><br><span class="line">       Node(Thread thread, Node mode) {     <span class="comment">// Used by addWaiter</span></span><br><span class="line">           <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">           <span class="built_in">this</span>.thread = thread;</span><br><span class="line">       }</span><br><span class="line">			<span class="comment">// 在CONDITION队列中使用该构造函数新建结点</span></span><br><span class="line">       Node(Thread thread, <span class="type">int</span> waitStatus) { <span class="comment">// Used by Condition</span></span><br><span class="line">           <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">           <span class="built_in">this</span>.thread = thread;</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">    * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">    * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">    * CANCELLED.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="comment">// 记录头结点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">    * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="comment">// 记录尾结点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Node-的状态表「waitStatus」"><a href="#Node-的状态表「waitStatus」" class="headerlink" title="Node 的状态表「waitStatus」"></a>Node 的状态表「waitStatus」</h2><table>
<thead>
<tr>
<th align="left">状态名</th>
<th align="center">状态值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"> INITAL</td>
<td align="center">0</td>
<td align="left"> 节点初始化默认值</td>
</tr>
<tr>
<td align="left"> CANCELLED</td>
<td align="center">1</td>
<td align="left"> 取消状态，如果当前线程的前置节点状态为 CANCELLED，则表明前置节点已经等待超时或者已经被中断了，这时需要将其从等待队列中删除</td>
</tr>
<tr>
<td align="left"> SIGNAL</td>
<td align="center">-1</td>
<td align="left"> 等待触发状态，如果当前线程的<strong>前置</strong>节点状态为 SIGNAL，则表明当前线程需要阻塞</td>
</tr>
<tr>
<td align="left"> CONDITION</td>
<td align="center">-2</td>
<td align="left"> 等待条件状态，表示当前节点在等待 condition，即在 condition 队列中。当其他线程对 Condtion 调用了 signal 方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中</td>
</tr>
<tr>
<td align="left"> PROPAGATE</td>
<td align="center">-3</td>
<td align="left"> 状态需要向后传播，表示 releaseShared 需要被传播给后续节点，仅在共享锁模式下使用</td>
</tr>
</tbody></table>
<h1 id="3-AQS对资源的共享方式"><a href="#3-AQS对资源的共享方式" class="headerlink" title="3 AQS对资源的共享方式"></a>3 AQS 对资源的共享方式</h1><p>线程同步的关键是对 state 进行操作，根据 state 是否属于一个线程，操作 state 的方式有两种模式。<br><strong>a. 独占模式「Exclusive」</strong>：只有一个线程能执行。使用独占的方式获取的资源是与具体线程绑定的，如果一个线程获取到了资源，便标记这个线程已经获取到，其他线程再次尝试操作 state 获取资源时就会发现当前该资源不是自己持有的，就会在获取失败后阻塞。又可分为公平锁和非公平锁：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序获取锁；</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的，所以非公平锁效率较高；</li>
</ul>
<p><strong>b 共享模式「 Share 」</strong>：多个线程可同时执行。对应共享方式的资源与具体线程是不相关的，当多个线程去请求资源时通过 CAS 方式竞争获取资源，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用 CAS 方式进行获取即可。</p>
<h1 id="4-AQS的设计模式"><a href="#4-AQS的设计模式" class="headerlink" title="4 AQS的设计模式"></a>4 AQS 的设计模式</h1><p>AQS 同步器的设计是基于模板方法模式。使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。实现对于共享资源 state 的获取和释放。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"> tryAcquire(int arg)</td>
<td align="left"><strong> 独占模式</strong>尝试获取资源。实现该方法需要查询当前状态是否符合预期，然后进行相应的状态更新实现控制 (获取成功返回 true，否则返回 false，成功通常是可以更新同步状态，失败则是不符合更新同步状态的条件)，其中 arg 表示需要获取的同步状态数</td>
</tr>
<tr>
<td align="left"> tryRelease(int arg)</td>
<td align="left"><strong> 独占模式</strong>尝试释放资源。同时更新同步状态 (通常在同步状态 state 更新为 0 才会返回 true，表示已经彻底释放同步资源)，其中 arg 表示需要释放的同步状态数</td>
</tr>
<tr>
<td align="left"> tryAcquireShared(int arg)</td>
<td align="left"><strong> 共享式</strong>获取同步状态，同时更新同步状态。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>
</tr>
<tr>
<td align="left">tryReleaseShared(int arg)</td>
<td align="left"><strong> 共享式</strong>释放同步状态，同时更新同步状态。</td>
</tr>
<tr>
<td align="left">isHeldExclusively()</td>
<td align="left"> 一般用于判断同步器是否被当前线程独占，只有用到 condition 才需要去实现它。</td>
</tr>
</tbody></table>
<h1 id="5-继承的父类"><a href="#5-继承的父类" class="headerlink" title="5 继承的父类"></a>5 继承的父类</h1><p>AbstractQueuedSynchronizer 继承自 AbstractOwnableSynchronizer 抽象类，并且实现了 Serializable 接口，可以进行序列化。</p>
<p>AbstractOwnableSynchronizer 源码分析</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Use serial ID even though all fields transient. */</span></span><br><span class="line">  	<span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3737899427754241961L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Empty constructor for use by subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractOwnableSynchronizer</span><span class="params">()</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The current owner of exclusive mode synchronization.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 独占模式下的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the thread that currently owns exclusive access.</span></span><br><span class="line"><span class="comment">     * A {<span class="doctag">@code</span> null} argument indicates that no thread owns access.</span></span><br><span class="line"><span class="comment">     * This method does not otherwise impose any synchronization or</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@code</span> volatile} field accesses.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thread the owner thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 设置独占线程 </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> {</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the thread last set by {<span class="doctag">@code</span> setExclusiveOwnerThread},</span></span><br><span class="line"><span class="comment">     * or {<span class="doctag">@code</span> null} if never set.  This method does not otherwise</span></span><br><span class="line"><span class="comment">     * impose any synchronization or {<span class="doctag">@code</span> volatile} field accesses.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the owner thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 获取独占线程 </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="6-核心方法介绍"><a href="#6-核心方法介绍" class="headerlink" title="6 核心方法介绍"></a>6 核心方法介绍</h1><p>此文档中，先介绍 AQS 中核心的方法，在使用中，进行串联。</p>
<h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once {<span class="doctag">@link</span> #tryAcquire},</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking {<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire} until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method {<span class="doctag">@link</span> Lock#lock}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        {<span class="doctag">@link</span> #tryAcquire} but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="comment">// 如果线程直接获取成功，或者再尝试获取成功后都是直接工作，</span></span><br><span class="line">  <span class="comment">// 如果是从阻塞状态中唤醒开始工作的线程，将当前的线程中断</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当一个线程调用 acquire 时，调用方法流程如下</p>
<p><img src="/2021/07/15/Java-AQS%E8%AF%A6%E8%A7%A3/raftuserstudy2013.png" alt="raftuserstudy2013"></p>
<ol>
<li>首先调用 tryAcquire 方法，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。在 AbstractQueuedSynchronizer 源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。</li>
<li>若 tryAcquire 失败，则调用 addWaiter 方法，addWaiter 方法完成的功能是将调用此方法的线程封装成为一个结点并放入 CLH 队列中。</li>
<li>调用 acquireQueued 方法，此方法完成的功能是 CLH 中的结点不断尝试获取资源，若成功，则返回 true，否则，返回 false。</li>
</ol>
<h2 id="tryAcquire-override"><a href="#tryAcquire-override" class="headerlink" title="tryAcquire - override"></a>tryAcquire - override</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 需要子类去重写此方法完成自己的逻辑 - 试图在独占模式下获取对象状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 添加等待者</span></span><br><span class="line">  <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> {</span><br><span class="line">    	<span class="comment">// 新生成一个结点，默认为独占模式 addWaiter(Node.EXCLUSIVE)</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">      <span class="comment">// 保存尾结点 </span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">      <span class="keyword">if</span> (pred != <span class="literal">null</span>) { <span class="comment">// 尾结点不为空，队列已经有节点在等待</span></span><br><span class="line">          node.prev = pred; <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetTail(pred, node)) {  <span class="comment">// 比较pred是否为尾结点，是-则将尾结点设置为node </span></span><br><span class="line">              pred.next = node; <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">              <span class="keyword">return</span> node; <span class="comment">// 返回新生成的结点</span></span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      enq(node); <span class="comment">// 第一次往队列中新增节点时，会执行enq方法，或者是compareAndSetTail操作失败，则入队列</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 将节点插入阻塞队列 - 尾结点</span></span><br><span class="line">  <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> {</span><br><span class="line">      <span class="keyword">for</span> (;;) { <span class="comment">// 无线循环，确保节点的成功插入</span></span><br><span class="line">          <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// 保存尾结点</span></span><br><span class="line">          <span class="keyword">if</span> (t == <span class="literal">null</span>) { <span class="comment">// 尾结点为空，即还没被初始化</span></span><br><span class="line">              <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) <span class="comment">// 头结点为空，并设置头结点为新生成的结点	</span></span><br><span class="line">                  tail = head; <span class="comment">// 头结点与尾结点都指向同一个新生结点</span></span><br><span class="line">          } <span class="keyword">else</span> { <span class="comment">// 尾结点不为空，即已经被初始化过</span></span><br><span class="line">              node.prev = t; <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">              <span class="keyword">if</span> (compareAndSetTail(t, node)) { <span class="comment">// 比较结点t是否为尾结点，是-则将尾结点设置为node</span></span><br><span class="line">                  t.next = node; <span class="comment">// 设置node为新的尾结点</span></span><br><span class="line">                  <span class="keyword">return</span> t; <span class="comment">// 返回原-尾结点</span></span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h2><p>首先获取当前节点的前驱节点，如果前驱节点是头结点并且能够获取 (资源)，代表该当前节点能够占有锁，设置头结点为当前节点，返回。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">   * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if interrupted while waiting</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 以独占不间断模式获取已在队列中的阻塞线程。</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> {</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 标志</span></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 中断标志</span></span><br><span class="line">          <span class="keyword">for</span> (;;) { <span class="comment">// 无限循环</span></span><br><span class="line">              <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); <span class="comment">// 获取node节点的前驱结点</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) { <span class="comment">// 前驱为头结点并且成功获得锁</span></span><br><span class="line">                  setHead(node); <span class="comment">// 设置头结点</span></span><br><span class="line">                  p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="literal">false</span>; <span class="comment">// 设置标志</span></span><br><span class="line">                  <span class="keyword">return</span> interrupted;</span><br><span class="line">              }</span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)&amp;&amp;<span class="comment">//当获取(资源)失败后，检查并且更新结点状态</span></span><br><span class="line">                  parkAndCheckInterrupt()) <span class="comment">//执行park操作</span></span><br><span class="line">                  interrupted = <span class="literal">true</span>;</span><br><span class="line">          }</span><br><span class="line">      } <span class="keyword">finally</span> {</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>acquireQueued 方法的整个的逻辑：</p>
<ol>
<li>判断结点的前驱是否为 head 并且当前线程是否再次成功获取 (资源)。</li>
<li>若步骤 1 均满足，则设置结点为 head，之后会判断是否 finally 模块，然后返回。</li>
<li>若步骤 2 不满足，则判断是否需要 park 当前线程，是否需要 park 当前线程的逻辑是判断结点的前驱结点的状态是否为 SIGNAL，若是，则 park 当前结点，否则，不进行 park 操作。</li>
<li>若 park 了当前线程，之后某个线程对本线程 unpark 后，并且本线程也获得机会运行。那么，将会继续进行步骤 1 的判断。</li>
</ol>
<h2 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h2><p>只有当该节点的前驱结点的状态为 SIGNAL 时，才可以对该结点所封装的线程进行 park 操作。否则，将不能进行 park 操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">   * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">   * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if thread should block</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 当获取(资源)失败后，检查并且更新结点状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> {</span><br><span class="line">      <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus; <span class="comment">// 获取前驱结点的状态</span></span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 如果前驱结点的状态为SIGNAL，那么当前的结点应该阻塞（SIGNAL定义）</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">           * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 可以进行park操作</span></span><br><span class="line">      <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) { <span class="comment">// 如果前驱结点已经为取消状态（CANCELLED 1 &gt; 0）则向前遍历，直到找到一个有效的结点</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">           * indicate retry.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">do</span> {</span><br><span class="line">              node.prev = pred = pred.prev;</span><br><span class="line">          } <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>); <span class="comment">// 找到pred结点前面最近的一个状态不为CANCELLED的结点</span></span><br><span class="line">          pred.next = node; <span class="comment">// 将当前结点与新找到的前驱结点连接</span></span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">           * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">           * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">       	 	<span class="comment">// 到这里的结点状态可能为：CONDITION 和 PROPAGATE，比较并设置前驱结点的状态为SIGNAL</span></span><br><span class="line">          compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能进行park操作</span></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h2><p>parkAndCheckInterrupt 方法里的逻辑是首先执行 park 操作，即禁用当前线程，然后返回该线程是否已经被中断。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if interrupted</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 进行park操作并且返回该线程是否被中断</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> {</span><br><span class="line">    	<span class="comment">// 在许可可用之前禁用当前线程，并且设置了blocker</span></span><br><span class="line">      LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">return</span> Thread.interrupted();  <span class="comment">// 当前线程是否已被中断，并清除中断标记位</span></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h2><p>该方法完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为 CANCELLED</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 取消线程继续获取资源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> {</span><br><span class="line">      <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// node为空，返回</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      node.thread = <span class="literal">null</span>; <span class="comment">// 设置node结点的thread为空</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev; <span class="comment">// 保存node的前驱结点</span></span><br><span class="line">      <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">//若前驱结点为CANCELLED转态，继续向前遍历，找到第一个状态小于0的结点</span></span><br><span class="line">          node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">      <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">      <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;<span class="comment">// 获取pred结点的下一个结点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">      <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">      <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">      node.waitStatus = Node.CANCELLED;<span class="comment">// 设置当前node结点的状态为CANCELLED</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">      <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) { <span class="comment">//如果node结点为尾结点，则设置尾结点为pred结点</span></span><br><span class="line">          compareAndSetNext(pred, predNext, <span class="literal">null</span>); <span class="comment">// 比较并设置pred结点的next节点为null</span></span><br><span class="line">      } <span class="keyword">else</span> { <span class="comment">// node结点不为尾结点，或者比较设置新的尾结点不成功</span></span><br><span class="line">          <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">          <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">          <span class="type">int</span> ws;</span><br><span class="line">          <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">              ((ws = pred.waitStatus) == Node.SIGNAL || <span class="comment">// pred结点不为头结点，并且pred结点的状态为SIGNAL</span></span><br><span class="line">               (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; <span class="comment">// 或者pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功</span></span><br><span class="line">              pred.thread != <span class="literal">null</span>) { <span class="comment">// 并且pred结点所封装的线程不为空</span></span><br><span class="line">              <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next; <span class="comment">// 保存node结点的后继结点</span></span><br><span class="line">              <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 后继不为空并且后继的状态小于等于0</span></span><br><span class="line">                  compareAndSetNext(pred, predNext, next); <span class="comment">// 比较并设置pred.next = next;</span></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">              unparkSuccessor(node); <span class="comment">// 唤醒当前node结点的后继结点</span></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          node.next = node; <span class="comment">// help GC</span></span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h2><p>该方法的作用就是为了释放 node 节点的后继结点。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 唤醒当前node结点的后继结点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> {</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">      * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">      * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus; <span class="comment">// 获取node结点的等待状态</span></span><br><span class="line">     <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)  <span class="comment">// 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3</span></span><br><span class="line">         compareAndSetWaitStatus(node, ws, <span class="number">0</span>);  <span class="comment">// 比较并且设置结点等待状态，设置为INITAL 0 </span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">      * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">      * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">      * non-cancelled successor.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next; <span class="comment">// 获取node的后继结点</span></span><br><span class="line">     <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) { <span class="comment">//如果node的后继结点为空，或者结点等待状态CANCELLED 1</span></span><br><span class="line">         s = <span class="literal">null</span>; <span class="comment">// s赋值为空</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从尾结点开始从后往前开始遍历</span></span><br><span class="line">             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">// 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点</span></span><br><span class="line">                 s = t; <span class="comment">// 保存结点</span></span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">if</span> (s != <span class="literal">null</span>) <span class="comment">// 该结点不为为空，释放许可</span></span><br><span class="line">         LockSupport.unpark(s.thread);</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p>以独占模式释放对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if {<span class="doctag">@link</span> #tryRelease} returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method {<span class="doctag">@link</span> Lock#unlock}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        {<span class="doctag">@link</span> #tryRelease} but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from {<span class="doctag">@link</span> #tryRelease}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) { <span class="comment">// 释放成功(自定义实现)</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// 保存头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 头结点不为空并且头结点状态不为0</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">//释放头结点的后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="tryRelease-override"><a href="#tryRelease-override" class="headerlink" title="tryRelease - override"></a>tryRelease - override</h2><p>tryRelease 的默认实现是抛出异常，需要具体的子类实现，如果 tryRelease 成功，那么如果头结点不为空并且头结点的状态不为 INITAL 0，则释放头结点的后继结点</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to set the state to reflect a release in exclusive</span></span><br><span class="line"><span class="comment"> * mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is always invoked by the thread performing release.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation throws</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> UnsupportedOperationException}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument. This value is always the one</span></span><br><span class="line"><span class="comment"> *        passed to a release method, or the current state value upon</span></span><br><span class="line"><span class="comment"> *        entry to a condition wait.  The value is otherwise</span></span><br><span class="line"><span class="comment"> *        uninterpreted and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this object is now in a fully released</span></span><br><span class="line"><span class="comment"> *         state, so that any waiting threads may attempt to acquire;</span></span><br><span class="line"><span class="comment"> *         and {<span class="doctag">@code</span> false} otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if releasing would place this</span></span><br><span class="line"><span class="comment"> *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment"> *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment"> *         correctly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException if exclusive mode is not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h2><p>将结点从 Condition 队列转移到 Sync 队列</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment"> * Returns true if successful.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment"> * cancelled before signal)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))<span class="comment">//将结点从CONDITION状态改为初始化状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node); <span class="comment">// 结点状态改为0，并且加入资源队列，p为node的前置结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus; <span class="comment">// 获取p的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) <span class="comment">// 如果前置结点为CANCELLED状态 或者 状态设置为SIGNAL失败</span></span><br><span class="line">        LockSupport.unpark(node.thread); <span class="comment">// 将node结点解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h2><p>使用当前状态值调用 release； 返回保存状态。 取消节点并在失败时抛出异常。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment">   * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 将当前的结点以独占模式释放资源，并且保留当前状态</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> {</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 保存释放是否成功的状态</span></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">          <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState(); <span class="comment">// 获取当前结点状态</span></span><br><span class="line">          <span class="keyword">if</span> (release(savedState)) { <span class="comment">// 以独占模式释放资源</span></span><br><span class="line">              failed = <span class="literal">false</span>; <span class="comment">// 结点释放成功</span></span><br><span class="line">              <span class="keyword">return</span> savedState; <span class="comment">// 返回同步状态</span></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(); <span class="comment">// 结点释放失败，抛出异常</span></span><br><span class="line">          }</span><br><span class="line">      } <span class="keyword">finally</span> {</span><br><span class="line">          <span class="keyword">if</span> (failed) <span class="comment">// 释放失败</span></span><br><span class="line">              node.waitStatus = Node.CANCELLED; <span class="comment">// 将结点状态标记为 CANCELLED</span></span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h2><p>如果一个结点（始终是最初放置在 Condition 队列中的结点）现在正在等待重新获取同步队列，则返回 true。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if a node, always one that was initially placed on</span></span><br><span class="line"><span class="comment"> * a condition queue, is now waiting to reacquire on sync queue.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if is reacquiring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>) <span class="comment">// 如果状态是CONDITION 或者 结点是队列第一个结点 (不在CLH队列)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"> 		<span class="comment">//如果当前节点有next指针（next指针只在CLH队列中的节点有，条件队列中的节点是nextWaiter）的话，就返回true (Condition队列中 下个结点是用 nextWaiter)</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">     * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">     * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">     * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">     * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">     * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node); <span class="comment">//如果上面无法快速判断的话，就只能从CLH队列中进行遍历，一个一个地去进行判断了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="findNodeFromTail"><a href="#findNodeFromTail" class="headerlink" title="findNodeFromTail"></a>findNodeFromTail</h2><p>从 CLH 队列的最后结点向前遍历，依次判断</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if node is on sync queue by searching backwards from tail.</span></span><br><span class="line"><span class="comment"> * Called only when needed by isOnSyncQueue.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if present</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="transferAfterCancelledWait"><a href="#transferAfterCancelledWait" class="headerlink" title="transferAfterCancelledWait"></a>transferAfterCancelledWait</h2><p>如有必要，在取消等待后将节点传输到同步队列。如果线程在发出信号之前被取消，则返回 true。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers node, if necessary, to sync queue after a cancelled wait.</span></span><br><span class="line"><span class="comment"> * Returns true if thread was cancelled before being signalled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if cancelled before the node was signalled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> {</span><br><span class="line">   <span class="comment">// 尝试使用CAS操作将node(CONDITION状态) 的ws设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) { </span><br><span class="line">        enq(node); <span class="comment">// 设置成功后，进入CLH队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we lost out to a signal(), then we can't proceed</span></span><br><span class="line"><span class="comment">     * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">     * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">     * spin.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) <span class="comment">// 判断节点是否在CLH队列中（不在队列中）</span></span><br><span class="line">        Thread.yield(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="7-扩展"><a href="#7-扩展" class="headerlink" title="7 扩展"></a>7 扩展</h1><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition 接口</h2><p>Contition 是一种广义上的条件队列，它利用 await () 和 signal () 为线程提供了一种<strong>更为灵活的等待 / 通知模式</strong>。</p>
<p>Condition 必须要配合 Lock 一起使用，因为对共享状态变量的访问发生在多线程环境下。一个 Condition 的实例必须与一个 Lock 绑定，因此 await 和 signal 的调用必须在 lock 和 unlock 之间，有锁之后，才能使用 condition。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> {</span><br><span class="line">	  <span class="comment">// 使当前线程等待，直到它收到信号或被中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  	<span class="comment">// 使当前线程等待，直到它收到信号</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">  	<span class="comment">// 使当前线程等待，直到它被发出信号或被中断，或者指定的等待时间过去</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  	<span class="comment">// 使当前线程等待，直到它被发出信号或被中断，或者指定的等待时间过去</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  	<span class="comment">// 使当前线程等待，直到它被发出信号或被中断，或者指定的截止日期过去</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  	<span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">  	<span class="comment">// 唤醒所有等待线程</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="ConditionObject内部类"><a href="#ConditionObject内部类" class="headerlink" title="ConditionObject内部类"></a>ConditionObject 内部类</h2><p>ConditionObject 是 AQS 的内部类，实现了 Condition 接口，Lock 中提供 newCondition () 方法，委托给内部 AQS 的实现 Sync 来创建 ConditionObject 对象，使用 AQS 中定义的 Condition。</p>
<p>ConditionObject 用来结合锁实现线程同步，<strong>ConditionObject 可以直接访问 AQS 对象内部的变量，比如 state 状态值和 AQS 队列</strong>。ConditionObject 是条件变量，每个条件变量对应一个<strong>条件队列</strong>（单向链表队列），用来存放调用条件变量的 await 方法后被阻塞的线程。</p>
<p>需要明确这里的 Condition 队列和 CLH 同步队列是不一样的：</p>
<ul>
<li>AQS 维护的是当前在等待资源的队列，Condition 维护的是在等待 signal 信号的队列；</li>
<li>每个线程会存在上述两个队列中的一个，lock 与 unlock 对应在 AQS 队列，signal 与 await 对应条件队列，线程节点在他们之间进行切换；</li>
</ul>
<h2 id="构造方法-属性"><a href="#构造方法-属性" class="headerlink" title="构造方法 + 属性"></a>构造方法 + 属性</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable {</span><br><span class="line">  	<span class="comment">// 序列化版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">   <span class="comment">// condition队列的头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">  	<span class="comment">// condition队列的尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionObject</span><span class="params">()</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For interruptible waits, we need to track whether to throw</span></span><br><span class="line"><span class="comment">     * InterruptedException, if interrupted while blocked on</span></span><br><span class="line"><span class="comment">     * condition, versus reinterrupt current thread, if</span></span><br><span class="line"><span class="comment">     * interrupted while blocked waiting to re-acquire.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">     * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">     * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> {</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">            <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Throws InterruptedException, reinterrupts current thread, or</span></span><br><span class="line"><span class="comment">     * does nothing, depending on mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements absolute timed condition wait.</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Save lock state returned by {<span class="doctag">@link</span> #getState}.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Invoke {<span class="doctag">@link</span> #release} with saved state as argument,</span></span><br><span class="line"><span class="comment">     *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">     *      {<span class="doctag">@link</span> #acquire} with saved state as argument.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">long</span> <span class="variable">abstime</span> <span class="operator">=</span> deadline.getTime();</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timedout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) {</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt; abstime) {</span><br><span class="line">                timedout = transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            LockSupport.parkUntil(<span class="built_in">this</span>, abstime);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> !timedout;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Save lock state returned by {<span class="doctag">@link</span> #getState}.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Invoke {<span class="doctag">@link</span> #release} with saved state as argument,</span></span><br><span class="line"><span class="comment">     *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">     *      {<span class="doctag">@link</span> #acquire} with saved state as argument.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">long</span> <span class="variable">nanosTimeout</span> <span class="operator">=</span> unit.toNanos(time);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timedout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) {</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) {</span><br><span class="line">                timedout = transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> !timedout;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  support for instrumentation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this condition was created by the given</span></span><br><span class="line"><span class="comment">     * synchronization object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if owned</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOwnedBy</span><span class="params">(AbstractQueuedSynchronizer sync)</span> {</span><br><span class="line">        <span class="keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries whether any threads are waiting on this condition.</span></span><br><span class="line"><span class="comment">     * Implements {<span class="doctag">@link</span> AbstractQueuedSynchronizer#hasWaiters(ConditionObject)}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if there are any waiting threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if {<span class="doctag">@link</span> #isHeldExclusively}</span></span><br><span class="line"><span class="comment">     *         returns {<span class="doctag">@code</span> false}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasWaiters</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter; w != <span class="literal">null</span>; w = w.nextWaiter) {</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an estimate of the number of threads waiting on</span></span><br><span class="line"><span class="comment">     * this condition.</span></span><br><span class="line"><span class="comment">     * Implements {<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the estimated number of waiting threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if {<span class="doctag">@link</span> #isHeldExclusively}</span></span><br><span class="line"><span class="comment">     *         returns {<span class="doctag">@code</span> false}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getWaitQueueLength</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter; w != <span class="literal">null</span>; w = w.nextWaiter) {</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                ++n;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a collection containing those threads that may be</span></span><br><span class="line"><span class="comment">     * waiting on this Condition.</span></span><br><span class="line"><span class="comment">     * Implements {<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if {<span class="doctag">@link</span> #isHeldExclusively}</span></span><br><span class="line"><span class="comment">     *         returns {<span class="doctag">@code</span> false}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title function_">getWaitingThreads</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter; w != <span class="literal">null</span>; w = w.nextWaiter) {</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION) {</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    list.add(t);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="内部方法（private）"><a href="#内部方法（private）" class="headerlink" title="内部方法（private）"></a>内部方法（private）</h2><h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 添加新的waiter到wait队列</span></span><br><span class="line"> <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> {</span><br><span class="line">   	<span class="comment">// 保存尾结点</span></span><br><span class="line">     <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">     <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">     <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) {<span class="comment">// 尾结点不为空，并且尾结点的状态不为CONDITION</span></span><br><span class="line">         unlinkCancelledWaiters(); <span class="comment">// 清除状态不为CONDITION(为CANCELLED)的结点</span></span><br><span class="line">         t = lastWaiter;</span><br><span class="line">     }</span><br><span class="line">     <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION); <span class="comment">// 新建一个结点</span></span><br><span class="line">     <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="comment">// 尾结点为空</span></span><br><span class="line">         firstWaiter = node; <span class="comment">// 设置condition队列的头结点</span></span><br><span class="line">     <span class="keyword">else</span> <span class="comment">// 尾结点不为空，说明队列不为空</span></span><br><span class="line">         t.nextWaiter = node; <span class="comment">// 设置为节点的nextWaiter域为node结点</span></span><br><span class="line">     lastWaiter = node; <span class="comment">// 更新node结点为condition队列的尾结点</span></span><br><span class="line">     <span class="keyword">return</span> node;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">  * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">  * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 把Condition队列第一个不为空的结点，转移到Sync结点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> {</span><br><span class="line">     <span class="keyword">do</span> { <span class="comment">// 循环</span></span><br><span class="line">         <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>) <span class="comment">// 该节点的nextWaiter为空</span></span><br><span class="line">             lastWaiter = <span class="literal">null</span>; <span class="comment">// 设置尾结点为空 </span></span><br><span class="line">         first.nextWaiter = <span class="literal">null</span>; <span class="comment">// 设置first结点的nextWaiter域</span></span><br><span class="line">     } <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; <span class="comment">// 将结点从condition队列转移到sync队列失败</span></span><br><span class="line">              (first = firstWaiter) != <span class="literal">null</span>); <span class="comment">// 并且condition队列中的头结点不为空，一直循环</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="doSignalAll"><a href="#doSignalAll" class="headerlink" title="doSignalAll"></a>doSignalAll</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and transfers all nodes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将CONDITION队列中的全部结点移除并加入到同步队列中竞争同步状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> {</span><br><span class="line">    <span class="comment">// condition队列的头结点尾结点都设置为空</span></span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> {<span class="comment">// 循环</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter; <span class="comment">// 获取first结点的nextWaiter域结点</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>; <span class="comment">// 设置first结点的nextWaiter域为空(切断第一个结点)</span></span><br><span class="line">        transferForSignal(first); <span class="comment">// 将first结点从condition队列转移到sync队列</span></span><br><span class="line">        first = next; <span class="comment">// 重新设置first</span></span><br><span class="line">    } <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">  * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">  * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">  * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">  * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">  * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">  * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">  * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">  * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">  * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">  * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">  * storms.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 清除condition队列中，状态为为CANCELLED的结点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> {</span><br><span class="line">     <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter; <span class="comment">// 保存condition队列头结点</span></span><br><span class="line">     <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">     <span class="keyword">while</span> (t != <span class="literal">null</span>) { <span class="comment">// t不为空</span></span><br><span class="line">         <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter; <span class="comment">// 下一个结点</span></span><br><span class="line">         <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) { <span class="comment">// t结点的状态不为CONDTION状态（为CANCELLED）</span></span><br><span class="line">             t.nextWaiter = <span class="literal">null</span>; <span class="comment">// 设置t节点的nextWaiter为空</span></span><br><span class="line">             <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                 firstWaiter = next;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 trail.nextWaiter = next;</span><br><span class="line">             <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                 lastWaiter = trail;</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">else</span> <span class="comment">// t结点的状态为CONDTION状态</span></span><br><span class="line">             trail = t; <span class="comment">// 设置trail结点</span></span><br><span class="line">         t = next; <span class="comment">// 设置t结点为下一个结点</span></span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="公共方法-（public）"><a href="#公共方法-（public）" class="headerlink" title="公共方法 （public）"></a>公共方法 （public）</h2><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">  * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">  * owning lock.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalMonitorStateException if {<span class="doctag">@link</span> #isHeldExclusively}</span></span><br><span class="line"><span class="comment">  *         returns {<span class="doctag">@code</span> false}</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 将等待时间最长的线程（如果存在）从此条件的等待队列移动到拥有锁的等待队列。</span></span><br><span class="line"> <span class="comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> {</span><br><span class="line">     <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占（非独占模式），抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">     <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter; <span class="comment">// 获取头结点</span></span><br><span class="line">     <span class="keyword">if</span> (first != <span class="literal">null</span>) </span><br><span class="line">         doSignal(first);  <span class="comment">// 把Condition队列第一个不为空的结点，转移到Sync结点</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Moves all threads from the wait queue for this condition to</span></span><br><span class="line"><span class="comment">  * the wait queue for the owning lock.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalMonitorStateException if {<span class="doctag">@link</span> #isHeldExclusively}</span></span><br><span class="line"><span class="comment">  *         returns {<span class="doctag">@code</span> false}</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 将所有结点从等待队列移动到拥有锁的等待队列。</span></span><br><span class="line"><span class="comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> {</span><br><span class="line">     <span class="keyword">if</span> (!isHeldExclusively())  <span class="comment">// 不被当前线程独占（非独占模式），抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">     <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">     <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">         doSignalAll(first); <span class="comment">// 将CONDITION队列中的全部结点移除并加入到同步队列中竞争同步状态</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>使当前线程等待，直到它收到信号或被中断</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Save lock state returned by {<span class="doctag">@link</span> #getState}.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Invoke {<span class="doctag">@link</span> #release} with saved state as argument,</span></span><br><span class="line"><span class="comment"> *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment"> *      {<span class="doctag">@link</span> #acquire} with saved state as argument.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())  <span class="comment">// 当前线程被中断，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter(); <span class="comment">// 在wait队列上添加一个结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node); <span class="comment">// 获取释放的状态（激活后置结点的状态）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) { <span class="comment">// 判断节点是否在CLH队列中（不在队列中），说明该线程还不具备竞争锁的资格</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);   <span class="comment">// 阻塞当前线程</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) <span class="comment">// 如果线程中断，退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">              <span class="comment">// 上面的循环退出有两种情况：</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node) 为true，即当前的node已经转移到CLH队列了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting != 0, 表示线程中断</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) <span class="comment">// 退出循环，被唤醒之后，进入阻塞队列，等待获取锁 acquireQueued</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters(); <span class="comment">// 线程中断，清除condition队列中，状态为为CANCELLED的结点</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="awaitNanos"><a href="#awaitNanos" class="headerlink" title="awaitNanos"></a>awaitNanos</h3><p>使当前线程等待，直到它被发出信号或被中断，或者指定的等待时间过去</p>
<p> 所有 awaitXX 方法其实就是:	</p>
<ol>
<li>将当前的线程封装成 Node 加入到 Condition 里面；</li>
<li>丢到当前线程所拥有的独占锁</li>
<li>等待 其他获取 独占锁的线程的唤醒，唤醒从 Condition Queue 到 Sync Queue 里面，进而获取独占锁 </li>
<li>最后获取 lock 之后，在根据线程唤醒的方式 (signal/interrupt) 进行处理 *  4. 最后还是需要调用 lock./unlock 进行释放锁 </li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements timed condition wait.</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Save lock state returned by {<span class="doctag">@link</span> #getState}.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Invoke {<span class="doctag">@link</span> #release} with saved state as argument,</span></span><br><span class="line"><span class="comment"> *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment"> *      {<span class="doctag">@link</span> #acquire} with saved state as argument.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter(); <span class="comment">// 将结点添加到Condition等待队列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node); <span class="comment">// 获取释放的状态（激活后置结点的状态）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout; <span class="comment">// 等待截止时间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) { <span class="comment">// 判断节点是否在CLH队列中（不在队列中）</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) { <span class="comment">// 等待时间到了</span></span><br><span class="line">            transferAfterCancelledWait(node);<span class="comment">//将Node 从 Condition 转移到 Sync Queue 里面</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">   <span class="comment">// 当剩余时间 &lt; spinForTimeoutThreshold, 其实函数 spin 比用 LockSupport.parkNanos 更高效</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold) </span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout); <span class="comment">// 进行线程的 block</span></span><br><span class="line">      <span class="comment">// 判断此次线程的唤醒是否因为线程被中断, 若是被中断, 则会在checkInterruptWhileWaiting的transferAfterCancelledWait 进行节点的转移; 返回值 interruptMode != 0</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nanosTimeout = deadline - System.nanoTime(); <span class="comment">// 更新一下还需要等待多久</span></span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 调用独占锁的获取, 返回值表明在获取的过程中有没有被中断过</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">  <span class="comment">// 通过 "node.nextWaiter != null" 判断 线程的唤醒是中断还是 signal, 因为通过中断唤醒的话, 此刻代表线程的 Node 在 Condition Queue 与 Sync Queue 里面都会存在</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">        unlinkCancelledWaiters(); <span class="comment">// 进行 cancelled 节点的清除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>) <span class="comment">// 代表通过中断的方式唤醒线程</span></span><br><span class="line">      <span class="comment">// 根据 interruptMode 的类型决定是抛出异常, 还是自己再中断一下</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode); </span><br><span class="line">    <span class="keyword">return</span> deadline - System.nanoTime(); <span class="comment">// 这个返回值代表是 通过 signal;还是超时</span></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h3 id="awaitUninterruptibly"><a href="#awaitUninterruptibly" class="headerlink" title="awaitUninterruptibly"></a>awaitUninterruptibly</h3><p>使当前线程等待，直到它收到信号（不会响应中断）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements uninterruptible condition wait.</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Save lock state returned by {<span class="doctag">@link</span> #getState}.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Invoke {<span class="doctag">@link</span> #release} with saved state as argument,</span></span><br><span class="line"><span class="comment">     *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Block until signalled.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">     *      {<span class="doctag">@link</span> #acquire} with saved state as argument.</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter(); <span class="comment">// 将结点添加到Condition等待队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node); <span class="comment">// 获取释放的状态（激活后置结点的状态）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) { <span class="comment">// 判断节点是否在CLH队列中（不在队列中）</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">// 以独占不间断模式获取已在队列中的阻塞线程</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><p><a href="https://www.cnblogs.com/summerday152/p/14238284.html">Java 并发包源码学习系列：AbstractQueuedSynchronizer</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903782636060679#heading-4">AQS 原理学习笔记</a></p>
</li>
<li><p><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">一行一行源码分析清楚 AbstractQueuedSynchronizer</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/summerday152/p/14288122.html#void-await">Java 并发包源码学习系列：详解 Condition 条件队列、signal 和 await</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性算法：Paxos</title>
    <url>/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/</url>
    <content><![CDATA[<h1 id="1-引言（什么是Paxos）"><a href="#1-引言（什么是Paxos）" class="headerlink" title="1 引言（什么是Paxos）"></a>1 引言（什么是 Paxos）</h1><p>分布式系统流行的当下，集群的机器总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（还有消息延迟、丢失、重复、乱序）等问题。分布式式一致性（强一致性）算法就是在系统中出现以上异常情况时，如何快速且正确地在集群内部对某个数据或者命令达成一致，并且保证不会破坏整个集群的一致性。Paxos 就是此类算法中一种，并且在分布式领域有着非常重要的地位。</p>
<blockquote>
<p>Paxos 算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。</p>
</blockquote>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="2-一个问题"><a href="#2-一个问题" class="headerlink" title="2 一个问题"></a>2 一个问题</h1><p>由一个实际场景作为出发点，介绍 Paxos（来自 Diego Ongaro）算法</p>
<p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20210704161321540.png" alt="image-20210704161321540"></p>
<p>假设服务端 (Servers) 系统是实现了多副本状态机 (<strong>Replicated state machine</strong>)，客户端发送的命令将会被保存为一个日志，以特定的顺序保存，并且被同步模块同步到集群的其他机器上，然后被各自的状态机消费，最后将结果返回给客户端。其中，如果日志的内容和顺序都相同，多个进程从同一状态开始，并且以相同的顺序获得相同的输入，那么可以预见的是这些进程将会生成相同的输出，并且结束在相同的状态。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>如何保证复制后的日志数据在每台机器上都一样？</strong></p>
<h1 id="3-不太完美的解决方案"><a href="#3-不太完美的解决方案" class="headerlink" title="3 不太完美的解决方案"></a>3 不太完美的解决方案</h1><p>为解决上述<a href="#%E9%97%AE%E9%A2%98">问题</a>，此小节进行一些方案讨论，用以引出 Paxos 算法。</p>
<h2 id="主从异步复制"><a href="#主从异步复制" class="headerlink" title="主从异步复制"></a>主从异步复制</h2><p>主从异步复制是较为简单的策略之一，但是存在一个问题。客户端接收到服务端返回的 <strong>200 OK</strong> 的结果码后，就认为数据已经安全，但是距离主节点将数据复制到全部结点还有一个时间空隙，这段时间内，若主节点宕机或者网络异常，则数据可能丢失，因此该策略不可靠。</p>
<blockquote>
<p>具体复制概念参考<a href="https://iswade.github.io/database/replication/#_3">文章</a></p>
</blockquote>
<h2 id="主从同步复制"><a href="#主从同步复制" class="headerlink" title="主从同步复制"></a>主从同步复制</h2><p>主从同步复制能够完整数据的完整性，同步复制保证了全部数据都被复制到所有结点上，主节点才返回客户端 <strong>200 OK</strong>，但是同步复制的缺点是，延迟很大（主节点需要等待所有从节点都返回 <strong>200 OK</strong> 后才返回给客户端结果），若是有从节点宕机或者网络异常，同步复制会一直阻塞下去。</p>
<h2 id="主从半同步复制"><a href="#主从半同步复制" class="headerlink" title="主从半同步复制"></a>主从半同步复制</h2><p>在同步和异步之间，做一个折中，看起来是一个不错的方案，这就是<strong>半同步复制</strong>。它要求 Leader 在应答客户端之前必须把数据复制到<strong>足够多</strong>的机器上，但不需要是全部。<strong>这样副本数够多可以提供比较高的可靠性；1 台机器宕机也不会让整个系统停止写入</strong>。<br>但该策略还是有缺点，例如<code>数据A</code> 复制到<code>节点1</code>, 但没有到达<code>节点2</code>; <code>数据B</code> 复制达到了<code>节点2</code> 但没有到达<code>节点1</code>, 这时如果<code>主节点</code>挂掉了需要从某个从节点恢复出数据，任何一个节点都不能提供完整的数据。所以在整个系统中，数据存在某种<strong>不一致</strong>。</p>
<h2 id="多数派写-Quorum"><a href="#多数派写-Quorum" class="headerlink" title="多数派写(Quorum)"></a>多数派写 (Quorum)</h2><p>为了解决半同步复制中数据不一致的问题，可以将这个复制策略再做一改进: <strong>多数派读写</strong>: 每条数据必须写入到<strong>半数以上</strong>的机器上。每次读取数据都必须检查<strong>半数以上</strong>的机器上是否有这条数据。即，<strong>如果集群中有 N 个节点，客户端需要写入 W &gt;= N/2 + 1 个节点。不需要主节点。这种方法可以容忍最多 (N-1)/2 个节点故障。</strong></p>
<p>在这种策略下，数据可靠性足够，宕机容忍足够，任一机器故障也能读到全部数据.</p>
<h2 id="多数派写-Quorum-后写入优胜"><a href="#多数派写-Quorum-后写入优胜" class="headerlink" title="多数派写(Quorum)后写入优胜"></a>多数派写 (Quorum) 后写入优胜</h2><p>由于多数派写无法区分写入数据的版本，此时也可能数据数据不一致问题。如：</p>
<ul>
<li>第一次更新时：节点 1、节点 2 都写入了 A = x;</li>
<li> 第二次更新时：节点 2、节点 3 都写入了 A = y;</li>
</ul>
<p>此时若一个客户端发送读取 A 的请求到节点 1 和节点 2 时，会得到 2 条不一样的数据。</p>
<p>基于以上问题，可以对多数派写进行优化，加入一个全局单调递增的时间戳作为一个<strong>版本号</strong>，并且规定最新版本的优先级高于旧版本。如此，客户端读取 A 的请求发送到节点 1 和节点 2 时，可以针对两条不一样的数据进行版本比较，取最新版本的即可。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>上述带版本号的多数派写入仍然存在问题，在客户端没有完成一次完整的多数派写的时候，例如，上面的例子中：</p>
<ul>
<li>第一次更新时：节点 1、节点 2 都写入了 A = x;</li>
<li> 第二次更新是：节点 3 写入了 A = y，客户端进程挂掉；</li>
</ul>
<p>此时集群中的状态为：</p>
<figure class="highlight tex"><table><tbody><tr><td class="code"><pre><span class="line">节点1： A = x</span><br><span class="line">节点2： A = x</span><br><span class="line">节点3： A = y</span><br></pre></td></tr></tbody></table></figure>

<p>同一时间，另外一个客户端读取时：</p>
<ul>
<li>如果请求发送到节点 1 和节点 2 时，此时 A = x</li>
<li> 如果请求发送到节点 2 和节点 3 是，此时 A = y</li>
</ul>
<p>对外的提供的信息仍然不一致。</p>
<h1 id="4-方案推演优化（Paxos的思想雏形）"><a href="#4-方案推演优化（Paxos的思想雏形）" class="headerlink" title="4 方案推演优化（Paxos的思想雏形）"></a>4 方案推演优化（Paxos 的思想雏形）</h1><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>假设有一个分布式存储系统，配置为 3 个存储节点，使用多数派写的策略，系统提供以下功能：</p>
<ul>
<li>只能存储一个变量 <code>i</code>;</li>
<li><code>i</code> 具有版本区分，随着每次更新，版本号也随之更新: <code>i1、i2、i3....</code></li>
<li>对变量 <code>i</code> 只能有 3 种更新操作：<ul>
<li><code>get</code> 读取变量 <code>i</code> 最新版本的值；</li>
<li><code>set&lt;n&gt;</code> 将变量 <code>i</code> 的值更新为 <code>n</code>，并更新版本号；</li>
<li><code>inc&lt;n&gt;</code> 对变量 <code>i</code> 的值增加 <code>n</code>，并更新版本号；</li>
</ul>
</li>
</ul>
<p>使用此分布式存储系统来更清晰地展示出对<strong>一致性问题</strong>多数派写的不足，以及如何用 Paxos 来解决这些问题；</p>
<h2 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h2><p>对于上述系统提供的 <code>get、set&lt;n&gt;、inc&lt;n&gt;</code> 命令的实现</p>
<ul>
<li><code>get</code>：对应多数派读（若集群节点数量为 N，则至少需要读取 N/2 + 1 个节点的数据）；</li>
<li><code>set&lt;n&gt;</code>：对应多数派写逻辑；</li>
<li><code>inc&lt;n&gt;</code>：拆分为几步，为一个事务型操作：<ol>
<li><code>get</code> 多数派读操作，读取变量 <code>i</code> 最新数据；</li>
<li>将 <code>i2 = i1 + n</code> </li>
<li><code>set&lt;i2&gt;</code></li>
</ol>
</li>
</ul>
<h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>如果有 2 个并发的客户端进程同时做这个 inc 的操作，在多数派读写的实现中，必然会产生一个 Y 客户端覆盖 X 客户端的问题。从而产生了数据更新点的丢失。</p>
<p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220715233011323.png" alt="image-20220715233011323"></p>
<p>提取一下上面提到的问题：<strong>让 Y 去更新的时候不能直接更新 <code>i2</code>，而是应该能检测到 <code>i2</code> 的存在，进而将自己的结果更新到下一个版本 <code>i3</code> 中，再写回系统中。</strong></p>
<p>问题进一步抽象：<strong>变量 <code>i</code> 的每个版本只能被<u>写入一次</u>，不允许修改。如果系统设计能满足这个要求，那么 X 和 Y 的 <code>inc</code> 操作就都可以正确被执行了。</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这里引申出一个更基础的问题：<strong>如何确定变量 <code>i</code> 的某个版本是否已经被写入到系统？</strong></p>
<p>一个最直观的的解决方法是：在客户端 X 或 Y 写之前先做一次<strong>多数派读</strong>，以便确认是否有其他客户端进程已经在写了，如果有，则放弃。</p>
<p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220715233851788.png" alt="image-20220715233851788"></p>
<p>此方法还是有个并发问题：客户端 X 和 Y 可能同时做这个<strong>写前读取</strong>的操作，并且同时得出一个结论：<u>还没有其他进程在写入，我可以写。</u>这样还是会造成更新丢失的问题。</p>
<p>可以通过为所有的存储节点添加一个功能来解决这个问题，即，<strong>每个存储节点必须记住谁最后一个做过写前读取的操作，并且只允许最后一个完成写前读取的客户端进程可以进行后续写入，同时拒绝之前其它写前读取的进程写入的权限（类似于保持最新版本的一个写前读取的操作）。</strong></p>
<p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220715234846368.png" alt="image-20220715234846368"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的优化方案为 paxos 的核心思想。</p>
<p>最终的问题只需要解决:</p>
<ul>
<li>如何标识不同客户端？例如：客户端 X 和 Y；</li>
<li>如何确认谁是最后一个完成<strong>写前读写</strong>的进程？</li>
<li>…</li>
</ul>
<h1 id="5-Basic-Paxos算法描述"><a href="#5-Basic-Paxos算法描述" class="headerlink" title="5 Basic Paxos算法描述"></a>5 Basic Paxos 算法描述</h1><p>Basic Paxos 很多地方也称作 Classic Paxos。</p>
<p>Basic Paxos 的价值在于开拓了分布式共识算法的发展思路，但它因有如下缺陷，一般不会直接用于实践：Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下将产生较大的网络开销，极端情况下甚至可能形成活锁。总之，Basic Paxos 是一种很学术化但对工业化并不友好的算法，现在几乎只用来做理论研究。实际的应用都是基于 Multi Paxos 和 Fast Paxos 算法的。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>Proposer：提议发起者「主动」，处理客户端请求，将客户端的请求发送到集群中，以便决定这个值是否可以被批准</p>
</li>
<li><p>Acceptor：提议批准者「被动」，负责处理接收到的提议，他们的回复就是一次投票。会存储一些状态来决定是否接收一个值</p>
<blockquote>
<p>同一个集群服务器，同时可以有多个角色「Proposer 、Acceptor」</p>
</blockquote>
</li>
<li><p>Proposal：提议发起者 Proposer 提出的值</p>
</li>
<li><p>Proposal Number：提议者提出的值的编号，每个请求带有唯一编号</p>
<table>
<thead>
<tr>
<th>Round Number</th>
<th>Server Id</th>
</tr>
</thead>
<tbody><tr>
<td>Round Number：为 Proposer 发起提议的次数，单调递增</td>
<td>为发起 Proposal 的 Proposer「服务器」Id，如：服务器名称</td>
</tr>
</tbody></table>
<blockquote>
<p>Round Number 更大，则优先级更高；<br>规则：提案者必须选择一个比之前见过的还大的提案值</p>
</blockquote>
</li>
</ul>
<h2 id="两个原则"><a href="#两个原则" class="headerlink" title="两个原则"></a>两个原则</h2><h3 id="a-Safety-安全原则"><a href="#a-Safety-安全原则" class="headerlink" title="a. Safety-安全原则"></a>a. Safety - 安全原则</h3><p>安全原则保证算法不能做错的事，即：</p>
<ul>
<li>针对某个实例的表决只能有一个值被批准，不能出现一个被批准的值被另一个值覆盖的情况；(假设有一个值被多数 Acceptor 批准了，那么这个值就只能被学习)</li>
<li> 每个节点只能学习到已经被批准的值，不能学习没有被批准的值。</li>
</ul>
<blockquote>
<p>有点类似于前面<a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a>提到的方式</p>
<p>每个存储节点必须记住谁最后一个做过写前读取的操作，并且只允许最后一个完成写前读取的客户端进程可以进行后续写入，同时拒绝之前其它写前读取的进程写入的权限（类似于保持最新版本的一个写前读取的操作）。</p>
</blockquote>
<h3 id="b-Liveness-存活原则"><a href="#b-Liveness-存活原则" class="headerlink" title="b. Liveness-存活原则"></a>b. <strong>Liveness</strong>- 存活原则</h3><p>存活原则 - 只要有多数服务器存活并且彼此间可以通信，最终都要做到的下列事情：</p>
<ul>
<li>最终会批准某个被提议的值；</li>
<li>一个值被批准了，其他服务器最终会学习到这个值。</li>
</ul>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>将前面<a href="#%E6%80%BB%E7%BB%93">总结</a>和<a href="#%E9%97%AE%E9%A2%98">问题</a>抽象一下：<u>Basic-Paxos 只会 Chosen 一个值。基于此，就需要一个两阶段（2-phase）协议，对于已经 Chosen 的值，<strong>后面的提案也要使用相同的值</strong>。</u></p>
<p>思想：</p>
<blockquote>
<p><strong>每个存储节点必须记住谁最后一个做过写前读取的操作，并且只允许最后一个完成写前读取的客户端进程可以进行后续写入，同时拒绝之前其它写前读取的进程写入的权限（类似于保持最新版本的一个写前读取的操作）。</strong></p>
</blockquote>
<h3 id="两阶段算法"><a href="#两阶段算法" class="headerlink" title="两阶段算法"></a>两阶段算法</h3><p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220716222240683.png" alt="image-20220716222240683"></p>
<p>Phase 1: 准备阶段（Prepare PRCs）</p>
<ul>
<li>找到已经被选中的值</li>
<li>阻止旧的提案</li>
</ul>
<p>Phase 2: 接受阶段（Accept RPCs）</p>
<ul>
<li>请求 Acceptors 接受值</li>
</ul>
<p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220716223056759.png" alt="image-20220716223056759"></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>Phase 1: 准备阶段（Prepare PRCs）</p>
<ol>
<li>Proposer 选择一个提案编号 n；</li>
<li>向所有的 Acceptor 广播 <code>Prepare(n)</code> 请求；</li>
<li>Acceptor 接收到 <code>Prepare(n)</code> 请求，此时有两种情况：<ol>
<li>如果 n 大于之前接受到的所有 Prepare 请求的编号 <code>minProposal</code>，则返回响应，并承诺将不会接收编号小于 n 的提案。如果之前已经有提案被 Chosen 的话，响应还应包含前一次提案编号 <code>acceptedProposal</code> 和对应的值 <code>acceptedValue</code>;</li>
<li> 否则（即 n 小于等于 Acceptor 之前收到的最大编号）忽略，但一般会回复一个拒绝响应；</li>
</ol>
</li>
<li>Proposer 接收到 Acceptors 的响应后，查看响应中是否包含 <code>acceptedValue</code>，如果有的话，说明之前已经有提案被 Chosen，替换当前 Proposal 的值为 Chosen 的值 (<strong>Conflicting Choices</strong> 问题)；</li>
</ol>
<p>Phase 2: 接受阶段（Accept RPCs）</p>
<ol start="5">
<li>向所有的节点广播 <code>Accept(n, value)</code> 请求；</li>
<li>Acceptor 收到 <code>Accept()</code> 请求，在这期间如果 Acceptor 没有对比 n 更大的编号，则接受该提案。否则拒绝接受 Proposal，直接返回；</li>
<li>Proposer 己收到大多数 Acceptor 的请求，此次请求的 Proposal 被接受。如果 Proposal 没有被大多数 Acceptors 接受，则回到第一步，重新发起新一轮的请求；</li>
</ol>
<h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><h3 id="Case1-前提案已经被Chosen"><a href="#Case1-前提案已经被Chosen" class="headerlink" title="Case1: 前提案已经被Chosen"></a>Case1: 前提案已经被 Chosen</h3><p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220716225952952.png" alt="image-20220716225952952"></p>
<ol>
<li>S1 收到客户端提案请求 X，于是 S1 向 S1-S3 发起 <code>Prepare(3.1)</code> 请求，Acceptor 响应返回目前没有提案被 Chosen；</li>
<li>由于 S1-S3 没有任何提案被 Chosen，S1 继续向 S1-S3 发送 <code>Accept(3.1, X)</code> 请求，提案被成功 Chosen；</li>
<li>在提案被 Chosen 后，S5 收到客户端提案值为 Y 的请求，向 S3-S5 发送 <code>Prepare(4.5)</code> 请求，由于编号 4 &gt; 3，S5 会收到提案值为 X 已经被 Chosen 的响应；</li>
<li>于是 S5 <strong>将提案值 Y 替换成 X</strong>，向 S1-S3 发送 <code>Accept(4.5, X)</code> 请求，提案再次被 Chosen;</li>
</ol>
<h3 id="Case2-前提案未被Chosen，对新一轮Proposer可见"><a href="#Case2-前提案未被Chosen，对新一轮Proposer可见" class="headerlink" title="Case2: 前提案未被Chosen，对新一轮Proposer可见"></a>Case2: 前提案未被 Chosen，对新一轮 Proposer 可见</h3><p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220716230833862.png" alt="image-20220716230833862"></p>
<ol>
<li>S1 收到客户端提案请求 X，于是 S1 向 S1-S3 发起 <code>Prepare(3.1)</code> 请求，响应返回没有提案被 Chosen；</li>
<li>由于 S1-S3 没有任何提案被 Chosen，S1 继续向 S1-S3 发送 <code>Accept(3.1, X)</code> 请求，由于网络延迟等关系，Proposal 首先在 S3 被 Chosen；</li>
<li>在提案被 Acceptor S1 和 S2 Chosen 之前，S5 收到客户端提案值为 Y 的请求，向 S3-S5 发送 <code>Prepare(4.5)</code> 请求，其中由于 S3 作为上一轮的 Acceptor，可以知道自己有了 Chosen 的 Proposal，并且新一轮的 Proposal Number 4 &gt; 3 ，则会在返回给 S5 的响应中带上上一轮的 Proposal 的值；</li>
<li>于是 S5 <strong>将提案值 Y 替换成 X</strong>，向 S1-S3 发送 <code>Accept(4.5, X)</code> 请求，提案再次被 Chosen；</li>
</ol>
<h3 id="Case3-前提案未被Chosen，对新一轮Proposer不可见"><a href="#Case3-前提案未被Chosen，对新一轮Proposer不可见" class="headerlink" title="Case3: 前提案未被Chosen，对新一轮Proposer不可见"></a>Case3: 前提案未被 Chosen，对新一轮 Proposer 不可见</h3><p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220716232014065.png" alt="image-20220716232014065"></p>
<ol>
<li>S1 收到客户端提案请求 X，于是 S1 向 S1-S3 发起 <code>Prepare(3.1)</code> 请求，响应返回没有提案被 Chosen；</li>
<li>由于 S1-S3 没有任何提案被 Chosen，S1 继续向 S1-S3 发送 <code>Accept(3.1, X)</code> 请求，由于网络延迟等关系，Accept 请求一直没有被响应；</li>
<li>在上一轮提案被 Acceptor S3 响应之前，S5 收到客户端提案值为 Y 的请求，向 S3-S5 发送 <code>Prepare(4.5)</code> 请求，响应返回没有提案被 Chosen；</li>
<li>此时 S3 收到 <code>Accept(3.1, X)</code> 请求，但是由于此时新的 <code>Proposal Number</code> 更大，会导致上一轮的 Proposal 被拒绝。而上一轮 Proposal，只有 S1-S2 响应，不能占到系统的大多数，会被拒绝；</li>
<li>由于 S3-S5 没有任何提案被 Chosen，S5 继续向 S3-S5 发送 <code>Accept(4.5, Y)</code> 请求，提案被成功 Chosen；</li>
</ol>
<h3 id="Case4-活锁"><a href="#Case4-活锁" class="headerlink" title="Case4: 活锁"></a>Case4: 活锁</h3><p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220716233504393.png" alt="image-20220716233504393"></p>
<p>当 Proposer 在第一轮 Prepare 发出请求，还没来得及完成后续的第二轮 Accept 请求，紧接着第二个 Proposer 在第一阶段也发出编号更大的请求。如果这样无穷无尽，Acceptor 始终停留在决定顺序号的过程上，那大家谁也成功不了。</p>
<p>解决活锁最简单的方式就是引入<strong>随机超时</strong>，这样可以让某个 Proposer 先进行提案，减少一直互相抢占的可能。</p>
<h2 id="异常处理（持久化存储）"><a href="#异常处理（持久化存储）" class="headerlink" title="异常处理（持久化存储）"></a>异常处理（持久化存储）</h2><p>在算法执行的过程中会产生很多的异常情况：proposer 宕机，acceptor 在接收 proposal 后宕机，proposer 接收消息后宕机，acceptor 在 accept 后宕机，存储失败，等等。为保证 paxos 算法的正确性，proposer、aceptor 都实现持久存储，以做到 server 恢复后仍能正确参与 paxos 处理。</p>
<p>Propose 存储已提交的最大 proposal 编号、决议编号（instance id）<br>Acceptor 存储已承诺（promise）的最大编号、已接受（accept）的最大编号和 value、决议编号。</p>
<h1 id="6-Multi-Paxos"><a href="#6-Multi-Paxos" class="headerlink" title="6 Multi Paxos"></a>6 Multi Paxos</h1><p>回到文章最开始的<a href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98">例子</a> —— <strong>多副本状态机（Replicated state machines）</strong>，Paxos 就是为了实现 Replicated Log。Paxos 只从一个或多个值中选择一个值，分布式系统常常需要重复运行 Paxos 来创建<strong>多副本状态机</strong>，但如果每个命令都通过一个 Basic Paxos 算法实例来达到一致，每次都要两轮 RPC，会产生大量开销。所以需要对 Paxos 做一些调整解决更实际的问题，并提升性能。经过一系列优化后的 Paxos 我们称之为 <strong>Multi-Paxos</strong>。</p>
<blockquote>
<p>Multi Paxos 对 Basic Paxos 的核心改进是增加了 “选主” 的过程，提案节点会通过定时轮询（心跳），确定当前网络中的所有节点里是否存在有一个主提案节点，一旦没有发现主节点存在，节点就会在心跳超时后使用 Basic Paxos 中定义的准备、批准的两轮网络交互过程，向所有其他节点广播自己希望竞选主节点的请求，希望整个分布式系统对 “由我作为主节点” 这件事情协商达成一致共识，如果得到了决策节点中多数派的批准，便宣告竞选成功。当选主完成之后，除非主节点失联之后发起重新竞选，否则从此往后，就只有主节点本身才能够提出提案。此时，无论哪个提案节点接收到客户端的操作请求，都会将请求转发给主节点来完成提案，而主节点提案的时候，也就无需再次经过准备过程，因为可以视作是经过选举时的那一次准备之后，后续的提案都是对相同提案 ID 的一连串的批准过程。也可以通俗理解为选主过后，就不会再有其他节点与它竞争，相当于是处于无并发的环境当中进行的有序操作，所以此时系统中要对某个值达成一致，只需要进行一次批准的交互即可。 [摘自<a href="http://icyfenix.cn/distribution/consensus/raft.html">凤凰架构</a>]</p>
</blockquote>
<p>为此，Multi-Paxos 提出了几个问题需要解决：</p>
<ol>
<li>日志内容如何选择？</li>
<li>性能优化<ol>
<li>使用 Leader 降低多个 Proposers 带来的冲突消耗；</li>
<li>降低不必要的 Prepare 请求，来降低不必要的 RPC 请求</li>
</ol>
</li>
<li>如何保证副本的完整性</li>
<li>客户端请求协议</li>
<li>分布式集群配置</li>
</ol>
<h2 id="日志内容选择"><a href="#日志内容选择" class="headerlink" title="日志内容选择"></a>日志内容选择</h2><p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220717000723564.png" alt="image-20220717000723564"></p>
<p>客户端的请求在服务端作为一个元素保存在数组中，然后数组被作为日志，被一致性模块同步到所有的服务端，最后被状态机消费，返回结果给客户端。Replicated log 类似一个数组，我们需要知道当次请求是在写日志的第几位。因此，Multi-Paxos 做的第一个调整就是要添加一个日志的 index 参数到 <code>Prepare</code> 和 <code>Accept</code> 阶段，表示这轮 Paxos 正在决策哪一条日志记录。</p>
<p>当新的客户端指令发送到服务器时，Multi Paxos 大致流程如下：</p>
<ol>
<li>寻找第一条没有 chosen 的日志 (该日志中没有提案或者提案还没有通过)；</li>
<li>执行 Basic Paxos，以该条目 index 为编号提出提案；</li>
<li>通过的提案内容就是该条目日志选择的内容，如果：<ol>
<li>选择了服务器中存在的指令，即该提案编号以下的最大未通过提案指令，就从步骤一重新开始；</li>
<li>否则就选择该客户端的请求指令；</li>
</ol>
</li>
</ol>
<p>例子：</p>
<p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220717001144973.png" alt="image-20220717001144973"></p>
<p>服务器上的每条日志记录可能存在<strong>三种状态</strong>：</p>
<ul>
<li>已经保存并知道被 chosen 的日志记录。例如 S1 方框加粗的第 1、2、6 条记录（后面会介绍服务器如何知道这些记录已经被 chosen）</li>
<li>已经保存但不知道有没有被 chosen。例如 S1 第 3 条 <code>cmp</code> 命令。观察三台服务器上的日志，cmp 其实已经存在两台上达成了多数派，只是 S1 还不知道</li>
<li>空的记录。例如 S1 第 4、5 条记录，S1 在这个位置没有接受过值，但可能在其它服务器接受过，例如 S2 第 4 条接受了 <code>sub</code>，S3 第 5 条接受了 <code>cmp</code></li>
</ul>
<p>多数派写方案中，3 个结点的集群可以容忍一台故障，为了更具体的分析，我们假设此时<strong>是 Server3 宕机的情况</strong>。同时，这里的提案值是一条具体的命令。当 S1 收到客户端的请求命令 <code>jmp</code> 时：</p>
<ol>
<li>找到第一个没有 chosen 的日志记录：图示中是第 3 条 <code>cmp</code> 命令；（指令 1 和指令 2 已经被选中了，通过前两轮 Paxos 选中）</li>
<li>这时候 S1 会尝试让 <code>jmp</code> 作为第 3 条的 chosen 值，运行 Basic Paxos；</li>
<li>因为 S1 的 Acceptor 已经接受了 <code>cmp</code>，所以在 Prepare 阶段会返回 <code>cmp</code>，接着用 <code>cmp</code> 作为提案值跑完这轮 Paxos，s2 也将接受 <code>cmp</code> 同时 S1 的 <code>cmp</code> 变为 chosen 状态，然后继续找下一个没有 chosen 的位置 —— 也就是第 4 位；</li>
<li>S2 的第 4 个位置接受了 <code>sub</code>，所以在 Prepare 阶段会返回 <code>sub</code>，S1 的第 4 位会 chosen <code>sub</code>，接着往下找；</li>
<li>第 5 位 S1 和 S2 都为空，不会返回 <code>acceptedValue</code>，所以第 5 个位置就确定为 <code>jmp</code> 命令的位置，运行 Paxos，并返回请求。</li>
</ol>
<p>值得注意的是：</p>
<ul>
<li>这个系统是可以并行处理多个客户端请求，比如 S1 知道 3、4、5、7 这几个位置都是未 chosen 的，就直接把收到的 4 个命令并行尝试写到这四个位置。</li>
<li>如果是状态机要执行日志时，必须是按照日志顺序逐一输入，如果第 3 条没有被 chosen，即便第 4 条已经 chosen 了，状态机也不能执行第 4 条命令。</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Basic Paxos 的效率很低。并发情况下，所有的 Proposer 都一起并行工作，因 Proposer 间大量的冲突而至少需要两轮乃至更多轮 RPC 才能达成共识。</p>
<p>解决方案：</p>
<ul>
<li><p>选择一个 Leader，任意时刻只有它一个 Proposer，这样可以避免冲突；</p>
<blockquote>
<p><strong>Leader 选举：</strong></p>
<ol>
<li><p>既然每台服务器都有一个 serverid，我们就直接让 serverid 最大的服务器成为 Leader，这意味着每台服务器需要知道其它服务器的 server_id；</p>
</li>
<li><p>服务器之间通过 T ms 的心跳来维持联系；</p>
</li>
<li><p>如果一个节点在 2Tms 时间内没有收到比自己 server_id 更大的心跳，那它自己就转为 Leader，意味着：</p>
<ol>
<li>该节点处理客户端请求；</li>
<li>该节点同时担任 Proposer 和 Acceptor；</li>
</ol>
</li>
<li><p>如果一个节点收到比自己 server_id 更大的服务器的心跳，那么它就不能成为 Leader，意味着</p>
<ol>
<li>该节点拒绝掉客户端请求，或者将请求重定向到 Leader；</li>
<li>该节点只能担任 Acceptor；</li>
</ol>
</li>
</ol>
</blockquote>
</li>
<li><p>减少大部分 Prepare 请求（压缩 prepare 过程的 RPC）只需要对整个日志进行一次 Prepare，后面大部分日志可以通过一次 Accept 被 Chosen;</p>
<blockquote>
<p><strong>压缩 Prepare 请求:</strong></p>
<p>在讨论如何减少 Prepare 请求之前，先讨论下 Prepare 阶段的作用，需要 Prepare 有两个原因：</p>
<ol>
<li>屏蔽老的提案：但 Basic-Paxos 只作用在日志的一条记录；</li>
<li>检查可能已经被 Chosen 的 value 来代替原本的提案值：多个 Proposer 并发进行提案的时候，新的 Proposal 要确保提案的值相同；</li>
</ol>
<p>可以见得，Prepare 还是很有必要的，可以通过以下几个方面来减少 Prepare 的请求：</p>
<ul>
<li>对于 a: 我们不再让提案编号只屏蔽一个 index 位置，而是让它变成全局的，即屏蔽整个日志。一旦 Prepare 成功，整个日志都会阻塞（值得注意的是，Accept 阶段还是只能写在对应的 index 位置上）。</li>
<li>对于 b: 需要拓展 Prepare 请求的返回信息，和之前一样，Prepare 还是会返回最大提案编号的 <code>acceptedValue</code>，除此之外，Acceptor 还会向后查看日志记录，如果要写的这个位置之后都是空的记录，没有接受过任何值，那么 Acceptor 就额外返回一个标志位 <code>noMoreAccepted</code>。</li>
</ul>
<p>后续，如果 Leader 接收到超过半数的 Acceptor 回复了 <code>noMoreAccepted</code>，那 Leader 就不需要发送 Prepare 请求了，直接发送 Accept 请求即可。这样只需要一轮 RPC。</p>
</blockquote>
</li>
</ul>
<h2 id="如何保证副本的完整性"><a href="#如何保证副本的完整性" class="headerlink" title="如何保证副本的完整性"></a>如何保证副本的完整性</h2><p>目前为止，通过选 Leader 和减少 Prepare 请求之后的 Multi-Paxos 依然不够完整，还需要解决：</p>
<ul>
<li>之前的日志只需要被多数派接受，完整的日志记录需要复制到全部节点；</li>
<li>只有 Proposer（也就是 Leader） 知道哪些记录被 chosen 了，需要所有的服务器都知道哪些记录被 chosen；</li>
</ul>
<p>要保证集群的所有节点的得到相同的输出，需要保证所有的节点的日志和指令都一致。</p>
<p>方案：</p>
<ol>
<li><p>为了让日志尽可能被复制到每台服务器：Leader 在收到多数派 Acceptor 回复后，可以继续做后面的处理，但同时在后台继续对未回复的 Acceptor 进行重试。这样不会影响客户端的响应时间，但这也不能确保完全复制了（例如，如果 Leader 在中途宕机了）</p>
</li>
<li><p>为了追踪哪些记录是被 chosen 的，增加一些内容：<code>acceptedProposal</code> 代表日志的提案编号，如果第 i 条记录被 chosen，则 <code>acceptedProposal[i] = ∞</code>（这是因为，只有提案编号更大的提案才能被接受，无穷大则表示无法再被重写了）每个节点都维护一个 <code>firstUnChosenIndex</code>，表示第一个没有被 chosen 的日志位置。（即第一个 <code>acceptedProposal[i] != ∞</code>的节点）</p>
</li>
<li><p>Leader 告诉 Acceptor 哪些日志被 chosen ：Leader 在向 Acceptor 发送 Accept 请求的时候带上 <code>firstUnChosenIndex</code>，这样 Acceptor 收到 Accept 请求的时候，如果第 i 条日志满足 <code>i &lt; request.firstUnchosenIndex &amp;&amp; acceptedProposal[i] == request.proposal</code>，则标记 i 为 chosen（即设为无穷大）</p>
<p>例子：</p>
<p><img src="/2023/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/image-20220717225727574.png" alt="image-20220717225727574">上图表示同一个 Acceptor 节点 Accept 请求前后的 <code>acceptedProposal</code> 的数组结果。</p>
<p>Before Accept： index(i) = 6,  acceptedProposal = 3.4;</p>
<p>Accept 请求中：proposal = 3.4, index = 8, value = v, firstUnchosenIndex = 7;</p>
<p>=&gt; <code>i &lt; request.firstUnchosenIndex &amp;&amp; acceptedProposal[i] == request.proposal</code></p>
<p>After Accept: accetpedProposal[6] = ∞</p>
<blockquote>
<p><strong>总结：</strong> acceptor 已经学习了大部分被选择的日志</p>
</blockquote>
</li>
<li><p>若 Leader 宕机，Acceptor 的日志条目中仍然可能有一些宕机的 Leader 留下的提案记录，还没有完成提案的复制或者 chosen。更换新 Leader 时，需要：</p>
<ul>
<li><p>Acceptor 将其 <code>firstUnchosenIndex</code> 作为 Accept 请求的响应返回给 Proposer；</p>
</li>
<li><p>Proposer 判断如果 <code>Acceptor.firstUnChosenIndex &lt; Proposer.firstUnChosenIndex</code>，则在后台（异步）发送 <code>Success(index, v)</code> RPC：</p>
</li>
<li><p>Acceptor 收到 Success RPC 后，更新已经被 chosen 的日志记录：</p>
<ul>
<li><p>acceptedValue[index] = v</p>
</li>
<li><p>acceptedProposal [index] = 无穷大</p>
</li>
<li><p>return firstUnchosenIndex</p>
<blockquote>
<p>如果需要 (可能存在多个不确定的状态)，Proposer 发送额外的 Success RPC</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>通过 4 个步骤就可以确保所有的 Acceptor 都最终知道已被 chosen 的日志记录。在一般的情况，并不需要额外的第 4 步，只有在 Leader 切换时才可能需要第 4 步</p>
</blockquote>
<h2 id="客户端请求协议"><a href="#客户端请求协议" class="headerlink" title="客户端请求协议"></a>客户端请求协议</h2><p>考虑客户端如何与集群交互。</p>
<p>当客户端第一次请求时，并不知道谁是 Leader，它任意请求一台服务器，如果该服务器不是 Leader，重定向给 Leader。<br>Leader 直到日志记录被 chosen 并且被 Leader 的状态机执行才返回响应给客户端。</p>
<p>客户端会一直和 Leader 交互，直到无法再联系上它（例如请求超时）。在这种情况下，客户端会联系任何其它服务器，这些服务器又在重定向到实际的 Leader。</p>
<p>但这存在一个问题，如果请求提案被 chosen 后，Leader 在回复客户端之前宕机了。客户端会认为请求失败了，并重试请求。这相当于一个命令会被状态机执行两次或者多次，在很多情况下是不能被接受的（幂等问题）。</p>
<p><strong>方案：</strong></p>
<p>客户端为每个请求增加一个唯一 id，服务器将该 id 与命令一起保存到日志记录中。状态机在执行命令之前，会根据 id 检查该命令是否被执行过。</p>
<h2 id="分布式集群配置"><a href="#分布式集群配置" class="headerlink" title="分布式集群配置"></a>分布式集群配置</h2><p>现在分布式使用的都是服务发现、配置中心来管理，是个非常复杂的问题，这里不再做过多介绍，之后用其他的篇幅来学习讲解。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>Paxos 是由 <a href="https://en.wikipedia.org/wiki/Leslie_Lamport">Leslie Lamport</a>（就是大名鼎鼎的 <a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX</a> 中的 “La”）提出的一种基于消息传递的协商共识算法，现已是当今分布式系统最重要的理论基础，几乎就是 “共识” 二字的代名词。</p>
<p>Paxos 是以复杂著称的算法，本章节从一个问题出发，来引出如何推演出 Paxos 的思想，主要讲解了下 Basic Paxos 的算法流程，即，以 prepare 和 accept 两个阶段以及在这两个阶段中 proposer 和 acceptor 的行为来解决：<strong>如何保证复制后的日志数据在每台机器上都一样？</strong>的问题。</p>
<p>同时也大概介绍了一下基于 Basic Paxos 的改进版本”Multi Paxos”，给出几个优化的点。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://coolshell.cn/articles/10910.html">分布式系统的事务处理</a></li>
<li><a href="https://www.jdon.com/artichect/paxos.html">分布式系统 Paxos 算法</a></li>
<li><a href="https://www.bilibili.com/video/BV1WW411a77S">Paxos &amp; Raft lecture, Diego Ongaro</a></li>
<li><a href="https://xie.infoq.cn/article/e53cbcd0e723e3a6ce4be3b8c">图解超难理解的 Paxos 算法（含伪代码）</a></li>
<li><a href="https://xie.infoq.cn/article/92f6b1a031594da8164645459">Paxos 的变种（一）：Multi-Paxos 是如何劝退大家去选择 Raft 的</a></li>
<li><a href="https://www.cnblogs.com/linbingdong/p/6253479.html">分布式系列文章 ——Paxos 算法原理与推导</a></li>
<li><a href="https://www.cnblogs.com/jmcui/p/14633799.html">Paxos 协议简单介绍</a></li>
<li><a href="https://blog.openacid.com/algo/paxos/">可靠分布式系统 - paxos 的直观解释</a></li>
<li><a href="https://iswade.github.io/database/replication/#_3">分布式系统之复制</a></li>
<li><a href="http://icyfenix.cn/distribution/consensus/paxos.html">凤凰架构 - Paxos</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>Paxos</tag>
        <tag>Multi-Paxos</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统：CAP 理论</title>
    <url>/2023/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9ACAP%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>分布式系统（<code>Distributed System</code>）已经变得非常常见和重要，现在市面上的大型网站与一些重要的系统几乎都是分布式的。</p>
<p>分布式系统最大的难点就是各个节点的状态如何同步。<code>CAP</code> 理论就是这方面的基本定理，也是理解分布式的起点。</p>
<blockquote>
<p><code>2000</code> 年 <code>7</code> 月，加州大学伯克利分校的 <code>Eric Brewer</code> 教授在 <code>ACM PODC</code> 会议上提出 <code>CAP</code> 猜想。两年后，麻省理工学院的 <code>Seth Gilbert</code> 和 <code>Nancy Lynch</code> 从理论上证明了 <code>CAP</code>。之后，<code>CAP</code> 理论正式成为分布式计算领域的公认定理。</p>
</blockquote>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="2-定义"><a href="#2-定义" class="headerlink" title="2 定义"></a>2 定义</h1><p><code>CAP</code> 分别代表分布式系统的三个指标:</p>
<ul>
<li><code>C（Consistency，一致性）</code></li>
<li><code>A（Availability，可用性）</code></li>
<li><code>P（Partition tolerance，分区容错）</code></li>
</ul>
<p><code>CAP</code> 理论指出：我们无法设计出一种同时满足 <code>CAP</code> 三个指标的分布式协议：</p>
<ol>
<li>该种协议下的副本始终是强一致性的；</li>
<li>系统的服务是始终可用的；</li>
<li>协议可以容忍任何网络分区异常；</li>
</ol>
<img src="/2023/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9ACAP%E7%90%86%E8%AE%BA/image-20230224002619208.png" alt="image-20230224002619208" style="zoom:50%;">

<h2 id="2-1-Consistency-一致性"><a href="#2-1-Consistency-一致性" class="headerlink" title="2.1 Consistency 一致性"></a>2.1 Consistency 一致性</h2><p><code>All nodes see the same data at the same time</code> 对于分布式系统来说，更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设系统中某条记录为 <code>V0</code>，客户端向 <code>G1</code> 发起写操作，将其改为 <code>V1</code>，</p>
<p><img src="/2023/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9ACAP%E7%90%86%E8%AE%BA/image-20230226205921477.png" alt="image-20230226205921477"></p>
<p>存在的问题：</p>
<p>客户端可能向 <code>G2</code> 发起读操作，由于 <code>G2</code> 的值没有同步，因此返回的值为 <code>V0</code>，<code>G1</code> 和 <code>G2</code> 读操作的结果不一致，不满足一致性。</p>
<p><img src="/2023/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9ACAP%E7%90%86%E8%AE%BA/image-20230226210732838.png" alt="image-20230226210732838"></p>
<p>为了保证一致性，即 <code>G2</code> 的值也能变为 <code>V1</code>，则需在 <code>G1</code> 写操作的时候，将信息同步给 <code>G2</code>。</p>
<img src="/2023/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9ACAP%E7%90%86%E8%AE%BA/image-20230226211101544.png" alt="image-20230226211101544" style="zoom:50%;">

<h2 id="2-2-Availability-可用性"><a href="#2-2-Availability-可用性" class="headerlink" title="2.2 Availability 可用性"></a>2.2 Availability 可用性</h2><p><code>Reads and writes always succeed</code> 系统服务一直可用，且系统的响应在正常时间范围内。</p>
<p>对于一个可用性的分布式系统，每一个非故障节点必须对每个请求做出响应，一般是通过停机时间来衡量一个系统的可用性。</p>
<table>
<thead>
<tr>
<th>可用性分类</th>
<th>可用水平（%）</th>
<th>可容忍停机时间（年）</th>
</tr>
</thead>
<tbody><tr>
<td>容错可用性</td>
<td> 99.9999</td>
<td>&lt; 1 min</td>
</tr>
<tr>
<td> 极高可用性</td>
<td> 99.999</td>
<td>&lt; 5 min</td>
</tr>
<tr>
<td> 具有故障自动恢复能力的可用性</td>
<td> 99.99</td>
<td>&lt; 53 min</td>
</tr>
<tr>
<td> 高可用性</td>
<td> 99.9</td>
<td>&lt; 8.8 h</td>
</tr>
<tr>
<td> 商品可用性</td>
<td> 99</td>
<td>&lt; 87.6 h (3.65d)</td>
</tr>
</tbody></table>
<blockquote>
<p>具体的计算方式：</p>
<p>假设淘宝系统的可用性为 <code>5</code> 个 <code>9</code>，即可用水平为 <code>99.999%</code>，则全年可容忍停机时间为：<code>(1 - 0.99999) * 365 * 24 * 60 = 5.256 min</code></p>
</blockquote>
<h3 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h3><p>用户可以选择向 <code>G1</code> 或者 <code>G2</code> 发起读请求，无论系统的哪个节点，只要收到请求，就必须响应用户，否则不满足可用性。</p>
<h2 id="2-3-Partition-Tolerance-分区容错"><a href="#2-3-Partition-Tolerance-分区容错" class="headerlink" title="2.3 Partition Tolerance 分区容错"></a>2.3 Partition Tolerance 分区容错</h2><p><code>The system continues to operate despite arbitrary message loss or failure of part of the system </code> 分布式系统在遇到某个节点或者网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。</p>
<h3 id="举例说明-2"><a href="#举例说明-2" class="headerlink" title="举例说明"></a>举例说明</h3><p>大多数分布式系统都分布在多个子网络，每个子网络都成为一个区（<code>partition</code>），分区容错为区间通信可能失败。假设系统的一台服务器在中国，另外一台服务器在美国，这就是两个分区，且网络通信可能异常。</p>
<h1 id="3-证明"><a href="#3-证明" class="headerlink" title="3 证明"></a>3 证明</h1><p>本节证明分布式系统无法同时满足 <code>CAP</code>。</p>
<p>如下图，假设存在一个系统，满足 <code>CAP</code>，即：一致性（<code>Consistency</code>）、可用性（<code>Availability</code>）、分区容错性（<code>Partition Tolarance</code>）</p>
<img src="/2023/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9ACAP%E7%90%86%E8%AE%BA/image-20230226215753799.png" alt="image-20230226215753799" style="zoom:50%;">

<p>此时系统出现网络分区，同时客户端向系统的 <code>G1</code> 写入 <code>V1</code>，但是 <code>G1</code> 无法将 <code>V1</code> 同步给 <code>G2</code>（正在网络分区）。</p>
<p><img src="/2023/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9ACAP%E7%90%86%E8%AE%BA/image-20230226221039755.png" alt="image-20230226221039755"></p>
<p>此时客户端向 <code>G2</code> 发起读请求，由于系统满足 <code>CAP</code>，所以 <code>G2</code> 必须响应请求（可用性），此时 <code>G2</code> 返回的值为 <code>V0</code>。</p>
<p><img src="/2023/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9ACAP%E7%90%86%E8%AE%BA/image-20230226221246145.png" alt="image-20230226221246145"></p>
<p>这违反了 <code>CAP</code> 的一致性，与假设相违背。所以无法设计出一个系统同时满足 <code>CAP</code> 理论。</p>
<h1 id="4-权衡"><a href="#4-权衡" class="headerlink" title="4 权衡"></a>4 权衡</h1><h2 id="4-1-CA-without-P"><a href="#4-1-CA-without-P" class="headerlink" title="4.1 CA without P"></a>4.1 CA without P</h2><p>网络分区问题是客观存在的事实，因此分区容错是无法避免的，所以在分布式系统的设计中，要时刻考虑 <code>Partition Tolerance</code> 的情况，只能在 <code>CA</code> 之间做权衡。</p>
<h2 id="4-2-CP-without-A"><a href="#4-2-CP-without-A" class="headerlink" title="4.2 CP without A"></a>4.2 CP without A</h2><p>如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在 <code>CAP</code> 三者中保障 <code>CP</code> 而舍弃 <code>A</code>。</p>
<p>一个保证了 <code>CP</code> 而一个舍弃了 <code>A</code> 的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。</p>
<p>设计成 <code>CP</code> 的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成 <code>CP</code>。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如 <code>Redis、HBase</code> 等，还有分布式系统中常用的 <code>Zookeeper</code> 也是在 <code>CAP</code> 三者之中选择优先保证 <code>CP</code> 的。</p>
<blockquote>
<p>比如 <code>Zookeeper</code>：</p>
<p><code>ZooKeeper</code> 是个 <code>CP</code>（一致性 + 分区容错性）的，即任何时刻对 <code>ZooKeeper</code> 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，<code>ZooKeeper</code> 可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。<code>ZooKeeper</code> 是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持同步、一致。所以就不难理解为什么 <code>ZooKeeper</code> 被设计成 <code>CP</code> 而不是 <code>AP</code> 特性的了。</p>
</blockquote>
<h2 id="4-3-AP-without-C"><a href="#4-3-AP-without-C" class="headerlink" title="4.3 AP without C"></a>4.3 AP without C</h2><p>要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</p>
<p>这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到 <code>N个9</code>，所以，对于很多业务系统来说，比如淘宝的购物，<code>12306</code> 的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。</p>
<blockquote>
<p>比如 <code>12306</code> 系统：</p>
<p>在 12306 买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。</p>
</blockquote>
<p>需要注意的是，此处说的舍弃了一致性，只是舍弃了强一致性，而选择了最终一致性。在 <code>12306</code> 售票系统中，虽然下单的瞬间可能存在余票不一致的情况，但是最终付款的时候，是保证了最终一致性的。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p><code>CAP</code> 理论证明了分布式系统无法同时满足：一致性<code>（C，Consistency）</code>、可用性<code>（Availability，A）</code>、分区容错性<code>（Partition Tolerance）</code>的条件。网络分区问题是客观存在的无法避免，系统设计需要在 <code>CA</code> 之间 <code>tradeoff</code>，可以根据具体的业务场景来考虑。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://www.ruanyifeng.com/blog/2018/07/cap.html">CAP 定理的含义</a></li>
<li><a href="http://www.hollischuang.com/archives/666">分布式系统的 CAP 理论</a></li>
<li><a href="https://dbaplus.cn/news-159-1917-1.html">一文带你重新审视 CAP 理论与分布式系统设计</a></li>
</ul>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>存储</tag>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型详解</title>
    <url>/2020/06/14/Java%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1 什么是泛型？"></a>1 什么是泛型？</h3><p>泛型，即 “参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用 / 调用时传入具体的类型（类型实参）。<br><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为<strong>泛型类、泛型接口、泛型方法</strong>。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h3 id="2-为什么要用泛型？"><a href="#2-为什么要用泛型？" class="headerlink" title="2 为什么要用泛型？"></a>2 为什么要用泛型？</h3><p>创建一个 <code>List</code>，不指定类型的话，则可以添加任意类型:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="string">"string"</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) {</span><br><span class="line">            System.out.println(arrayList.get(i));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">string</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是如果如果需要以 <code>String</code> 的类型来处理 <code>arrayList</code> 内的元素，则编译的时候会遇到错误 (编译器不报错)：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="string">"string"</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) {</span><br><span class="line"><span class="comment">//            System.out.println(arrayList.get(i));</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) arrayList.get(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ERROR</code>:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></tbody></table></figure>

<p>若是我们在初始化 <code>arraryList</code> 的时候，指定了 <code>String</code> 类型，则编译器能够提前发现问题：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">"string"</span>);</span><br><span class="line"><span class="comment">//arrayList.add(1);</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-泛型的类型擦除"><a href="#3-泛型的类型擦除" class="headerlink" title="3 泛型的类型擦除"></a>3 泛型的类型擦除</h3><p>下面例子中，定义了 <code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code>，本意上是 2 个类型，但是在编译后都变成 <code>ArrayList</code>。<code>Java</code> 的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息，使用泛型的时候加上类型参数，在编译器编译时会去掉，这个过程称为类型擦除。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"string"</span>);</span><br><span class="line">List&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">integerList.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">classStringList</span> <span class="operator">=</span> stringList.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">classIntegerList</span> <span class="operator">=</span> integerList.getClass();</span><br><span class="line"></span><br><span class="line">System.out.println(classStringList); <span class="comment">// class java.util.ArrayList</span></span><br><span class="line">System.out.println(classIntegerList); <span class="comment">// class java.util.ArrayList</span></span><br><span class="line">System.out.println(classStringList == classIntegerList);  <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure>

<p>后面详细讲解这块。</p>
<h3 id="4-泛型的使用"><a href="#4-泛型的使用" class="headerlink" title="4 泛型的使用"></a>4 泛型的使用</h3><p>泛型的使用情形分为三种：泛型类、泛型接口、泛型方法</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类用于类的定义中，可以通过这个方式来实现对类的” 参数化 “，顾名思义，在 new 类的时候可以输入类型参数。典型的用法就是各种容器类，如：<code>List</code>、<code>Set</code>、<code>Map</code></p>
<p>基本用法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">public</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericClass</span><span class="params">(T key)</span>{</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        GenericClass&lt;String&gt; genericClass = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;(<span class="string">"String"</span>);</span><br><span class="line">        System.out.println(genericClass.getKey());  <span class="comment">// String</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>new</code> 泛型类的时候，不一定要传入类型实参。如上的例子所示，使用泛型的时候，若传入泛型类型实参 (<code>String</code>)，则创建的类会根据类型参数做相应的限制。如果不传入类型参数的话，如下例子所示，使用泛型类的时候，成员变量可以为任意的类型。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        GenericClass&lt;String&gt; genericClass = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;(<span class="string">"String"</span>);</span><br><span class="line">        System.out.println(genericClass.getKey());</span><br><span class="line"></span><br><span class="line">        <span class="type">GenericClass</span> <span class="variable">genericStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericClass</span>(<span class="string">"str"</span>);</span><br><span class="line">        <span class="type">GenericClass</span> <span class="variable">genericInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericClass</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">GenericClass</span> <span class="variable">genericChar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericClass</span>(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(genericStr.getKey()); <span class="comment">// str</span></span><br><span class="line">        System.out.println(genericInt.getKey()); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(genericChar.getKey()); <span class="comment">// c</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是:</p>
<ol>
<li><p>泛型类的类型参数必须为引用类型 (类类型)，不能是基础类型 (<code>string</code>, <code>int</code> …);</p>
</li>
<li><p>不能对泛型类使用 <code>instanceof</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (val <span class="keyword">instanceof</span> GenericClass&lt;Integer&gt;) {</span><br><span class="line">    System.out.println(<span class="string">"test"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">GenericDemo.java:<span class="number">17</span>: error: illegal generic type <span class="keyword">for</span> <span class="keyword">instanceof</span></span><br><span class="line">        <span class="title function_">if</span> <span class="params">(val <span class="keyword">instanceof</span> GenericClass&lt;Integer&gt;)</span> {</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型接口的定义和泛型类基本相同，基本用法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericsInterface</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>未传入类型参数，实现泛型接口类：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">GenericsInterface</span>&lt;T&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsImpl</span><span class="params">(T key)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        GenericsImpl&lt;String&gt; generics = <span class="keyword">new</span> <span class="title class_">GenericsImpl</span>(<span class="string">"str"</span>);</span><br><span class="line">        System.out.println(generics.getKey());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，其中实现类的声明中，不能忽略泛型类的声明 <code>&lt;T&gt;</code>, 即：<code>public class GenericsImpl&lt;T&gt; implements GenericsInterface&lt;T&gt; {</code>若是忽略了 <code>&lt;T&gt;</code>，编译会出现错误：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsImpl</span> <span class="keyword">implements</span> <span class="title class_">GenericsInterface</span>&lt;T&gt; {</span><br><span class="line">	... ... </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">ERROR:</span><br><span class="line"></span><br><span class="line">GenericsImpl.java:<span class="number">3</span>: error: cannot find symbol</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsImpl</span> <span class="keyword">implements</span> <span class="title class_">GenericsInterface</span>&lt;T&gt; {</span><br><span class="line">                                                       ^</span><br><span class="line">  symbol: <span class="keyword">class</span> <span class="title class_">T</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>传入类型参数，实现泛型接口类：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsImplPara</span> <span class="keyword">implements</span> <span class="title class_">GenericsInterface</span>&lt;String&gt;{</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsImplPara</span><span class="params">(String key)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">GenericsImplPara</span> <span class="variable">genericsImplPara</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericsImplPara</span>(<span class="string">"test"</span>);</span><br><span class="line">        System.out.println(genericsImplPara.getKey()); <span class="comment">// test</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当传入类型参数 String 时，则泛型类的声明 <code>&lt;T&gt;</code> 可以忽略。即 <code>public class GenericsImplPara&lt;T&gt; implements GenericsInterface&lt;String&gt;</code> 简化为以上的 <code>public class GenericsImplPara implements GenericsInterface&lt;String&gt;</code>.</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>与<strong>泛型类</strong>在实例化类的时候指明泛型的具体类型不同的是，<strong>泛型方法</strong>是在调用方法的时候指明泛型的具体类型。</p>
<p>##### 泛型方法的基本用法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> GenericClass&lt;T&gt; genericClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 		1&gt; public与返回值T中间&lt;T&gt;非常重要,可以理解为声明此方法为泛型方法;</span></span><br><span class="line"><span class="comment"> * 		2&gt; 只有声明了&lt;T&gt;的方法才是泛型方法,泛型类中的使用了泛型的成员方法并不是泛型方法;</span></span><br><span class="line"><span class="comment"> *		3&gt; &lt;T&gt;表明该方法将使用泛型类型T,此时才可以在方法中使用泛型类型T;</span></span><br><span class="line"><span class="comment"> *		4&gt; 与泛型类的定义一样,此处T可以随便写为任意标识,常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genericsMethod</span><span class="params">(GenericClass&lt;T&gt; genericClass)</span> {</span><br><span class="line">    <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> genericClass.newInstance();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="类中使用泛型方法："><a href="#类中使用泛型方法：" class="headerlink" title="类中使用泛型方法："></a>类中使用泛型方法：</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsFruit</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Fruit"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Apple"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GenerateTest</span>&lt;T&gt; {</span><br><span class="line">        <span class="comment">// 前面提到过，没有&lt;T&gt;修饰的方法不是泛型方法，T为调用方法的参数类型</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(T t)</span> {</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        }</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 有&lt;T&gt;修饰，是泛型方法；此时可以在方法中使用泛型类型T;</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">(T t)</span> {</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        }</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 本质上和show2方法一样，只是通配符的不同，后面会详细讲解一下通配符的使用</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show3</span><span class="params">(E t)</span> {</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        }</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 错误的声明，此泛型方法只声明了&lt;T&gt;，并没有声明&lt;E&gt;</span></span><br><span class="line"><span class="comment">//        public &lt;T&gt; void show4(GenericClass&lt;E&gt; e) {</span></span><br><span class="line"><span class="comment">//            System.out.println(e.toString());</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> <span class="title class_">GenerateTest</span>&lt;&gt;();</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// show1 不是泛型方法，所以T是指类GenerateTest 初始化的时候，限定的Fruit</span></span><br><span class="line">        generateTest.show1(apple);</span><br><span class="line"><span class="comment">//        generateTest.show1(person);</span></span><br><span class="line"></span><br><span class="line">      	<span class="comment">// show2方法有 &lt;T&gt; 修饰，所以此方法可以传入任意的类类型</span></span><br><span class="line">        generateTest.show2(apple);</span><br><span class="line">        generateTest.show2(person);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 同 show2</span></span><br><span class="line">        generateTest.show3(apple);</span><br><span class="line">        generateTest.show3(person);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// OUTPUT：</span></span><br><span class="line">  Apple</span><br><span class="line">	Apple</span><br><span class="line">  Person</span><br><span class="line">  Apple</span><br><span class="line">  Person</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="可变参数的泛型方法："><a href="#可变参数的泛型方法：" class="headerlink" title="可变参数的泛型方法："></a>可变参数的泛型方法：</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">      <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T... args)</span> {</span><br><span class="line">          <span class="keyword">for</span>(T t: args) {</span><br><span class="line">              System.out.println(<span class="string">"T is: "</span> + t);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">		... ...</span><br><span class="line">        </span><br><span class="line">		generateTest.print(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OUTPUT:</span></span><br><span class="line">T is: <span class="number">111</span></span><br><span class="line">T is: <span class="number">222</span></span><br><span class="line">T is: aaaa</span><br><span class="line">T is: <span class="number">2323.4</span></span><br><span class="line">T is: <span class="number">55.55</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="静态方法使用泛型参数："><a href="#静态方法使用泛型参数：" class="headerlink" title="静态方法使用泛型参数："></a>静态方法使用泛型参数：</h5><p>如果想要静态方法中使用泛型，即泛型参数。则这个静态方法必须为泛型方法 (<code>&lt;T&gt;</code>)：</p>
<p>错误示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">(T t)</span> {</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译ERROR：</span></span><br><span class="line">non-<span class="keyword">static</span> type variable T cannot be referenced from a <span class="keyword">static</span> context</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">(T t)</span> {</span><br></pre></td></tr></tbody></table></figure>

<p>正确用法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">(T t)</span> {</span><br><span class="line">    System.out.println(t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为如果是类中的变量使用了静态变量，静态变量的调用是可以在类初始化之前就调用的，而泛型类在初始化之前，还不能确定类型，所以不能在类中使用静态的泛型参数。</p>
<h5 id="泛型方法小结："><a href="#泛型方法小结：" class="headerlink" title="泛型方法小结："></a>泛型方法小结：</h5><ul>
<li>静态方法想要使用泛型参数，则必须使用泛型方法；</li>
<li>泛型方法必须要有泛型声明 <code>&lt;T&gt;</code>;</li>
<li> 尽量使用泛型方法</li>
</ul>
<h3 id="5-泛型通配符"><a href="#5-泛型通配符" class="headerlink" title="5 泛型通配符"></a>5 泛型通配符</h3><p>常用的泛型通配符为： <code>T，E，K，V，？</code> ，本质上这些字符都区别，是我们代码中一种约定俗成的东西。如上文提到的 <code>T</code>，我们可以使用 <code>A—Z</code> 中的任意字符替换，并不会影响程序本身的运行，但是如果使用其他字母替换的话，代码整体的可读性较弱，没有统一的规范。</p>
<p>通常：</p>
<ul>
<li><code>？</code> 表示不确定的 <code>java</code> 类型；</li>
<li><code>T (type)</code> 表示具体的一个 <code>java</code> 类型；</li>
<li><code>K V (key value)</code> 分别代表 <code>java</code> 键值中的 <code>Key Value</code>;</li>
<li><code>E (element)</code> 代表 <code>Element</code></li>
</ul>
<h4 id="无界通配符-lt-gt"><a href="#无界通配符-lt-gt" class="headerlink" title="无界通配符 <?>"></a>无界通配符 <code>&lt;?&gt;</code></h4><p>一般用于不确定或者不关心实际要操作的类类型，表示可以传入任意类类型参数；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testQuestion</span><span class="params">(GenericClass&lt;?&gt; objs)</span>{</span><br><span class="line">    System.out.println(objs);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="上界通配符-lt-extends-T-gt"><a href="#上界通配符-lt-extends-T-gt" class="headerlink" title="上界通配符<? extends T>"></a>上界通配符 <code>&lt;? extends T&gt;</code></h4><p>用 <code>extends</code> 关键字声明，表示参数类型可能是所指定 <code>T</code> 的类型，或者是此 <code>T</code> 类型的子类。这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 <code>T</code> 或者 <code>T</code> 的子类，编译不成功</li>
<li>泛型中可以使用 <code>T</code> 的方法，要强转成 <code>T</code> 才能使用 </li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;K <span class="keyword">extends</span> <span class="title class_">Apple</span>, E <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; E <span class="title function_">testUp</span><span class="params">(K k, E e)</span>{</span><br><span class="line">    <span class="type">E</span> <span class="variable">res</span> <span class="operator">=</span> e;</span><br><span class="line">    res.toString(k);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注</strong>： 类型参数列表中如果有多个类型参数上限，用逗号分开</p>
<h4 id="下界通配符-lt-super-T-gt"><a href="#下界通配符-lt-super-T-gt" class="headerlink" title="下界通配符<? super T>"></a>下界通配符 <code>&lt;? super T&gt;</code></h4><p>用 <code>super</code> 关键字声明，表示参数类型可能是所指定的 <code>T</code> 类型，或者是此 <code>T</code> 类型的父类型，直至 <code>Object</code> 类:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"animal eat"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Dog run"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Dog eat"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericLowBound</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Animal&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GenericLowBound</span>().test(animals, dogs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dst, List&lt;T&gt; src)</span> {</span><br><span class="line">        <span class="keyword">for</span> (T t: src) {</span><br><span class="line">            dst.add(t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述例子中 <code>test</code> 方法中 <code>dst</code> 类型范围是 <strong>“大于等于”</strong><code>src</code> 类型，所以 <code>dst</code> 的容器也能装下 <code>src</code>。</p>
<h4 id="lt-gt-和-gt-T-gt-的区别"><a href="#lt-gt-和-gt-T-gt-的区别" class="headerlink" title="<?>和>T>的区别"></a><code>&lt;?&gt;</code> 和 <code>&gt;T&gt;</code> 的区别</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 指定了集合tList中的元素的类型必须为T</span></span><br><span class="line">List&lt;T&gt; tList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的？指集合qList中元素类型可以为任意类型，没有任何实际意义，这里是用作例子说明</span></span><br><span class="line">List&lt;?&gt; qList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure>

<p>在泛型的使用中，<code>？</code>和 <code>T</code> 都是表示某一类型，区别是我们可以对 <code>T</code> 类型的参数进行一些操作（方法调用等），而<code>？</code>却不行，很容理解，因为<code>？</code>是不确定的类型，如果需要对参数进行某个方法调用，我们无法确定<code>？</code>的参数是否有这个方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">// 能确定operate()能返回T类型</span></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法确定？</span></span><br><span class="line">    ? q = operate();</span><br></pre></td></tr></tbody></table></figure>

<p><code>T</code> 是一个<strong>确定的</strong>类型，通常用于泛型类和泛型方法的定义，<code>？</code>是一个<strong>不确定</strong>的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h5 id="T可以用来保证泛型参数的一致性"><a href="#T可以用来保证泛型参数的一致性" class="headerlink" title="T可以用来保证泛型参数的一致性"></a><code>T</code> 可以用来保证泛型参数的一致性</h5><p>像下面的代码中，约定的 <code>T</code> 是 <code>Number</code> 的子类才可以，但是申明时是用的 <code>Animal</code> 和 <code>Dog</code>，所以就会报错。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Animal&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GenericLowBound</span>().test2(animals, dogs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(List&lt;T&gt; src, List&lt;T&gt; dest)</span> {</span><br><span class="line">        System.out.println(src);</span><br><span class="line">        System.out.println(dest);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">Error：</span><br><span class="line">========================</span><br><span class="line">error: method test2 in <span class="keyword">class</span> <span class="title class_">GenericLowBound</span> cannot be applied to given types;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GenericLowBound</span>().test2(animals, dogs);</span><br><span class="line">                             ^</span><br><span class="line">  required: List&lt;T&gt;,List&lt;T&gt;</span><br><span class="line">  found: List&lt;Animal&gt;,List&lt;Dog&gt;</span><br><span class="line">  reason: inference variable T has incompatible bounds</span><br><span class="line">    equality constraints: Dog,Animal</span><br><span class="line">    upper bounds: Number</span><br><span class="line">  where T is a type-variable:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Number</span> declared in method &lt;T&gt;test2(List&lt;T&gt;,List&lt;T&gt;)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="类型参数T可以多重限定而通配符-不行"><a href="#类型参数T可以多重限定而通配符-不行" class="headerlink" title="类型参数T可以多重限定而通配符?不行"></a>类型参数 <code>T</code> 可以多重限定而通配符 <code>?</code> 不行</h5><p>使用 <code>&amp;</code> 符号设定多重边界（<code>Multi Bounds</code>)，指定泛型类型 <code>T</code> 必须是 <code>MultiLimitInterfaceA</code> 和 <code>MultiLimitInterfaceB</code> 的共有子类型，此时变量 <code>t</code> 就具有了所有限定的方法和属性。对于通配符 <code>?</code> 来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MultiLimitInterfaceA</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MultiLimitInterfaceB</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiLimitClass</span> <span class="keyword">implements</span> <span class="title class_">MultiLimitInterfaceA</span>, MultiLimitInterfaceB{</span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">MultiLimitInterfaceA</span> &amp; MultiLimitInterfaceB&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span> {</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>##### 通配符 <code>?</code> 可以使用<strong>超类限定</strong>而类型参数 <code>T</code> 不行</p>
<p>类型参数 <code>T</code> 只具有 一种类型限定方式 (<code>extends</code>):</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="title class_">A</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是通配符 <code>?</code> 可以进行两种限定 (<code>extends  + super</code>)：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">? <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">? <span class="built_in">super</span> A</span><br></pre></td></tr></tbody></table></figure>

<h4 id="List-lt-T-gt-，List-lt-Object-gt-，List-lt-gt-区别"><a href="#List-lt-T-gt-，List-lt-Object-gt-，List-lt-gt-区别" class="headerlink" title="List<T>，List<Object>，List<?>区别"></a><code>List&lt;T&gt;</code>，<code>List&lt;Object&gt;</code>，<code>List&lt;?&gt;</code> 区别</h4><p>前面已经说过 <code>&lt;T&gt;</code> 和 <code>&lt;?&gt;</code> 的区别，这里主要说明下 <code>&lt;Object&gt;</code>，<code>Object</code> 和 <code>T</code> 不同点在于，<code>Object</code> 是一个实打实的类，并没有泛指谁，而 <code>T</code> 可以泛指比如 <code>Object</code> , **<code>public void printList2(List&lt;T&gt; list){}</code><strong>方法中可以传入</strong><code>List&lt;Object&gt; list</code><strong>类型参数，也可以传入</strong><code>List&lt;String&gt; list</code><strong>类型参数，但是</strong><code>public void printList1(List&lt;Object&gt; list){}</code><strong>就只可以传入</strong><code>List&lt;Object&gt; list</code>** 类型参数，因为 <code>Object</code> 类型并没有泛指谁，是一个确定的类型.</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDifferenceBetweenObjectAndT</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList1</span><span class="params">(List&lt;Object&gt; list)</span> {</span><br><span class="line">        <span class="keyword">for</span> (Object elem : list)</span><br><span class="line">            System.out.println(elem + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printList2</span><span class="params">(List&lt;T&gt; list)</span> {</span><br><span class="line">        <span class="keyword">for</span> (T elem : list)</span><br><span class="line">            System.out.println(elem + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList3</span><span class="params">(List&lt;?&gt; list)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;list.size();i++)</span><br><span class="line">            System.out.println(list.get(i) + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;Integer&gt; test1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        List&lt;String&gt; test2 = Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</span><br><span class="line">        List&lt;Object&gt; test3 = Arrays.asList(<span class="number">1</span>, <span class="string">"two"</span>, <span class="number">1.23</span>);</span><br><span class="line">        List&lt;GenericsFruit.Fruit&gt; test4 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">GenericsFruit</span>.Apple(), <span class="keyword">new</span> <span class="title class_">GenericsFruit</span>.Banana());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面这句会编译报错，因为参数不能转化成功</span></span><br><span class="line"><span class="comment">//        printList1(test4);</span></span><br><span class="line">        printList1(test3);</span><br><span class="line">        printList1(test3);</span><br><span class="line">        printList2(test1);</span><br><span class="line">        printList2(test2);</span><br><span class="line">        printList2(test3);</span><br><span class="line">        printList3(test1);</span><br><span class="line">        printList3(test2);</span><br><span class="line">        printList3(test3);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//OUTPUT</span></span><br><span class="line">========</span><br><span class="line">&gt; Task :TestDifferenceBetweenObjectAndT.main()</span><br><span class="line"><span class="number">1</span> </span><br><span class="line">two </span><br><span class="line"><span class="number">1.23</span> </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> </span><br><span class="line">two </span><br><span class="line"><span class="number">1.23</span> </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"></span><br><span class="line">one </span><br><span class="line">two </span><br><span class="line">three </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> </span><br><span class="line">two </span><br><span class="line"><span class="number">1.23</span> </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"></span><br><span class="line">one </span><br><span class="line">two </span><br><span class="line">three </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> </span><br><span class="line">two </span><br><span class="line"><span class="number">1.23</span> </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="lt-T-gt-，Class-lt-T-gt-，Class-lt-gt-的区别"><a href="#lt-T-gt-，Class-lt-T-gt-，Class-lt-gt-的区别" class="headerlink" title="<T>，Class<T>，Class<?>的区别"></a><code>&lt;T&gt;</code>，<code>Class&lt;T&gt;</code>，<code>Class&lt;?&gt;</code> 的区别</h4><p>前面说过 <code>&lt;T&gt;</code> 是指某个确定的类类型，如 <code>String</code>, <code>Integer</code>, <code>Map</code> 等。</p>
<p>那 <a href="https://blog.csdn.net/javazejian/article/details/70768369"><code>Class</code></a>是什么呢？<code>Class</code> 也是一个类，但在 <code>Class</code> 存放上 <code>&lt;String&gt;, &lt;List&gt;, &lt;Map&gt;</code> 等类信息的一个类，有点抽象，下面具体分析：</p>
<p>#####<code>Java</code> 当中有 3 种获取 <code>Class</code> 的方式：</p>
<ol>
<li><p><strong>调用 <code>Object</code> 类的 <code>getClass()</code> 方法来得到 <code>Class</code> 对象，这也是最常见的产生 <code>Class</code> 对象的方法</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> list.getClass();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用 <code>Class</code> 类的中静态 <code>forName()</code> 方法获得与字符串对应的 <code>Class</code> 对象</strong>:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> Class.forName(<span class="string">"interview.generics.Dog"</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>如果 <code>T</code> 是一个 <code>Java</code> 类型，那么 <code>T.class</code> 就代表了匹配的类对象</strong>:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> List.class;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>Class<t><code>和</code> Class&lt;?&gt;` 的使用场景:</t></p>
<p>使用 <code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code> 多发生在反射场景下，先看看如果我们不使用泛型，反射创建一个类是什么样的.</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 需要强转，如果反射的类型不是Dog类，就会报</span></span><br><span class="line"><span class="comment">// java.lang.ClassCastException错误。</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) Class.forName(<span class="string">"interview.generics.Dog"</span>).newInstance();</span><br></pre></td></tr></tbody></table></figure>

<p>使用 Class<t> 泛型后，不用强转了。</t></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCreateClassWithGenerics</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">createInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException {</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException {</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> createInstance(Dog.class);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>#####<code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code> 的区别:</p>
<p><strong><code>Class&lt;T&gt;</code> 在实例化的时候，<code>T</code> 要替换成具体类</strong>， 如前面那个例子中 <code>createInstance(Dog.class)</code>，传入的是具体的 **<code>Dog.class</code>**;</p>
<p><strong><code>Class&lt;?&gt;</code> 它是个通配泛型，<code>?</code> 可以代表任何类型，主要用于声明时的限制情况</strong> :</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 可以声明如下</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; clazz1;</span><br><span class="line">  <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; clazz2;</span><br><span class="line">  <span class="keyword">public</span> Class&lt;? <span class="built_in">super</span> Number&gt; clazz3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以声明，除非是在一个泛型类中 T 有提前声明</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;T&gt; clazz4;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-泛型的类型擦除详解"><a href="#6-泛型的类型擦除详解" class="headerlink" title="6 泛型的类型擦除详解"></a>6 泛型的类型擦除详解</h3><p>前面我们举了<a href="###%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">一个例子</a>大概说明了一下什么是泛型的类型擦除：<code>Java</code> 的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p>
<p>如在代码中定义 <code>List&lt;Object&gt;</code> 和 <code>List&lt;String&gt;</code> 等类型，在编译后都会变成 <code>List</code>，<code>JVM</code> 看到的只是 <code>List</code>，而由泛型附加的类型信息对 <code>JVM</code> 是看不到的。<code>Java</code> 编译器会在编译时<strong>尽可能</strong>的发现可能出错的地方，但是<strong>仍然无法发现在运行时刻出现的类型转换异常</strong>的情况，类型擦除也是 <code>Java</code> 的泛型与 <code>C++</code> 模板机制实现方式之间的重要区别。</p>
<p>除了前面提到的那个例子，我们再用一个反射的例子，来说明类型擦除：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGenericsTypeErasure</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException {</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod(<span class="string">"add"</span>, Object.class).invoke(list, <span class="string">"asd"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) {</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//OUTPUT:</span></span><br><span class="line">&gt; Task :TestGenericsTypeErasure.main()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">asd</span><br></pre></td></tr></tbody></table></figure>

<p>在程序中定义了一个 <code>ArrayList</code> 泛型类型实例化为 <code>Integer</code> 对象，如果直接调用 <code>add()</code> 方法，那么只能存储整数数据，不过当我们利用反射调用 <code>add()</code> 方法的时候，却可以存储字符串，这说明了 <code>Integer</code> 泛型实例在编译之后被擦除掉了，只保留了原始类型。</p>
<h4 id="泛型类型擦除后保留的原始类型"><a href="#泛型类型擦除后保留的原始类型" class="headerlink" title="泛型类型擦除后保留的原始类型"></a>泛型类型擦除后保留的原始类型</h4><h5 id="什么是原始类型？"><a href="#什么是原始类型？" class="headerlink" title="什么是原始类型？"></a>什么是原始类型？</h5><p>就是在泛型类编译后，擦去了泛型信息，最后在字节码中参数类型的真正类型。</p>
<ul>
<li><p>在没有限定泛型类型时（上界），泛型参数会被自动转成该方法中的几种类型的最小公共父类，直到 <code>Object</code> 类型（所有类的公共父类）；</p>
</li>
<li><p>在指定泛型类型时，该方法的几种类型必须是该泛型的实例的类型或者其子类。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPublicParentClass</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 不指定泛型时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> TestPublicParentClass.returnT(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型</span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> TestPublicParentClass.returnT(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> TestPublicParentClass.returnT(<span class="number">1</span>, <span class="string">"abc"</span>); <span class="comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定泛型的时候</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> TestPublicParentClass.&lt;Integer&gt;returnT(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以T只能为Integer类型或者其子类</span></span><br><span class="line">        <span class="comment">// int b = TestPublicParentClass.&lt;Integer&gt;returnT(1, 2.2); //编译错误，指定了Integer，不能为Float</span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> TestPublicParentClass.&lt;Number&gt;returnT(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">returnT</span><span class="params">(T x, T y)</span> {</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h5 id="Object泛型"><a href="#Object泛型" class="headerlink" title="Object泛型"></a><code>Object</code> 泛型</h5><p>在泛型类中，如果不指定泛型的时候，这个时候的泛型为 <code>Object</code>，就比如 <code>ArrayList</code> 中，如果不指定泛型，那么这个 <code>ArrayList</code> 可以存储任意的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 即： ArrayList list = new ArrayList();</span></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="string">"121"</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></tbody></table></figure>

<h4 id="先检查，再编译以及编译的对象和引用传递问题"><a href="#先检查，再编译以及编译的对象和引用传递问题" class="headerlink" title="先检查，再编译以及编译的对象和引用传递问题"></a>先检查，再编译以及编译的对象和引用传递问题</h4><h5 id="先检查，再编译"><a href="#先检查，再编译" class="headerlink" title="先检查，再编译"></a>先检查，再编译</h5><p><strong>问：</strong> 前面提到过类型变量会在编译的时候擦除掉，那为什么我们往 <code>ArrayList</code> 创建的对象中添加整数会报错呢？不是说泛型变量 <code>String</code> 会在编译的时候变为 <code>Object</code> 类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p>
<p><strong>答：</strong><code>Java</code> 编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {  </span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">    list.add(<span class="string">"123"</span>);  </span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">//编译错误  </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的程序中，使用 <code>add</code> 方法添加一个整型，在 <code>IDE</code> 中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为 <code>Object</code>，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p>
<p>还是以 <code>ArrayList</code> 为例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">//以前的写法</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//现在的写法</span></span><br><span class="line">    ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</span></span><br><span class="line">    ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//第一种情况</span></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//第二种情况</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上代码都能通过编译，不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p>
<p>因为类型检查就是编译时完成的，<code>new ArrayList()</code> 只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用 <code>list1</code> 来调用它的方法，比如说调用 <code>add</code> 方法，所以 <code>list1</code> 引用能完成泛型类型的检查。而引用 <code>list2</code> 没有使用泛型，所以不行。</p>
<h5 id="编译的对象"><a href="#编译的对象" class="headerlink" title="编译的对象"></a>编译的对象</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCheckingOfGenerics</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">"1"</span>); <span class="comment">//检查通过  编译通过</span></span><br><span class="line"><span class="comment">//        list1.add(1); //检查错误  编译错误</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> list1.get(<span class="number">0</span>); <span class="comment">//返回类型就是String</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list2.add(<span class="string">"1"</span>); <span class="comment">//检查通过  编译通过</span></span><br><span class="line">        list2.add(<span class="number">1</span>); <span class="comment">//检查通过  编译通过</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list2.get(<span class="number">0</span>); <span class="comment">//返回类型就是Object</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">"1"</span>); <span class="comment">//检查通过  编译通过</span></span><br><span class="line"><span class="comment">//        new ArrayList&lt;String&gt;().add(22); //检查错误  编译错误</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p>
<h5 id="引用传递问题"><a href="#引用传递问题" class="headerlink" title="引用传递问题"></a>引用传递问题</h5><p>有继承关系的两种情况，引用传递都是不允许的：</p>
<ol>
<li><pre><code class="java">ArrayList&lt;String&gt; list1 = new ArrayList&lt;Object&gt;(); //编译错误 
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">将代码拓展：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">        ArrayList&lt;Object&gt; list11 = new ArrayList&lt;Object&gt;();</span><br><span class="line">        list11.add(new Object());</span><br><span class="line">        list11.add(new Object());</span><br><span class="line">//        ArrayList&lt;String&gt; list12 = list11; //编译错误</span><br><span class="line"></span><br><span class="line">// ERROR:</span><br><span class="line">error: incompatible types: ArrayList&lt;Object&gt; cannot be converted to ArrayList&lt;String&gt;</span><br><span class="line">        ArrayList&lt;String&gt; list12 = list11; //编译错误</span><br></pre></td></tr></tbody></table></figure>

实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用`list12`引用用`get()`方法取值的时候，返回的都是`String`类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了`Object`类型的对象，这样就会有`ClassCastException`了。所以为了避免这种极易出现的错误，`Java`不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）
</code></pre>
</li>
<li><p>```java<br>ArrayList<object> list2 = new ArrayList<string>(); // 编译错误 <p></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">将代码拓展：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">        ArrayList&lt;String&gt; list21 = new ArrayList&lt;&gt;();</span><br><span class="line">        list21.add(new String());</span><br><span class="line">        list21.add(new String());</span><br><span class="line">//        ArrayList&lt;Object&gt; list22 = list21; //编译错误</span><br><span class="line"></span><br><span class="line">// ERROR:</span><br><span class="line">error: incompatible types: ArrayList&lt;String&gt; cannot be converted to ArrayList&lt;Object&gt;</span><br><span class="line">        ArrayList&lt;Object&gt; list22 = list21;</span><br></pre></td></tr></tbody></table></figure>

<p>泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以 <code>java</code> 不允许这么干。再说，你如果又用 <code>list21</code> 往里面 <code>add()</code> 新的对象，那么到时候取得时候，我怎么知道我取出来的到底是 <code>String</code> 类型的，还是 <code>Object</code> 类型的呢？</p>


<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>因为类型擦除，所有的泛型变量在编译以后都转为原始类型了，<strong>那为什么我们从泛型集合内获取元素时，不需要强制类型转换？</strong></p>
<p>以 <code>ArrayList</code> 的 <code>get()</code> 方法为例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到在 retrun 之前，泛型变量会先被强制转换。假设泛型类型变量为 <code>Date</code>，虽然代码编译以后泛型信息会被擦除掉，但是会将 <code>(E) elementData[index]</code>，编译为 <code>(Date)elementData[index]</code>。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。</p>
<h4 id="类型擦除与多态"><a href="#类型擦除与多态" class="headerlink" title="类型擦除与多态"></a>类型擦除与多态</h4><p>一个例子：</p>
<p>父类（泛型）：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassErasureAndGenerics</span>&lt;T&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public Object getValue(){</span></span><br><span class="line"><span class="comment">//        return new Object();</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>子类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassErasureAndGenericsSub</span> <span class="keyword">extends</span> <span class="title class_">ClassErasureAndGenerics</span>&lt;Date&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> {</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ClassErasureAndGenericsSub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassErasureAndGenericsSub</span>();</span><br><span class="line">        sub.setValue(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//        sub.setValue(new Object());</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>按照前面提到，父类编译以后，<code>T</code> 会被转换成原始类型 <code>Object</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//javap</span></span><br><span class="line">Mark:generics mark$ javap -c ClassErasureAndGenerics.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">"ClassErasureAndGenerics.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">interview</span>.generics.ClassErasureAndGenerics&lt;T&gt; {</span><br><span class="line">  <span class="keyword">public</span> interview.generics.ClassErasureAndGenerics();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field value:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field value:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那么在子类中的 <code>setValue</code> 方法调用的类型是 <code>Date</code>，参数类型不一致，那在 <code>java</code> 中提到的，如果方法类型不一样，方法名一样，应该是重载，而不是重写，但是重载是发生在同一个类中的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ClassErasureAndGenericsSub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassErasureAndGenericsSub</span>();</span><br><span class="line">        sub.setValue(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">// sub.setValue(new Object()); 编译错误</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//ERROR：</span></span><br><span class="line">error: no suitable method found <span class="keyword">for</span> <span class="title function_">setValue</span><span class="params">(Object)</span></span><br><span class="line">        sub.setValue(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">           ^</span><br><span class="line">    method ClassErasureAndGenerics.setValue(Date) is not <span class="title function_">applicable</span></span><br><span class="line">      <span class="params">(argument mismatch; Object cannot be converted to Date)</span></span><br><span class="line">    method ClassErasureAndGenericsSub.setValue(Date) is not <span class="title function_">applicable</span></span><br><span class="line">      <span class="params">(argument mismatch; Object cannot be converted to Date)</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上代码再次证明了，这个确实是重写，而不是重载。</p>
<p>这不是与我们之前解释的理论相矛盾了吗？从 <code>Java</code> 语法上来看，子类的类型是 <code>Data</code>，而父类的类型在反编译中也很清楚是 <code>Object</code> 的，这样应该是重载呀。类型擦除就和多态有了冲突。<code>JVM</code> 知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的 <code>Date</code> 类型参数的方法啊。</p>
<p>再看看 <code>ClassErasureAndGenericsSub.class</code> 的反编译：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ark:generics mark$ javap -c ClassErasureAndGenericsSub.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">"ClassErasureAndGenericsSub.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">interview</span>.generics.ClassErasureAndGenericsSub <span class="keyword">extends</span> <span class="title class_">interview</span>.generics.ClassErasureAndGenerics&lt;java.util.Date&gt; {</span><br><span class="line">  <span class="keyword">public</span> interview.generics.ClassErasureAndGenericsSub();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method interview/generics/ClassErasureAndGenerics."&lt;init&gt;":()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.util.Date)</span>;     <span class="comment">// &lt;--- Override setValue</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       <span class="number">2</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method interview/generics/ClassErasureAndGenerics.setValue:(Ljava/lang/Object;)V</span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       <span class="number">2</span>: checkcast     #<span class="number">4</span>                  <span class="comment">// class java/util/Date</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method setValue:(Ljava/util/Date;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>       </span><br><span class="line">    </span><br><span class="line"> -----------------------------------------------        </span><br><span class="line">         </span><br><span class="line">  <span class="keyword">public</span> java.lang.Object <span class="title function_">getValue</span><span class="params">()</span>;       <span class="comment">// &lt;--- Override getValue</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method getValue:()Ljava/util/Date;</span></span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Date <span class="title function_">getValue</span><span class="params">()</span>;         </span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method interview/generics/ClassErasureAndGenerics.getValue:()Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: checkcast     #<span class="number">4</span>                  <span class="comment">// class java/util/Date</span></span><br><span class="line">       <span class="number">7</span>: areturn</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>从编译的结果来看，我们本意重写 <code>setValue</code> 和 <code>getValue</code> 方法的子类，竟然有 <code>4</code> 个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的<strong>桥方法</strong>。可以看到桥方法的参数类型都是 <code>Object</code>，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的 <code>setvalue</code> 和 <code>getValue</code> 方法上面的 <code>@Oveerride</code> 只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p>
<p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p>
<p>不过，要提到一点，这里面的 <code>setValue</code> 和 <code>getValue</code> 这两个桥方法的意义又有不同。</p>
<p><code>setValue</code> 方法是为了解决类型擦除与多态之间的冲突。</p>
<p>而 <code>getValue</code> 却有普遍的意义。</p>
<p>即如果这是一个普通的继承关系，那么父类的 <code>getValue</code> 方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> {  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>子类方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> {  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这在普通的类继承中也是普遍存在的重写。</p>
<h4 id="为什么泛型变量不能是基本数据类型"><a href="#为什么泛型变量不能是基本数据类型" class="headerlink" title="为什么泛型变量不能是基本数据类型"></a>为什么泛型变量不能是基本数据类型</h4><p>因为类型擦除以后，假设原始类型转变为 <code>Object</code>，而 <code>Object</code> 变量中无法存基本类型。</p>
<p>如： 没有 <code>ArrayList&lt;double&gt;</code>，只有 <code>ArrayList&lt;Double&gt;</code>。因为当类型擦除后，<code>ArrayList</code> 的原始类型变为 <code>Object</code>，但是 <code>Object</code> 类型不能存储 <code>double</code> 值，只能引用 <code>Double</code> 的值。</p>
<h4 id="为什么泛型类型不能使用instanceof"><a href="#为什么泛型类型不能使用instanceof" class="headerlink" title="为什么泛型类型不能使用instanceof"></a>为什么泛型类型不能使用 <code>instanceof</code></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (val <span class="keyword">instanceof</span> GenericClass&lt;Integer&gt;) {</span><br><span class="line">    System.out.println(<span class="string">"test"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为类型擦除后，<code>Integer</code> 被转成原始类型，泛型信息 <code>Integer</code> 已经不存在了。</p>
<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h3><ul>
<li><a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9#heading-4">聊一聊 - JAVA 泛型中的通配符 T，E，K，V，？</a> </li>
<li><a href="https://www.toutiao.com/a6694132392728199683">JAVA 泛型通配符 T，E，K，V 区别，网友回复：一文秒懂</a></li>
<li><a href="https://blog.csdn.net/s10461/article/details/53941091">java 泛型详解 - 绝对是对泛型方法讲解最详细的，没有之一</a></li>
<li><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java 泛型类型擦除以及类型擦除带来的问题</a></li>
</ul>
</string></object></p></li></ol>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2023/01/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实际场景"><a href="#1-实际场景" class="headerlink" title="1 实际场景"></a>1 实际场景</h1><h2 id="1-1-读取配置文件的内容"><a href="#1-1-读取配置文件的内容" class="headerlink" title="1.1 读取配置文件的内容"></a>1.1 读取配置文件的内容</h2><p>很多应用项目中，都有与应用相关的配置文件，这些配置文件是由项目开发人员自定义的，在里面定义一些应用需要的参数数据。在实际的项目中，这种配置文件多采用 <code>xml</code> 格式的。也有采用 <code>properties</code> 格式（使用 <code>Java</code> 来读取 <code>properties</code> 格式的配置文件比较简单）</p>
<p><strong>考虑如何实现代码来读取配置文件中的内容？</strong></p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h2 id="1-2-不使用设计模式的方式"><a href="#1-2-不使用设计模式的方式" class="headerlink" title="1.2 不使用设计模式的方式"></a>1.2 不使用设计模式的方式</h2><p>直接读取文件内容，再将文件内容存放在相应的数据对象中。假设系统采用的是 <code>properties</code> 格式的配置文件。</p>
<p>1、直接使用 Java 来读取配置文件</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> AppConfig.java v 0.1 2023/1/28 14:55 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存放配置文件中参数A的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String parameterA;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存放配置文件中参数B的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String parameterB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameterA</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> parameterA;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameterB</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> parameterB;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppConfig</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 调用读取配置文件的方法</span></span><br><span class="line">        readConfig();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置文件，把配置文件中的内容读出来设置到属性上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readConfig</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            in = AppConfig.class.getResourceAsStream(<span class="string">"/Test.properties"</span>);</span><br><span class="line">            p.load(in);</span><br><span class="line">            <span class="comment">//把配置文件中的内容读出来设置到属性上</span></span><br><span class="line">            <span class="built_in">this</span>.parameterA = p.getProperty(<span class="string">"paramA"</span>);</span><br><span class="line">            <span class="built_in">this</span>.parameterB = p.getProperty(<span class="string">"paramB"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            System.out.println(<span class="string">"装载配置文件出错了，具体堆栈信息如下："</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">assert</span> in != <span class="literal">null</span>;</span><br><span class="line">                in.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><strong>只有访问参数的方法，没有设置参数的方法</strong></p>
</blockquote>
<p>2、应用的配置文件，名字是 <code>Test.properties</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">paramA=a</span><br><span class="line">paramB=b</span><br></pre></td></tr></tbody></table></figure>

<p>3、客户端代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/1/28 15:02 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">AppConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppConfig</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">paramA</span> <span class="operator">=</span> config.getParameterA();</span><br><span class="line">        <span class="type">String</span> <span class="variable">paramB</span> <span class="operator">=</span> config.getParameterB();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"paramA="</span> + paramA + <span class="string">",paramB="</span> + paramB);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-存在的问题"><a href="#1-3-存在的问题" class="headerlink" title="1.3 存在的问题"></a>1.3 存在的问题</h2><p>如上客户端的代码，是通过 <code>new</code> 一个 <code>AppConfig</code> 的实例来得到一个配置文件内容的对象。假设在系统的运行过程中，有许多地方都需要使用此配置文件，即：有很多地方都需要创建该对象的实例。</p>
<blockquote>
<p><strong>换句话说，在系统运行期间，系统中会存在很多个・<code>AppConfig</code> 的实例对象，这有什么问题吗？</strong></p>
</blockquote>
<p>肯定有问题！每一个 <code>AppConfig</code> 实例对象，里面都封装着配置文件的内容，系统中有多个 <code>AppConfig</code> 实例对象，也就是说系统中会同时存在多份配置文件的内容，这会严重浪费内存资源。如果配置文件内容较少，问题还小一点，如果配置文件内容较大，会造成系统资源严重浪费。<strong>事实上，对于 <code>AppConfig</code> 这种类，在运行期间，只需要一个实例对象就够了。</strong></p>
<blockquote>
<p>进一步抽象问题：<strong>在一个系统运行期间，某个类只需要一个类实例就可以了，那么应该怎么实现呢？</strong></p>
</blockquote>
<h1 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h1><h2 id="2-1-单例模式"><a href="#2-1-单例模式" class="headerlink" title="2.1 单例模式"></a>2.1 单例模式</h2><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h3><p>单例模式（<code>Singleton</code>）：保证一个类仅有一个实例，并提供一个可被全局访问的访问点。</p>
<h3 id="2-1-2-单例模式解决问题的思路"><a href="#2-1-2-单例模式解决问题的思路" class="headerlink" title="2.1.2 单例模式解决问题的思路"></a>2.1.2 单例模式解决问题的思路</h3><p>通过分析上面的问题，一个类能够被创建多个实例，问题的根源在于类的构造方法是公开的，也就是可以让类的外部来通过构造方法创建多个实例。换句话说，只要类的构造方法能让类的外部访问，就没有办法去控制外部来创建这个类的实例个数。</p>
<p>要想控制一个类只被创建一个实例，那么<strong>首要的问题就是要把创建实例的权限收回来，让类自身来负责自己类实例的创建工作，然后由这个类来提供外部可以访问这个类实例的方法，这就是单例模式的实现方式</strong>。</p>
<h2 id="2-2-结构说明"><a href="#2-2-结构说明" class="headerlink" title="2.2 结构说明"></a>2.2 结构说明</h2><img src="/2023/01/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230128163408983.png" alt="image-20230128163408983" style="zoom:67%;">

<blockquote>
<p><strong>Singleton：负责创建 <code>Singleton</code> 类自己的唯一实例，并提供一个 <code>getInstance</code> 的方法，让外部来访问这个类的唯一实例。</strong></p>
</blockquote>
<h2 id="2-3-代码示例"><a href="#2-3-代码示例" class="headerlink" title="2.3 代码示例"></a>2.3 代码示例</h2><p>单例模式的实现又分为两种，<strong>一种称为懒汉式，一种称为饿汉式</strong>，其实就是在具体创建对象实例的处理上，有不同的实现方式。</p>
<p>1、懒汉式实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Singleton.java v 0.1 2023/1/28 16:44 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 懒汉式单例实现的示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个变量来存储创建好的类实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法，好在内部控制创建实例的数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法来为客户端提供类实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个Singleton的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//判断存储实例的变量是否有值</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">//如果没有，就创建一个类实例，并把值赋值给存储类实例的变量</span></span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果有值，那就直接使用</span></span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，单例可以有自己的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singletonOperation</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//功能处理</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意属性，单例可以有自己的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String singletonData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，让外部通过这些方法来访问属性的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSingletonData</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> singletonData;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、饿汉式实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Singleton.java v 0.1 2023/1/28 16:48 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 饿汉式单例实现的示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个变量来存储创建好的类实例，直接在这里创建类实例，只会创建一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法，好在内部控制创建实例的数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//  </span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法来为客户端提供类实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个Singleton的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//直接使用已经创建好的实例  </span></span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，单例可以有自己的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singletonOperation</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//功能处理  </span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意属性，单例可以有自己的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String singletonData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，让外部通过这些方法来访问属性的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSingletonData</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> singletonData;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-4-重写方案"><a href="#2-4-重写方案" class="headerlink" title="2.4 重写方案"></a>2.4 重写方案</h2><p>选择饿汉式的方式来重写示例</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Singleton.java v 0.1 2023/1/28 16:54 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 读取应用配置文件，单例实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonAppConfig</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个变量来存储创建好的类实例，直接在这里创建类实例，只会创建一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonAppConfig</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAppConfig</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法来为客户端提供AppConfig类的实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个AppConfig的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonAppConfig <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存放配置文件中参数A的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String parameterA;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存放配置文件中参数B的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String parameterB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameterA</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> parameterA;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameterB</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> parameterB;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonAppConfig</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//调用读取配置文件的方法</span></span><br><span class="line">        readConfig();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置文件，把配置文件中的内容读出来设置到属性上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readConfig</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            in = AppConfig.class.getResourceAsStream(<span class="string">"/Test.properties"</span>);</span><br><span class="line">            p.load(in);</span><br><span class="line">            <span class="comment">//把配置文件中的内容读出来设置到属性上</span></span><br><span class="line">            <span class="built_in">this</span>.parameterA = p.getProperty(<span class="string">"paramA"</span>);</span><br><span class="line">            <span class="built_in">this</span>.parameterB = p.getProperty(<span class="string">"paramB"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            System.out.println(<span class="string">"装载配置文件出错了，具体堆栈信息如下："</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">assert</span> in != <span class="literal">null</span>;</span><br><span class="line">                in.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> SingletonClient.java v 0.1 2023/1/28 16:57 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试的客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">SingletonAppConfig</span> <span class="variable">config</span> <span class="operator">=</span> SingletonAppConfig.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">paramA</span> <span class="operator">=</span> config.getParameterA();</span><br><span class="line">        <span class="type">String</span> <span class="variable">paramB</span> <span class="operator">=</span> config.getParameterB();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"paramA="</span> + paramA + <span class="string">",paramB="</span> + paramB);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="3-模式讲解"><a href="#3-模式讲解" class="headerlink" title="3 模式讲解"></a>3 模式讲解</h1><h2 id="3-1-认识单例模式"><a href="#3-1-认识单例模式" class="headerlink" title="3.1 认识单例模式"></a>3.1 认识单例模式</h2><h3 id="3-1-1-功能"><a href="#3-1-1-功能" class="headerlink" title="3.1.1 功能"></a>3.1.1 功能</h3><p>单例模式的功能是用来保证这个类在运行期间只会被创建一个类实例，另外单例模式还提供了一个全局唯一访问这个类实例的访问点，即：<code>getInstance</code> 方法。不管采用懒汉式还是饿汉式的实现方式，这个全局访问点是一样的。</p>
<blockquote>
<p> 对于单例模式而言，<strong>不管采用何种实现方式，它都是只关心类实例的创建问题</strong>，并不关心具体的业务功能。</p>
</blockquote>
<h3 id="3-1-2-作用范围"><a href="#3-1-2-作用范围" class="headerlink" title="3.1.2 作用范围"></a>3.1.2 作用范围</h3><p><strong>目前 <code>Java</code> 里面实现的单例是一个 <code>ClassLoader</code> 及其子 <code>ClassLoader</code> 的范围。因为一个 <code>ClassLoader</code> 在装载饿汉式实现的单例类的时候就会创建一个类的实例</strong>。</p>
<p><strong>这就意味着如果一个 <code>JVM</code> 里面有很多个 <code>ClassLoader</code>，而且这些 <code>ClassLoader</code> 都装载某个类的话，就算这个类是单例，它也会产生很多个实例</strong>。当然，如果一个机器上有多个虚拟机，那么每个虚拟机里面都应该至少有一个这个类的实例，也就是说整个机器上就有很多个实例，这就不算单例。</p>
<blockquote>
<p>另外注意：这里讨论的单例模式并不适用于集群环境</p>
</blockquote>
<h3 id="3-1-3-命名"><a href="#3-1-3-命名" class="headerlink" title="3.1.3 命名"></a>3.1.3 命名</h3><p><strong>一般建议单例模式的方法命名为：<code>getInstance()</code>，该方法的返回类型是单例类的类型。</strong><code>getInstance</code> 方法可以有参数，这些参数可能是创建类实例所需要的参数（大多数情况下是不需要的）</p>
<h2 id="3-2-懒汉式和饿汉式"><a href="#3-2-懒汉式和饿汉式" class="headerlink" title="3.2 懒汉式和饿汉式"></a>3.2 懒汉式和饿汉式</h2><p>前面示例中提到了单例的两种模式：<strong>懒汉式和饿汉式</strong>，本章节会介绍一些实现细节，为了看得更清晰一点，只是实现基本的单例控制部分，不再提供示例的属性和方法。</p>
<blockquote>
<p><strong>关于线程安全的问题，在后面会重点分析</strong></p>
</blockquote>
<h3 id="3-2-1-懒汉式"><a href="#3-2-1-懒汉式" class="headerlink" title="3.2.1 懒汉式"></a>3.2.1 懒汉式</h3><h4 id="1、私有化构造方法"><a href="#1、私有化构造方法" class="headerlink" title="1、私有化构造方法"></a>1、私有化构造方法</h4><p>要想在运行期间控制某一个类的实例只有一个，<strong>那首先的任务就是要控制创建实例的地方，也就是不能随随便便就可以创建类实例</strong>。现在是让使用类的地方来创建类实例，也就是在类外部来创建类实例。那么怎样才能让类的外部不能创建一个类的实例呢？—— <strong>私有化构造方法</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {  </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h4 id="2、提供获取实例的方法"><a href="#2、提供获取实例的方法" class="headerlink" title="2、提供获取实例的方法"></a>2、提供获取实例的方法</h4><p>构造方法被私有化，则外部创建不了该类的实例就无法调用这个对象的方法，就实现不了功能处理，单例模式可以让这个类提供一个方法来返回实例，以提供给外部使用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3、获取实例的方法改为静态方法"><a href="#3、获取实例的方法改为静态方法" class="headerlink" title="3、获取实例的方法改为静态方法"></a>3、获取实例的方法改为静态方法</h4><p>随着上一个步骤，产生一个新问题，获取对象实例的这个方法是个实例方法，客户端要想调用这个方法，需要先得到类实例，然后才可以调用，导致死循环问题。</p>
<p>解法是将获取实例的方法改成静态方法 <code>static</code>，这样可以直接通过类来调用此静态方法获取实例。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<h4 id="4、定义存储实例的属性"><a href="#4、定义存储实例的属性" class="headerlink" title="4、定义存储实例的属性"></a>4、定义存储实例的属性</h4><p>定义好获取实例的方法 <code>getInstance</code> 后，如何实现方法？是否可以直接实现？如下示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>{  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p>答案是肯定不行。若多处地方调用，会导致产生多个实例。<strong>单例模式的做法是用一个属性来记录自己创建好的类实例，当第一次创建过后，就把这个实例保存下来，以后就可以复用这个实例，而不是重复创建对象实例</strong>。示例代码如下</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br></pre></td></tr></tbody></table></figure>

<h4 id="5、定义静态属性"><a href="#5、定义静态属性" class="headerlink" title="5、定义静态属性"></a>5、定义静态属性</h4><p>这个属性变量应该在什么地方用？肯定是第一次创建类实例的地方，也就是在前面那个返回对象实例的静态方法里面使用。</p>
<p><strong>由于要在一个静态方法里面使用，所以这个属性被迫成为一个类变量，要强制加上 <code>static</code>，也就是说，这里并没有使用 <code>static</code> 的特性。</strong>示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="6、控制实例的创建"><a href="#6、控制实例的创建" class="headerlink" title="6、控制实例的创建"></a>6、控制实例的创建</h4><p>控制实例的创建较为简单，查看存放实例的属性是否已经赋值，如有值，说明已经创建过，若没有值，应该创建。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {  </span><br><span class="line">      <span class="comment">//先判断instance是否有值  </span></span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>) {  </span><br><span class="line">          <span class="comment">//如果没有值，说明还没有创建过实例，那就创建一个  </span></span><br><span class="line">          <span class="comment">//并把这个实例设置给instance  </span></span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span> ();  </span><br><span class="line">      }  </span><br><span class="line">      <span class="comment">//如果有值，或者是创建了值，那就直接使用  </span></span><br><span class="line">      <span class="keyword">return</span> instance;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="7、完整实现"><a href="#7、完整实现" class="headerlink" title="7、完整实现"></a>7、完整实现</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {  </span><br><span class="line">      <span class="comment">//4：定义一个变量来存储创建好的类实例  </span></span><br><span class="line">      <span class="comment">//5：因为这个变量要在静态方法中使用，所以需要加上static修饰  </span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">      <span class="comment">//1：私有化构造方法，好在内部控制创建实例的数目  </span></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>{      </span><br><span class="line">      }  </span><br><span class="line">      <span class="comment">//2：定义一个方法来为客户端提供类实例  </span></span><br><span class="line">      <span class="comment">//3：这个方法需要定义成类方法，也就是要加static  </span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>{  </span><br><span class="line">          <span class="comment">//6：判断存储实例的变量是否有值  </span></span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="literal">null</span>){  </span><br><span class="line">              <span class="comment">//6.1：如果没有，就创建一个类实例，并把值赋值给存储类实例的变量  </span></span><br><span class="line">              instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">          }  </span><br><span class="line">          <span class="comment">//6.2：如果有值，那就直接使用  </span></span><br><span class="line">          <span class="keyword">return</span> instance;  </span><br><span class="line">      }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-2-饿汉式"><a href="#3-2-2-饿汉式" class="headerlink" title="3.2.2 饿汉式"></a>3.2.2 饿汉式</h3><p>与懒汉式的实现方式相比，私有化构造方法、提供静态的 <code>getInstance</code> 方法返回实例的方法都一样。区别在于如何实现 <code>getInstance</code> 方法。</p>
<p>在 <code>Java</code> 中 <code>static</code> 的特性为：<code>static</code> 变量在类装载的时候进行初始化；多个实例的 <code>static</code> 变量会共享同一块内存区域。</p>
<p>利用 <code>static</code> 的特性，单例模式的饿汉式的实现方式为:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {  </span><br><span class="line">    <span class="comment">//4：定义一个静态变量来存储创建好的类实例  </span></span><br><span class="line">    <span class="comment">//直接在这里创建类实例，只会创建一次  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="comment">//1：私有化构造方法，好在内部控制创建实例的数目  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>{          </span><br><span class="line">    }  </span><br><span class="line">    <span class="comment">//2：定义一个方法来为客户端提供类实例  </span></span><br><span class="line">    <span class="comment">//3：这个方法需要定义成类方法，也就是要加static  </span></span><br><span class="line">    <span class="comment">//这个方法里面就不需要控制代码了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>{  </span><br><span class="line">        <span class="comment">//5：直接使用已经创建好的实例  </span></span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>无论采用哪一种方式，在运行期间，都只会生成一个实例，而访问这些类的一个全局访问点，为静态的 <code>getInstance</code> 方法。</p>
</blockquote>
<h2 id="3-3-关于延迟加载"><a href="#3-3-关于延迟加载" class="headerlink" title="3.3 关于延迟加载"></a>3.3 关于延迟加载</h2><p>延迟加载：通俗来讲，就是一开始不要加载资源或者数据，直到到马上就要使用这个资源或者数据时才加载，也称 <code>Lazy Load</code>，这在实际开发中是一种很常见的思想，尽可能的节约资源。</p>
<p>延迟加载在单例模式中的体现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {  </span><br><span class="line">  		<span class="comment">//.....</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>{  </span><br><span class="line">          <span class="comment">// 此处体现了延迟加载，马上要使用此实例了，但是无法得知是否实例化，先判断下，若没有则创建一个</span></span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="literal">null</span>){  </span><br><span class="line">              instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">          }  </span><br><span class="line">          <span class="keyword">return</span> instance;  </span><br><span class="line">      }  </span><br><span class="line">  		<span class="comment">//.....</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-4-缓存思维"><a href="#3-4-缓存思维" class="headerlink" title="3.4 缓存思维"></a>3.4 缓存思维</h2><p>简单来讲，如果某些资源或者数据会被频繁地使用，而这些资源或数据存储在系统外部，比如数据库、硬盘文件等，那么每次操作这些数据的时候都从数据库或者硬盘上去获取，速度会较慢，容易造成性能问题。</p>
<p><strong>一个简单的解决方法</strong>：将热点数据缓存到内存里面，每次操作的时候，先到内存里面找，看有没有这些数据，如果有，则直接使用，如果没有那么就获取它，并设置到缓存中，下一次访问的时候就可以直接从内存中获取了。从而节省大量的时间，缓存是一种典型的空间换时间的方案。</p>
<p>缓存思维在单例模式中的体现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {  </span><br><span class="line">      <span class="comment">// 此属性就是用来缓存实例</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;    </span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>{      </span><br><span class="line">      }  </span><br><span class="line"> </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>{  </span><br><span class="line">          <span class="comment">// 缓存的实现</span></span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="literal">null</span>){  </span><br><span class="line">              instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">          }  </span><br><span class="line">          <span class="keyword">return</span> instance;  </span><br><span class="line">      }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="缓存实现简介"><a href="#缓存实现简介" class="headerlink" title="缓存实现简介"></a>缓存实现简介</h3><p>引申一下，在 java 中最常见的缓存实现方式是 <code>Map</code>，基本步骤为：</p>
<blockquote>
<ol>
<li>先到缓存里面查找，看看是否存在需要使用的数据；</li>
<li>如果没有找到，那么就创建一个满足要求的数据，然后把这个数据设置回到缓存中，以备下次使用；</li>
<li>如果找到了相应的数据，或者是创建了相应的数据，那就直接使用这个数据；</li>
</ol>
</blockquote>
<p>示例代码（基本实现，没有考虑缓存的清除、同步等功能）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java中缓存的基本实现示例</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaCache</span> {  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 缓存数据的容器，定义成Map是方便访问，直接根据Key就可以获取Value了</span></span><br><span class="line"><span class="comment">    * key选用String是为了简单，方便演示</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从缓存中获取值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 设置时候的key值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> key对应的Value值</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(String key)</span>{  </span><br><span class="line">       <span class="comment">//先从缓存里面取值  </span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> map.get(key);  </span><br><span class="line">       <span class="comment">//判断缓存里面是否有值  </span></span><br><span class="line">       <span class="keyword">if</span>(obj == <span class="literal">null</span>){  </span><br><span class="line">           <span class="comment">//如果没有，那么就去获取相应的数据，比如读取数据库或者文件  </span></span><br><span class="line">           <span class="comment">//这里只是演示，所以直接写个假的值  </span></span><br><span class="line">           obj = key+<span class="string">",value"</span>;  </span><br><span class="line">           <span class="comment">//把获取的值设置回到缓存里面  </span></span><br><span class="line">           map.put(key, obj);  </span><br><span class="line">       }  </span><br><span class="line">       <span class="comment">//如果有值了，就直接返回使用  </span></span><br><span class="line">       <span class="keyword">return</span> obj;  </span><br><span class="line">   }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-5-单例模式的优缺点"><a href="#3-5-单例模式的优缺点" class="headerlink" title="3.5 单例模式的优缺点"></a>3.5 单例模式的优缺点</h2><h3 id="3-5-1-时间和空间"><a href="#3-5-1-时间和空间" class="headerlink" title="3.5.1 时间和空间"></a>3.5.1 时间和空间</h3><p><strong>懒汉式是典型的时间换空间</strong>，每次获取实例都会进行判断，看是否需要创建实例，消耗判断的时间，如果一直没有人使用的话，那就不会创建实例，节约内存空间。</p>
<p><strong>饿汉式是典型的空间换时间</strong>，当类装载的时候就会创建类实例，无论是否调用，先创建出来，然后每次调用时，就不需要再判断，节省了运行时间。</p>
<h3 id="3-5-2-线程安全"><a href="#3-5-2-线程安全" class="headerlink" title="3.5.2 线程安全"></a>3.5.2 线程安全</h3><h4 id="1、不加同步的懒汉式是线程不安全的"><a href="#1、不加同步的懒汉式是线程不安全的" class="headerlink" title="1、不加同步的懒汉式是线程不安全的"></a>1、不加同步的懒汉式是线程不安全的</h4><p>假设：有两个线程 A 和 B，同时调用 <code>getInstance</code> 方法，可能导致并发问题。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>{  </span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>){  </span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<img src="/2023/01/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230129154439726.png" alt="image-20230129154439726" style="zoom:50%;">

<p>通过上图的分解描述，明显可以看出，当 A、B 线程并发的情况下，会创建出两个实例来，也就是单例的控制在并发情况下会失效。</p>
<p>如何实现懒汉式的线程安全？可以通过将方法加锁 <code>synchronized</code> 的方式</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>{} </span><br></pre></td></tr></tbody></table></figure>

<p><strong>但是，此种加锁的方式太重了，并发量大时，会导致性能问题。</strong></p>
<h5 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h5><p>所谓双重检查加锁机制，指的是：<strong>不需要每次进入 <code>getInstance</code> 方法都需要同步，而是先不同步，进入方法过后，先检查实例是否存在，如果不存在才进入下面的同步块，这是第一重检查。进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。</strong>如此只需要同步一次，从而减少了多次在同步情况下进行判断所浪费的时间。</p>
<p><strong>双重检查加锁机制的实现会使用关键字 <code>volatile</code></strong></p>
<blockquote>
<p>被 <code>volatile</code> 修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p>
<p>由于 <code>volatile</code> 关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高，因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用双重加锁机制来实现线程安全的单例，但并不建议大量采用。</p>
</blockquote>
<p>实例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {  </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 对保存实例的变量添加volatile的修饰</span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>{      </span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">getInstance</span><span class="params">()</span>{  </span><br><span class="line">          <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块  </span></span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="literal">null</span>){  </span><br><span class="line">              <span class="comment">//同步块，线程安全的创建实例  </span></span><br><span class="line">              <span class="keyword">synchronized</span>(Singleton.class){  </span><br><span class="line">                  <span class="comment">//再次检查实例是否存在，如果不存在才真的创建实例  </span></span><br><span class="line">                  <span class="keyword">if</span>(instance == <span class="literal">null</span>){  </span><br><span class="line">                      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">                  }  </span><br><span class="line">              }  </span><br><span class="line">          }  </span><br><span class="line">          <span class="keyword">return</span> instance;  </span><br><span class="line">      }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种实现方式既可使实现线程安全的创建实例，又不会对性能造成太大的影响，它<strong>只是在第一次创建实例的时候同步，以后就不需要同步了，从而加快运行速度</strong>。</p>
<h4 id="2、饿汉式是线程安全的"><a href="#2、饿汉式是线程安全的" class="headerlink" title="2、饿汉式是线程安全的"></a>2、<strong>饿汉式是线程安全的</strong></h4><p>因为虚拟机保证了只会装载一次，在装载类的时候是不会发生并发的。</p>
<h2 id="3-6-其它实现方式"><a href="#3-6-其它实现方式" class="headerlink" title="3.6 其它实现方式"></a>3.6 其它实现方式</h2><h3 id="3-6-1-静态内部类方式"><a href="#3-6-1-静态内部类方式" class="headerlink" title="3.6.1 静态内部类方式"></a>3.6.1 静态内部类方式</h3><p>懒汉式和饿汉式的两种实现方式都各有优缺点，而是用静态内部类可以达到既能实现延迟加载，又能实现线程安全。</p>
<h4 id="1、基础知识介绍"><a href="#1、基础知识介绍" class="headerlink" title="1、基础知识介绍"></a>1、基础知识介绍</h4><p>什么是类级内部类？简单点说，<strong>类级内部类指的是：有 <code>static</code> 修饰的成员式内部类。如果没有 <code>static</code> 修饰的成员式内部类被称为对象级内部类</strong>。</p>
<p><strong>类级内部类相当于其外部类的 <code>static</code> 成分</strong>，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。</p>
<p>类级内部类中，可以定义静态的方法，在静态方法中只能够引用外部类中的静态成员方法或者成员变量。<strong>类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被装载。</strong></p>
<p>多线程缺省同步锁：在多线程开发中，为了解决并发问题，主要是通过使用 <code>synchronized</code> 来加互斥锁进行同步控制。<strong>但是在某些情况中，<code>JVM</code> 已经隐含地为用户执行了同步，这些情况下就不用用户再来进行同步控制了。这些情况包括：</strong></p>
<blockquote>
<ol>
<li>由静态初始化器（<strong>在静态字段上或 <code>static{}</code> 块中的初始化器</strong>）初始化数据时；</li>
<li><strong>访问 <code>final</code> 字段时</strong>；</li>
<li>在创建线程之前创建对象时；</li>
<li>线程可以看见它将要处理的对象时；</li>
</ol>
</blockquote>
<h4 id="2、实现方式"><a href="#2、实现方式" class="headerlink" title="2、实现方式"></a>2、实现方式</h4><p>要想很简单的实现线程安全，<strong>可以采用静态初始化器的方式，它可以由 <code>JVM</code> 来保证线程安全</strong>。比如前面的 “饿汉式” 实现方式，但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。</p>
<p>如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是<strong>采用类级内部类，在这个类级内部类里面去创建对象实例</strong>，这样一来，<strong>只要不使用到这个类级内部类，那就不会创建对象实例</strong>。从而同时实现延迟加载和线程安全。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {  </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例</span></span><br><span class="line"><span class="comment">       * 没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载</span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {  </span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment">           */</span>  </span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">      }  </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 私有化构造方法</span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {  </span><br><span class="line">      }  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">getInstance</span><span class="params">()</span> {  </span><br><span class="line">          <span class="keyword">return</span> SingletonHolder.instance;  </span><br><span class="line">      }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当 <code>getInstance</code> 方法第一次被调用的时候，它第一次读取 <code>SingletonHolder.instance</code>，导致 <code>SingletonHolder</code> 类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建 Singleton 的实例，由于是静态的域，因此只会被虚拟机在装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。</p>
<p>这个实现方式的优势在于，<code>getInstance</code> 方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</p>
<h3 id="3-6-2-枚举方式"><a href="#3-6-2-枚举方式" class="headerlink" title="3.6.2 枚举方式"></a>3.6.2 枚举方式</h3><p><strong>单元素的枚举类型已经成为实现 <code>Singleton</code> 的最佳方法</strong> ——<code>Effective Java</code></p>
<blockquote>
<ol>
<li><strong><code>Java</code> 的枚举类型实质上是功能齐全的类</strong>，因此可以有自己的属性和方法；</li>
<li><code>Java</code> 枚举类型的基本思想：<strong>通过公有的静态 <code>final</code> 域为每个枚举常量导出实例的类</strong>；</li>
<li>从某个角度讲，<strong>枚举是单例的泛型化，本质上是单元素的枚举</strong>；</li>
</ol>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> SingletonEnum.java v 0.1 2023/1/29 19:40 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> {</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"this is singleton instance"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">SingletonEnum</span> <span class="variable">singleton</span> <span class="operator">=</span> SingletonEnum.INSTANCE;</span><br><span class="line">        singleton.operation();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用枚举来实现单实例控制，会更加简洁，而且<strong>无偿的提供了序列化的机制，并由 <code>JVM</code> 从根本上提供保障，绝对防止多次实例化</strong>，是更简洁、高效、安全的实现单例的方式。</p>
<p><strong>综上，可以得出结论：枚举是实现单例模式的最佳实践</strong>。毕竟使用它全都是优点：</p>
<ol>
<li>反射安全</li>
<li>序列化 / 反序列化安全</li>
<li><strong>写法简单</strong></li>
</ol>
<h2 id="3-7-思考单例模式"><a href="#3-7-思考单例模式" class="headerlink" title="3.7 思考单例模式"></a>3.7 思考单例模式</h2><h3 id="3-7-1-单例模式的本质"><a href="#3-7-1-单例模式的本质" class="headerlink" title="3.7.1 单例模式的本质"></a>3.7.1 单例模式的本质</h3><p><strong>单例模式的本质：控制实例数目</strong></p>
<p>单例模式是为了控制在运行期间，某些类的实例数目只能有一个。可能有人就会想了，那么我能不能控制实例数目为 <code>2</code> 个，<code>3</code> 个，或者是任意多个呢？目的都是 —— 节省资源，有些时候单个实例不能满足实际的需要（并发量），根据测算，<code>3</code> 个实例刚刚好，也就是说，现在要控制实例数目为 <code>3</code> 个，怎么办？</p>
<p>其实思路很简单，就是利用上面通过 <code>Map</code> 来缓存实现单例的示例，进行变形，一个 <code>Map</code> 可以缓存任意多个实例，<strong>新的问题就是，<code>Map</code> 中有多个实例，但是客户端调用的时候，到底返回那一个实例呢？</strong>，即实例的调度问题，本文不会对调度算法进行展开，示例代码利用简单的循环来展示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OneExtend.java v 0.1 2023/1/29 19:44 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneExtend</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个缺省的key值的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span>                 <span class="variable">DEFAULT_PREKEY</span> <span class="operator">=</span> <span class="string">"Cache"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存实例的容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>       Map&lt;String, OneExtend&gt; map            = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来记录当前正在使用第几个实例，到了控制的最大数目，就返回从1开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>       <span class="type">int</span>                    <span class="variable">num</span>            <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义控制实例的最大数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span>                    <span class="variable">NUM_MAX</span>        <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">OneExtend</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OneExtend <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> DEFAULT_PREKEY + num;</span><br><span class="line">        <span class="comment">//缓存的体现，通过控制缓存的数据多少来控制实例数目</span></span><br><span class="line">        <span class="type">OneExtend</span> <span class="variable">oneExtend</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (oneExtend == <span class="literal">null</span>) {</span><br><span class="line">            oneExtend = <span class="keyword">new</span> <span class="title class_">OneExtend</span>();</span><br><span class="line">            map.put(key, oneExtend);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//把当前实例的序号加1</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; NUM_MAX) {</span><br><span class="line">            <span class="comment">//如果实例的序号已经达到最大数目了，那就重复从1开始获取</span></span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> oneExtend;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//测试是否能满足功能要求</span></span><br><span class="line">        <span class="type">OneExtend</span> <span class="variable">t1</span> <span class="operator">=</span> getInstance ();</span><br><span class="line">        <span class="type">OneExtend</span> <span class="variable">t2</span> <span class="operator">=</span> getInstance ();</span><br><span class="line">        <span class="type">OneExtend</span> <span class="variable">t3</span> <span class="operator">=</span> getInstance ();</span><br><span class="line">        <span class="type">OneExtend</span> <span class="variable">t4</span> <span class="operator">=</span> getInstance ();</span><br><span class="line">        <span class="type">OneExtend</span> <span class="variable">t5</span> <span class="operator">=</span> getInstance ();</span><br><span class="line">        <span class="type">OneExtend</span> <span class="variable">t6</span> <span class="operator">=</span> getInstance ();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"t1=="</span>+t1);</span><br><span class="line">        System.out.println(<span class="string">"t2=="</span>+t2);</span><br><span class="line">        System.out.println(<span class="string">"t3=="</span>+t3);</span><br><span class="line">        System.out.println(<span class="string">"t4=="</span>+t4);</span><br><span class="line">        System.out.println(<span class="string">"t5=="</span>+t5);</span><br><span class="line">        System.out.println(<span class="string">"t6=="</span>+t6);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">t1==pattern.singleton.OneExtend@1d44bcfa</span><br><span class="line">t2==pattern.singleton.OneExtend@266474c2</span><br><span class="line">t3==pattern.singleton.OneExtend@6f94fa3e</span><br><span class="line">t4==pattern.singleton.OneExtend@1d44bcfa</span><br><span class="line">t5==pattern.singleton.OneExtend@266474c2</span><br><span class="line">t6==pattern.singleton.OneExtend@6f94fa3e</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-7-2-使用场景"><a href="#3-7-2-使用场景" class="headerlink" title="3.7.2 使用场景"></a>3.7.2 使用场景</h3><p><strong>当需要控制一个类的实例只能有一个，而且客户只能从一个全局访问点访问它时，可以选用单例模式，这些功能恰好是单例模式要解决的问题。</strong></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://cloud.tencent.com/developer/article/1497592">Java 单例模式的 7 种写法中，为何用 Enum 枚举实现被认为是最好的方式？</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>创建型模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2023/02/19/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实际场景"><a href="#1-实际场景" class="headerlink" title="1 实际场景"></a>1 实际场景</h1><h2 id="1-1-代码模板生成"><a href="#1-1-代码模板生成" class="headerlink" title="1.1 代码模板生成"></a>1.1 代码模板生成</h2><p>很多平台代码工具可以根据配置生成相应的模板代码，用户则只需要关注特定的业务功能实现，降低用户使用的复杂度以及提高效率。</p>
<p>假设生成的模板代码都具有基本的三层架构，即：<strong>表现层、逻辑层和数据层</strong>，所以代码生成工具应该具有相应代码生成的处理模块，另外代码工具还需要有相应的<strong>配置管理模块</strong>，定义配置模板，用来决定生成代码的逻辑。</p>
<p>如何实现该代码生成工具？</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h2 id="1-2-非设计模式的解决方案"><a href="#1-2-非设计模式的解决方案" class="headerlink" title="1.2 非设计模式的解决方案"></a>1.2 非设计模式的解决方案</h2><p>非常 <code>straightforward</code> 的实现方式，方便示例，其中每个模块的实现就简单示意。</p>
<p>1、 配置管理模块的配置对象定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConfigModel.java v 0.1 2023/2/19 21:52 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 示意配置描述的数据Model，实际场景的配置数据会很多</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigModel</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要生成表现层，默认是true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">needGenPresentation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要生成逻辑层，默认是true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">needGenBusiness</span>     <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要生成DAO，默认是true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">needGenDAO</span>          <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNeedGenPresentation</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> needGenPresentation;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNeedGenPresentation</span><span class="params">(<span class="type">boolean</span> needGenPresentation)</span> {</span><br><span class="line">        <span class="built_in">this</span>.needGenPresentation = needGenPresentation;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNeedGenBusiness</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> needGenBusiness;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNeedGenBusiness</span><span class="params">(<span class="type">boolean</span> needGenBusiness)</span> {</span><br><span class="line">        <span class="built_in">this</span>.needGenBusiness = needGenBusiness;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNeedGenDAO</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> needGenDAO;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNeedGenDAO</span><span class="params">(<span class="type">boolean</span> needGenDAO)</span> {</span><br><span class="line">        <span class="built_in">this</span>.needGenDAO = needGenDAO;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、配置管理定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConfigManager.java v 0.1 2023/2/19 21:54 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 示意配置管理，就是负责读取配置文件，</span></span><br><span class="line"><span class="comment"> * 并把配置文件的内容设置到配置Model中去，是个单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigManager</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ConfigManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ConfigModel</span>   <span class="variable">cm</span>      <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConfigManager <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (manager == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (ConfigManager.class) {</span><br><span class="line">                manager = <span class="keyword">new</span> <span class="title class_">ConfigManager</span>();</span><br><span class="line">                cm = <span class="keyword">new</span> <span class="title class_">ConfigModel</span>();</span><br><span class="line">                <span class="comment">// 读取配置文件，把值设置到ConfigModel中去，此处省略</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取配置的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 配置的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ConfigModel <span class="title function_">getConfigData</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cm;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、各个模块的生成代码，通过获取配置文件的内容，按照配置生成相应的代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Presentation.java v 0.1 2023/2/19 22:00 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 示意生成表现层的模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Presentation</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//1：从配置管理里面获取相应的配置信息</span></span><br><span class="line">        <span class="type">ConfigModel</span> <span class="variable">cm</span> <span class="operator">=</span> ConfigManager.getInstance().getConfigData();</span><br><span class="line">        <span class="keyword">if</span> (cm.isNeedGenPresentation()) {</span><br><span class="line">            <span class="comment">//2：按照要求去生成相应的代码，并保存成文件</span></span><br><span class="line">            System.out.println(<span class="string">"正在生成表现层代码文件"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Business.java v 0.1 2023/2/19 22:02 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 示意生成逻辑层的模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Business</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">ConfigModel</span> <span class="variable">cm</span> <span class="operator">=</span> ConfigManager.getInstance().getConfigData();</span><br><span class="line">        <span class="keyword">if</span> (cm.isNeedGenBusiness()) {</span><br><span class="line">            System.out.println(<span class="string">"正在生成逻辑层代码文件"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> DAO.java v 0.1 2023/2/19 22:03 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 示意生成数据层的模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">ConfigModel</span> <span class="variable">cm</span> <span class="operator">=</span> ConfigManager.getInstance().getConfigData();</span><br><span class="line">        <span class="keyword">if</span> (cm.isNeedGenDAO()) {</span><br><span class="line">            System.out.println(<span class="string">"正在生成数据层代码文件"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、客户端实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/19 22:04 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//现在没有配置文件，就直接使用默认的配置，通常情况下，三层都应该生成，</span></span><br><span class="line">        <span class="comment">//也就是说客户端必须对这些模块都有了解，才能够正确使用它们</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Presentation</span>().generate();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Business</span>().generate();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DAO</span>().generate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-有何问题"><a href="#1-3-有何问题" class="headerlink" title="1. 3 有何问题"></a>1. 3 有何问题</h2><p>如上述案例代码，<strong>客户端为了使用生成代码工具，需要与生成代码的内部多个模块交互</strong>。从用户的角度来说，代码生成工具的使用体验非常差，若工具内部某个模块发生变化，还需要引起客户端也随之变化。如何处理此问题？</p>
<h1 id="2-外观模式"><a href="#2-外观模式" class="headerlink" title="2 外观模式"></a>2 外观模式</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>外观模式（<code>Facade Pattern</code>）属于结构型模式。为子系统中的一组接口提供一致的界面，<code>Facade</code> 模式定义了一个高层接口，此接口可以使子系统更加容易使用。</p>
<blockquote>
<p>此处的的界面指的是从一个组件外部来看这个组件，对外提供的接口，就是这个组件的界面，即：外观。</p>
</blockquote>
<h2 id="2-2-外观模式解决问题思路"><a href="#2-2-外观模式解决问题思路" class="headerlink" title="2.2 外观模式解决问题思路"></a>2.2 外观模式解决问题思路</h2><p>上面案例中，用户需要更简单的操作，此时需要为客户端定义一个简单的接口，客户端调用这个接口就行。</p>
<blockquote>
<p>此处提到的接口，不是指的是 <code>interface</code>，在外观模式中，一般指的是外观类，在这个类中定义客户端需要的方法，然后在方法实现里面，有外观类去分别调用多个内部模块来实现功能。</p>
</blockquote>
<h2 id="2-3-结构说明"><a href="#2-3-结构说明" class="headerlink" title="2.3 结构说明"></a>2.3 结构说明</h2><img src="/2023/02/19/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230219234426815.png" alt="image-20230219234426815" style="zoom:50%;">

<img src="/2023/02/19/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230219234504594.png" alt="image-20230219234504594" style="zoom: 50%;">

<blockquote>
<ul>
<li>Facade：定义子系统的多个模块对外的高层接口。需要调用内部多个模块，从而把客户的请求代理给适当的子系统的系统对象；</li>
<li>模块：接受 <code>Facade</code> 对象的委派，实现具体的功能，各个模块之间可能有交互。其中 <code>Facade</code> 对象能感知各个模块，但是各个模块无法感知 <code>Facade</code> 对象的存在；</li>
</ul>
</blockquote>
<h2 id="2-4-示例代码"><a href="#2-4-示例代码" class="headerlink" title="2.4 示例代码"></a>2.4 示例代码</h2><p>1、内部多个模块的接口定义（<strong>可以是任意的功能方法</strong>）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> AModuleApi.java v 0.1 2023/2/20 20:53 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> A模块的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AModuleApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，A模块对外的一个功能方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> BModuleApi.java v 0.1 2023/2/20 20:53 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> B模块的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BModuleApi</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> CModuleApi.java v 0.1 2023/2/20 21:03 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CModuleApi</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testC</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、模块接口的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> AModuleImpl.java v 0.1 2023/2/20 22:52 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AModuleImpl</span> <span class="keyword">implements</span> <span class="title class_">AModuleApi</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"现在在A模块里面操作testA方法"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> BModuleImpl.java v 0.1 2023/2/20 22:52 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BModuleImpl</span> <span class="keyword">implements</span> <span class="title class_">BModuleApi</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"现在在B模块里面操作testB方法"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> CModuleImpl.java v 0.1 2023/2/20 22:53 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CModuleImpl</span> <span class="keyword">implements</span> <span class="title class_">CModuleApi</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testC</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"现在在C模块里面操作testC方法"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、定义外观对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Facade.java v 0.1 2023/2/20 22:54 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 外观对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，满足客户需要的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//在内部实现的时候，可能会调用到内部的多个模块</span></span><br><span class="line">        <span class="type">AModuleApi</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AModuleImpl</span>();</span><br><span class="line">        a.testA();</span><br><span class="line">        <span class="type">BModuleApi</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BModuleImpl</span>();</span><br><span class="line">        b.testB();</span><br><span class="line">        <span class="type">CModuleApi</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CModuleImpl</span>();</span><br><span class="line">        c.testC();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、客户端，直接使用外观对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/20 22:56 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//使用Facade</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Facade</span>().test();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-5-重写方案"><a href="#2-5-重写方案" class="headerlink" title="2.5 重写方案"></a>2.5 重写方案</h2><p>1、重写的方案中，子模块的 <code>Business</code>、<code>DAO</code>、<code>Presentation</code> 都是同上定义一致，需要添加一个 <code>Facade</code> 对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Facade.java v 0.1 2023/2/20 23:18 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 代码生成子系统的外观对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端需要的，一个简单的调用代码生成的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Presentation</span>().generate();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Business</span>().generate();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DAO</span>().generate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、客户端实现，不需要在与多个子系统内部模块交互，直接使用外观对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/19 22:04 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">////现在没有配置文件，就直接使用默认的配置，通常情况下，三层都应该生成，</span></span><br><span class="line">        <span class="comment">////也就是说客户端必须对这些模块都有了解，才能够正确使用它们</span></span><br><span class="line">        <span class="comment">//new Presentation().generate();</span></span><br><span class="line">        <span class="comment">//new Business().generate();</span></span><br><span class="line">        <span class="comment">//new DAO().generate();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Facade</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Facade</span>().generate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Facade</code> 类也被称为子模块模块对外的接口，有了 <code>Facade</code> 类，客户端就不需要知道系统内部的实现细节，甚至客户端都不需要知道内部模块的存在，客户端只需要同 <code>Facade</code> 类交互就行，从而更好的实现了客户端和子系统中的模块的解耦，让客户端更容易的使用系统。</p>
<h1 id="3-模式讲解"><a href="#3-模式讲解" class="headerlink" title="3 模式讲解"></a>3 模式讲解</h1><h2 id="3-1-认识外观模式"><a href="#3-1-认识外观模式" class="headerlink" title="3.1 认识外观模式"></a>3.1 认识外观模式</h2><h3 id="3-1-1-目的"><a href="#3-1-1-目的" class="headerlink" title="3.1.1 目的"></a>3.1.1 目的</h3><p>外观模式的目的是<strong>让外部减少与子系统内多个模块的交互，松耦合，从而让外部能更简单地使用子系统</strong>。</p>
<p>值得注意的是，虽然在代码层面可以在外观类中定义额外的与子系统无关的功能方法，但是不建议这么做。外观应该包装已有的功能，<strong>它主要负责组合已有功能来实现客户需要，而不是添加新的实现</strong>。</p>
<h3 id="3-1-2-外观模式提供缺省的功能实现"><a href="#3-1-2-外观模式提供缺省的功能实现" class="headerlink" title="3.1.2 外观模式提供缺省的功能实现"></a>3.1.2 外观模式提供缺省的功能实现</h3><p>随着业务的发展，一般系统会越做越大、越来越复杂，随着代码的要求也就更高。为了提高系统的可重用性，通常会把一个大的系统分成很多个子系统，再把一个子系统分成很多更小的子系统，一直分下去，分到一个一个小的模块，这样一来，子系统的重用性会得到加强，也更容易对子系统进行定制和使用。</p>
<p>但是随着带来一个问题，如果用户不需要对子系统进行定制，仅仅就是想要使用它们来完成一定的功能，那么使用起来会比较麻烦，需要跟这多个模块交互。<strong>外观对象就可以为用户提供一个简单的、缺省的实现，这个实现满足了大多数的用户的需求。但是外观并不限制那些需要更多定制功能的用户，直接越过外观去访问内部的模块的功能</strong>。</p>
<h2 id="3-2-实现方式"><a href="#3-2-实现方式" class="headerlink" title="3.2 实现方式"></a>3.2 实现方式</h2><h3 id="3-2-1-单例实现"><a href="#3-2-1-单例实现" class="headerlink" title="3.2.1 单例实现"></a>3.2.1 单例实现</h3><p>对于一个子系统而言，外观类不需要很多，<strong>通常可以实现成为一个单例</strong>。<strong>也可以直接把外观中的方法实现成为静态的方法，这样就可以不需要创建外观对象的实例而直接就可以调用</strong>，这种实现<strong>相当于把外观类当成一个辅助工具类实现</strong>。简要的示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> {</span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Facade</span><span class="params">()</span> {</span><br><span class="line">           </span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>{</span><br><span class="line">          <span class="type">AModuleApi</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AModuleImpl</span>();</span><br><span class="line">          a.testA();</span><br><span class="line">          <span class="type">BModuleApi</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BModuleImpl</span>();</span><br><span class="line">          b.testB();</span><br><span class="line">          <span class="type">CModuleApi</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CModuleImpl</span>();</span><br><span class="line">          c.testC();</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-2-接口实现"><a href="#3-2-2-接口实现" class="headerlink" title="3.2.2 接口实现"></a>3.2.2 接口实现</h3><p>虽然 <code>Facade</code> 通常直接实现成为类，但是也可以把 <code>Facade</code> 实现成为真正的 <code>interface</code>，只是这样会增加系统的复杂程度，因为这样会需要一个 <code>Facade</code> 的实现，还需要一个来获取 <code>Facade</code> 接口对象的工厂。</p>
<img src="/2023/02/19/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230223002858033.png" alt="image-20230223002858033" style="zoom:50%;">

<p>此时客户端需要先从工厂获取 <code>Facade</code> 的接口，才能调用对应功能。</p>
<h4 id="接口实现的好处"><a href="#接口实现的好处" class="headerlink" title="接口实现的好处"></a>接口实现的好处</h4><p>好处：<strong>就是能够有选择性的暴露接口方法，尽量减少模块对子系统外提供的接口方法</strong>。即：一个模块的接口里面定义的方法可以分成两部分，<strong>一部分是给子系统外部使用的，一部分是子系统内部的模块间相互调用时使用的</strong>。有了 <code>Facade</code> 接口，则用于子系统内部的接口功能就不用暴露给子系统外部。</p>
<p>示例：</p>
<p>定义如下的 A、B、C 模块的接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AModuleApi</span> {</span><br><span class="line">  		<span class="comment">//对子系统外部</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a1</span><span class="params">()</span>;</span><br><span class="line">  		<span class="comment">//子系统内部使用</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a2</span><span class="params">()</span>;</span><br><span class="line">  		<span class="comment">//子系统内部使用</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a3</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BModuleApi</span> {</span><br><span class="line">      <span class="comment">//对子系统外部</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b1</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">//子系统内部使用</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b2</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">//子系统内部使用</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b3</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CModuleApi</span> {</span><br><span class="line">      <span class="comment">//对子系统外部</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c1</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">//子系统内部使用</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c2</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">//子系统内部使用</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c3</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Facade</code> 接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FacadeApi</span> {</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a1</span><span class="params">()</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b1</span><span class="params">()</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c1</span><span class="params">()</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在示例中，外部只需要有 <code>Facade</code> 接口，就不再需要其它的接口，<strong>这样就能有效地屏蔽内部的细节，可以避免客户端去调用 A 模块的接口时，发现了一些不需要它知道的接口，这会造成 “接口污染”</strong>。</p>
<h3 id="3-2-3-Facade的方法实现"><a href="#3-2-3-Facade的方法实现" class="headerlink" title="3.2.3 Facade的方法实现"></a>3.2.3 Facade 的方法实现</h3><p><code>Facade</code> 的方法实现中，一般是负责把客户端的请求转发给子系统内部的各个模块进行处理，<code>Facade</code> 的方法本身并不进行功能的处理，<code>Facade</code> 的方法的实现只是实现一个功能的组合调用。</p>
<p>但是 <code>Facade</code> 并不禁止在其中实现其他逻辑，但是不符合 <code>Facade</code> 的设计模式本意。</p>
<h2 id="3-3-外观模式的优缺点"><a href="#3-3-外观模式的优缺点" class="headerlink" title="3.3 外观模式的优缺点"></a>3.3 外观模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>松散耦合</p>
<p><strong>外观模式松散了客户端与子系统的耦合关系</strong>，让子系统内部的模块能更容易扩展和维护。如果调用模块的算法发生了变化，比如变化成要先调用 <code>B</code>，然后调用 <code>A</code>，那么只需要修改 <code>Facade</code> 的实现就可以。</p>
</li>
<li><p>简单易用</p>
<p><strong>外观模式使子系统更加易用，客户端不需要了解子系统内部的实现</strong>，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以，相当于外观类为外部客户端使用子系统提供了一站式服务。</p>
<p>还有一个潜在的优点，对使用 <code>Facade</code> 的用户来说，<code>Facade</code> 大大节省了用户的学习成本，他们只需要了解 <code>Facade</code> 的用法即可，无需再深入到子系统内部，去了解每个模块的细节，也不用和这多个模块交互，从而使得开发简单，学习也容易。</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>增加系统复杂度</p>
<p><code>Facade</code> 过多的时候（可能有些不合理的设计），容易导致用户比较困惑，何时选择调用 <code>Facade</code>，何时选择调用内部模块。</p>
</li>
</ul>
<h2 id="3-4-思考"><a href="#3-4-思考" class="headerlink" title="3.4 思考"></a>3.4 思考</h2><h3 id="3-4-1-本质"><a href="#3-4-1-本质" class="headerlink" title="3.4.1 本质"></a>3.4.1 本质</h3><p><strong>封装交互，简化调用</strong></p>
<h3 id="3-4-2-设计原则"><a href="#3-4-2-设计原则" class="headerlink" title="3.4.2 设计原则"></a>3.4.2 设计原则</h3><p><strong>最少知识原则</strong></p>
<p>用户无需了解系统内部实现细节，只需要了解外观类就行。且通过外观模式可以在不影响用户的情况下，对系统内部模块进行维护和扩展。</p>
<h3 id="3-4-3-使用场景"><a href="#3-4-3-使用场景" class="headerlink" title="3.4.3 使用场景"></a>3.4.3 使用场景</h3><ul>
<li>若需要为一个复杂系统提供一个简单接口时；</li>
<li>若需要客户端程序与抽象类实现松散耦合，通过外观对象将子系统与客户端分离，同时也能提高系统子模块的独立性和可移植性；</li>
<li>构建多层结构系统时，通过外观对象作为每层的入口，可以简化系统层间调用，同时也松散了层次之间的依赖关系；</li>
</ul>
<h2 id="3-5-相关模式"><a href="#3-5-相关模式" class="headerlink" title="3.5 相关模式"></a>3.5 相关模式</h2><h3 id="3-5-1-外观模式和中介者模式"><a href="#3-5-1-外观模式和中介者模式" class="headerlink" title="3.5.1 外观模式和中介者模式"></a>3.5.1 外观模式和中介者模式</h3><blockquote>
<ul>
<li>外观模式封装的是单方面的请求，指的是从客户端对系统的调用；</li>
<li>中介者模式主要用来封装多个对象之间相互的交互，主要是在系统内部的多个模块之间的交互；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>外观模式一般是组合调用或者是对内部系统的子模块调用，在外观类中不实现这些功能；</li>
<li>中介者模式中需要实现具体具体的交互功能；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>外观模式的目的是简化客户端的调用，不需要了解内部实现细节；</li>
<li>中介者模式的目的是松散多个模块之间的耦合，具体的耦合关系在中介者中实现；</li>
</ul>
</blockquote>
<h3 id="3-5-2-外观模式和单例模式"><a href="#3-5-2-外观模式和单例模式" class="headerlink" title="3.5.2 外观模式和单例模式"></a>3.5.2 外观模式和单例模式</h3><p>在实际的生产场景中，外观模式与单例模式组合使用，将 <code>Facade</code> 类实现为单例，节省系统资源。</p>
<h3 id="3-5-3-外观模式和抽象工厂模式"><a href="#3-5-3-外观模式和抽象工厂模式" class="headerlink" title="3.5.3 外观模式和抽象工厂模式"></a>3.5.3 外观模式和抽象工厂模式</h3><p>外观模式需要与系统内部的多个模块交互，组合这些接口能力来完成客户需要的功能，其中每个模块都有自己定义的接口，这些接口的则可以使用抽象工厂来实现，将模块内部的实现对 <code>Facade</code> 进行屏蔽，即，<code>Facade</code> 只需要从模块中获取需要对应功能的接口，无需深入内部的实现细节。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>结构型模式</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2022/12/25/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实际场景"><a href="#1-实际场景" class="headerlink" title="1 实际场景"></a>1 实际场景</h1><h2 id="1-1-导出数据的应用框架"><a href="#1-1-导出数据的应用框架" class="headerlink" title="1.1 导出数据的应用框架"></a>1.1 导出数据的应用框架</h2><p>假设某个企业应用，需要每天定期额汇总各个分公司的业务数据，进行数据导入与核算。但是各个公司分布在不同的地方，且公司没有建设专用内网的条件。 需要各个公司将不同数据导出，然后由专门运输渠道将数据上交给总部。</p>
<p>则此应用需要：<strong>支持多种数据格式的导出（如：文本、数据库备份、Excel 格式、Xml 格式等等），并真正执行数据导出动作。</strong></p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h2 id="1-2-存在的问题"><a href="#1-2-存在的问题" class="headerlink" title="1.2 存在的问题"></a>1.2 存在的问题</h2><p>分析上面的需求，不管用户选择何种导出格式，最后导出的都是一个文件，而且系统本身不能感知最终要导出成何种文件，因此应该有一个统一的接口，描述系统最后生成的对象，并操作输出的文件。</p>
<p>到处文件对象的接口定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ExprotFileApi.java v1.0 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 导出的文件对象的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExportFileApi</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出的文件对象的接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 示意：需要保存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否导出成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">export</span><span class="params">(String data)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于实现导出数据的业务功能对象，它应该根据需要来创建相应的 <code>ExportFileApi</code> 的实现对象，因为特定的 <code>ExportFileApi</code> 的实现是与具体的业务相关的。但是对于实现导出数据的业务功能对象而言，它并不知道应该创建哪一个 <code>ExportFileApi</code> 的实现对象，也不知道如何创建。</p>
<p>即：对于实现导出数据的业务功能对象，需要创建 <code>ExportFileApi</code> 的具体实例对象，但是它只能感知该接口，而不知道起具体的实现。</p>
<h1 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h1><h2 id="2-1-工厂方法模式"><a href="#2-1-工厂方法模式" class="headerlink" title="2.1 工厂方法模式"></a>2.1 工厂方法模式</h2><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>
<h3 id="2-1-2-工厂方法模式解决问题思路"><a href="#2-1-2-工厂方法模式解决问题思路" class="headerlink" title="2.1.2 工厂方法模式解决问题思路"></a>2.1.2 工厂方法模式解决问题思路</h3><p>通过分析上面的问题，<strong>事实上在实现导出数据的业务功能对象里面，根本就不知道究竟要使用哪一种导出文件的格式，因此这个对象本就不应该和具体的导出文件的对象耦合在一起，它只需要面向导出的文件对象的接口就好了</strong>。</p>
<p>但是这样一来，又有新的问题产生了：<strong>接口是不能直接使用的，需要使用具体的接口实现对象的实例</strong>。</p>
<p>这不是自相矛盾吗？要求面向接口，不让和具体的实现耦合，但是又需要创建接口的具体实现对象的实例。怎么解决这个矛盾呢？</p>
<p>工厂方法模式的解决思路很有意思，那就是不解决，<strong>采取无为而治的方式：不是需要接口对象吗，那就定义一个方法来创建；可是事实上它自己是不知道如何创建这个接口对象的，没有关系，那就定义成抽象方法就好了，自己实现不了，那就让子类来实现，这样这个对象本身就可以只是面向接口编程，而无需关心到底如何创建接口对象了</strong>。</p>
<h2 id="2-2-结构说明"><a href="#2-2-结构说明" class="headerlink" title="2.2 结构说明"></a>2.2 结构说明</h2><p>结构图</p>
<img src="/2022/12/25/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20221225210314824.png" alt="image-20221225210314824" style="zoom:67%;">

<blockquote>
<ul>
<li>Product：定义工厂方法所创建的对象的接口，即实际需要使用的对象接口；</li>
<li>ConcreteProduct：继承与 Product 接口的具体实现对象；</li>
<li>Creator：创建器，声明工厂方法，工厂方法通常会返回一个 Product 类型的实例对象，而且多是抽象方法。也可以在 Creator 里面提供工厂发的默认实现，让工厂方法返回一个缺省的实例对象；</li>
<li>ConcreteCreator：具体的创建器对象，覆盖实现的 Creator 定义的工厂方法，返回具体的 Product 实例对象；</li>
</ul>
</blockquote>
<h2 id="2-3-代码示例"><a href="#2-3-代码示例" class="headerlink" title="2.3 代码示例"></a>2.3 代码示例</h2><p>Product.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Product.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 工厂方法所创建的对象的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="comment">// 可以定义Product的属性和方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ConcreteProduct.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ConcreteProduct.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 具体的Product对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="comment">// 实现Product要求的方法</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>Creator.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Creator.java v1.0 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 创建器，声明工厂方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Creator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，实现某些功能的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someOperation</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Product的工厂方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Product对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ConcreteCreator.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ConcreteCreator.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 具体的创建器实现对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCreator</span> <span class="keyword">extends</span> <span class="title class_">Creator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 重定义工厂方法，返回一个具体的Product对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-4-重写方案"><a href="#2-4-重写方案" class="headerlink" title="2.4 重写方案"></a>2.4 重写方案</h2><p>要使用工厂方法模式来实现示例，先来按照工厂方法模式的结构，对应出哪些是被创建的 <code>Product</code>，哪些是 <code>Creator</code><strong>。分析要求实现的功能，</strong>导出的文件对象接口 <code>ExportFileApi</code> 就相当于是 <code>Product</code>，而用来实现导出数据的业务功能对象就相当于 <code>Creator</code>。</p>
<p>代码结构图：</p>
<img src="/2022/12/25/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20221225214636906.png" alt="image-20221225214636906" style="zoom:67%;">

<ol>
<li><p>导出文件的对象接口 <code>ExportFileApi</code> 实现同上</p>
</li>
<li><p><strong>接口 <code>ExportFileApi</code> 的实现，为了示例简单，只实现导出文本文件格式和数据库备份文件两种</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ExportTxtFile.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 导出成文文件格式的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportTxtFile</span> <span class="keyword">implements</span> <span class="title class_">ExportFileApi</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">export</span><span class="params">(String data)</span> {</span><br><span class="line">        <span class="comment">// 示意代码，操作文件</span></span><br><span class="line">        System.out.println(<span class="string">"导出数据"</span> + data + <span class="string">"到文本文件"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ExportDB.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 导出成数据库备份文件形式的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportDB</span> <span class="keyword">implements</span> <span class="title class_">ExportFileApi</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">export</span><span class="params">(String data)</span> {</span><br><span class="line">        <span class="comment">// 示意代码，操作数据库和文件</span></span><br><span class="line">        System.out.println(<span class="string">"导出数据"</span> + data + <span class="string">"到数据库备份文件"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>工厂模版 <code>ExportOperate</code> 的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ExportOperate.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 实现导出数据的业务功能对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ExportOperate</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 需要保存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功导出文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">export</span><span class="params">(String data)</span> {</span><br><span class="line">        <span class="comment">// 使用工厂方法</span></span><br><span class="line">        <span class="type">ExportFileApi</span> <span class="variable">api</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">        <span class="keyword">return</span> api.export(data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，创建导出的文件对象的接口对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 导出的文件对象的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> ExportFileApi <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>Creator 的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ExportTxtFileOperate.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 具体的创建器实现对象，实现创建导出成文本文件格式的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportTxtFileOperate</span> <span class="keyword">extends</span> <span class="title class_">ExportOperate</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ExportFileApi <span class="title function_">factoryMethod</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//创建导出成文本文件格式的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExportTxtFile</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ExportDBOperate.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 具体的创建器实现对象，实现创建导出成数据库备份文件形式的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportDBOperate</span> <span class="keyword">extends</span> <span class="title class_">ExportOperate</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ExportFileApi <span class="title function_">factoryMethod</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//创建导出成数据库备份文件形式的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExportFileApi</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>客户端使用 Creator 对象，使用相应功能的示例</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Client.java v1.0  Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//创建需要使用的Creator对象</span></span><br><span class="line">        <span class="type">ExportOperate</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportDBOperate</span>();</span><br><span class="line">        <span class="comment">// 调用输出数据的方法</span></span><br><span class="line">        operate.export(<span class="string">"测试数据"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="3-模式讲解"><a href="#3-模式讲解" class="headerlink" title="3 模式讲解"></a>3 模式讲解</h1><h2 id="3-1-认识工厂方法模式"><a href="#3-1-认识工厂方法模式" class="headerlink" title="3.1 认识工厂方法模式"></a>3.1 认识工厂方法模式</h2><h3 id="3-1-1-功能"><a href="#3-1-1-功能" class="headerlink" title="3.1.1 功能"></a>3.1.1 功能</h3><p><strong>工厂方法的主要功能是让父类在不知道具体实现的情况下，完成自身的功能调用，而具体的实现延迟到子类来实现。</strong></p>
<p>这样在设计的时候，<strong>不用去考虑具体的实现，需要某个对象，把它通过工厂方法返回就好了，在使用这些对象实现功能的时候还是通过接口来操作</strong>，这非常类似于 IoC/DI 的思想（后面介绍）。</p>
<h3 id="3-1-2-实现成抽象类"><a href="#3-1-2-实现成抽象类" class="headerlink" title="3.1.2 实现成抽象类"></a>3.1.2 实现成抽象类</h3><p><strong>工厂方法的实现中，通常父类会是一个抽象类，里面包含创建所需对象的抽象方法，这些抽象方法就是工厂方法。</strong></p>
<p>注意：<strong>子类在实现这些抽象方法的时候，通常并不是真的由子类来实现具体的功能，而是在子类的方法里面做选择，选择具体的产品实现对象</strong>。</p>
<p>父类里面，<strong>通常会有使用这些产品对象来实现一定的功能的方法</strong>，而且这些方法所实现的功能通常都是公共的功能，不管子类选择了何种具体的产品实现，这些方法的功能总是能正确执行。</p>
<h3 id="3-1-3-实现成具体的类"><a href="#3-1-3-实现成具体的类" class="headerlink" title="3.1.3 实现成具体的类"></a>3.1.3 实现成具体的类</h3><p>父类也可以实现成为一个具体的类，这种情况下，<strong>通常是在父类中提供获取所需对象的默认实现方法，这样就算没有具体的子类，也能够运行</strong>。</p>
<p>通常这种情况还是需要具体的子类来决定具体要如何创建父类所需要的对象。也把这种情况称为工厂方法为子类提供了挂钩，通过工厂方法，可以让子类对象来覆盖父类的实现，从而提供更好的灵活性。</p>
<h3 id="3-1-4-工厂方法的参数和返回"><a href="#3-1-4-工厂方法的参数和返回" class="headerlink" title="3.1.4 工厂方法的参数和返回"></a>3.1.4 工厂方法的参数和返回</h3><p>工厂方法的实现中，可能需要参数，以便决定到底选用哪一种具体的实现。也就是说<strong>通过在抽象方法里面传递参数，在子类实现的时候根据参数进行选择，看看究竟应该创建哪一个具体的实现对象</strong>。</p>
<p>一般工厂方法返回的是被创建对象的接口对象，当然也可以是抽象类或者一个具体的类的实例。</p>
<h3 id="3-1-5-谁使用工厂方法创建的对象"><a href="#3-1-5-谁使用工厂方法创建的对象" class="headerlink" title="3.1.5 谁使用工厂方法创建的对象"></a>3.1.5 谁使用工厂方法创建的对象</h3><p>事实上，在工厂方法模式里面，应该是 <code>Creator</code> 中的其它方法在使用工厂方法创建的对象，虽然也可以把工厂方法创建的对象直接提供给 <code>Creator</code> 外部使用，<strong>但工厂方法模式的本意，是由 <code>Creator</code> 对象内部的方法来使用工厂方法创建的对象，也就是说，工厂方法一般不提供给 <code>Creator</code> 外部使用</strong>。</p>
<p><strong>客户端应该是使用 <code>Creator</code> 对象，或者是使用由 <code>Creator</code> 创建出来的对象。</strong></p>
<ul>
<li>对于客户端使用 <code>Creator</code> 对象，这个时候工厂方法创建的对象，是 <code>Creator</code> 中的某些方法使用。</li>
<li>对于使用由 <code>Creator</code> 创建出来的对象，这个时候工厂方法创建的对象，是构成客户端需要的对象的一部分。</li>
</ul>
<p>分别举例来说明。</p>
<ol>
<li><p><strong>客户端使用 <code>Creator</code> 对象</strong></p>
<p>比如前面的示例，对于 “实现导出数据的业务功能对象” 的类 <code>ExportOperate</code>，在 <code>export</code> 方法里面，需要使用具体的 “导出的文件对象的接口对象” <code>ExportFileApi</code>，而 <code>ExportOperate</code> 是不知道具体的 <code>ExportFileApi</code> 实现的，那么怎么做的呢？<strong>就是定义了一个工厂方法，用来返回 <code>ExportFileAp</code>i 的对象，然后 <code>export</code> 方法会使用这个工厂方法来获取它所需要的对象，然后执行功能</strong>。</p>
<p>这个时候客户端主要就是使用这个 <code>ExportOperate</code> 的实例来完成它想要完成的功能，也就是客户端使用 <code>Creator</code> 对象的情况，简单描述这种情况下的代码结构如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Creator.java v1.0 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 创建器，声明工厂方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Creator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，实现某些功能的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someOperation</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Product的工厂方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Product对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>客户端使用由 <code>Creator</code> 创建出来的对象</strong></p>
<p><strong>由 <code>Creator</code> 向客户端返回由 “工厂方法创建的对象” 来构建的对象，这个时候工厂方法创建的对象，是构成客户端需要的对象的一部分</strong>。简单描述这种情况下的代码结构如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 客户端使用Creator来创建客户端需要的对象的情况下，Creator的基本实现结构</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Creator</span> {</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 工厂方法，一般不对外，创建一个部件对象</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 创建的产品对象，一般是另一个产品对象的部件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">abstract</span> Product1 <span class="title function_">factoryMethod1</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 工厂方法，一般不对外，创建一个部件对象</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 创建的产品对象，一般是另一个产品对象的部件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">abstract</span> Product2 <span class="title function_">factoryMethod2</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 创建客户端需要的对象，客户端主要使用产品对象来完成所需要的功能</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 客户端需要的对象</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span>{</span><br><span class="line">          <span class="comment">//在这里使用工厂方法，得到客户端所需对象的部件对象</span></span><br><span class="line">          <span class="type">Product1</span> <span class="variable">p1</span> <span class="operator">=</span> factoryMethod1();</span><br><span class="line">          <span class="type">Product2</span> <span class="variable">p2</span> <span class="operator">=</span> factoryMethod2();</span><br><span class="line">          <span class="comment">//工厂方法创建的对象是创建客户端对象所需要的</span></span><br><span class="line">          <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">          p.setProduct1(p1);</span><br><span class="line">          p.setProduct2(p2);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>小结：<strong>在工厂方法模式里面，客户端要么使用 <code>Creator</code> 对象，要么使用 <code>Creator</code> 创建的对象，一般客户端不直接使用工厂方法。当然也可以直接把工厂方法暴露给客户端操作，但是一般不这么做。</strong></p>
<h2 id="3-2-工厂方法模式与IoC-x2F-DI"><a href="#3-2-工厂方法模式与IoC-x2F-DI" class="headerlink" title="3.2 工厂方法模式与IoC/DI"></a>3.2 工厂方法模式与 IoC/DI</h2><blockquote>
<p>IoC——Inversion of Control 控制反转</p>
<p>DI——Dependency Injection 依赖注入</p>
</blockquote>
<h3 id="3-2-1-理解IoC-x2F-DI"><a href="#3-2-1-理解IoC-x2F-DI" class="headerlink" title="3.2.1 理解IoC/DI"></a>3.2.1 理解 IoC/DI</h3><p>几个问题：</p>
<blockquote>
<ol>
<li>参与者都有谁？</li>
<li>依赖：谁依赖于谁？为什么需要依赖？</li>
<li>注入：谁注入谁？注入什么？</li>
<li>控制反转：谁控制谁？控制什么？为什么是反转？</li>
<li>依赖注入和控制反转的区别？</li>
</ol>
</blockquote>
<p>回答：</p>
<ol>
<li><p>参与者</p>
<p><strong>一般有三方参与者，一个是某个对象；一个是 IoC/DI 的容器；另一个是某个对象的外部资源</strong></p>
<blockquote>
<ul>
<li>某个对象指的就是任意的、普通的 Java 对象；</li>
<li>IoC/DI 的容器简单点说就是指用来实现 IoC/DI 功能的一个框架程序；</li>
<li>对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。</li>
</ul>
</blockquote>
</li>
<li><p>谁依赖谁</p>
<p>某个对象依赖于 IoC/DI 的容器</p>
</li>
<li><p>为什么需要依赖</p>
<p>对象需要 IoC/DI 的容器来提供对象需要的外部资源</p>
</li>
<li><p>谁注入谁</p>
<p>IoC/DI 容器注入对象</p>
</li>
<li><p>注入什么</p>
<p>IoC/DI 容器注入对象需要的外部资源</p>
</li>
<li><p>谁控制谁</p>
<p>IoC/DI 容器控制对象</p>
</li>
<li><p>控制什么</p>
<p>控制对象实例的创建</p>
</li>
<li><p>反转是什么</p>
<p>假设在应用程序中，如果需要在 A 里面使用 C，一般是直接去创建 C 的对象实例，然后在 A 类中主动去获取所需要的外部资源 C，这种称为正向。反向则是在 A 类中不再主动去获取 C，而是被动等待，等待 IoC/DI 容器获取一个 C 的实例，然后反向注入到 A 中。</p>
<p>正向：</p>
<p><img src="/2022/12/25/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20230101232319654.png" alt="image-20230101232319654"></p>
<p>反向：</p>
<p><img src="/2022/12/25/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20230101232426759.png" alt="image-20230101232426759"></p>
</li>
<li><p>依赖注入与控制反转</p>
<p>是对同一件事情的不同描述。</p>
<p>依赖注入从应用程序的角度描述，应用程序依赖容器创建并注入它所需要的外部资源</p>
<p>控制反转从容器的角度描述，容器控制应用程序，有容器反向的向应用程序注入应用程序所需要的外部资源</p>
</li>
</ol>
<h3 id="3-2-2-对比工厂模式与IoC-x2F-DI"><a href="#3-2-2-对比工厂模式与IoC-x2F-DI" class="headerlink" title="3.2.2 对比工厂模式与IoC/DI"></a>3.2.2 对比工厂模式与 IoC/DI</h3><p>IoC/DI 代码示例：</p>
<p>资源 C：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">C</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用者 A：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被注入的资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">C</span> <span class="variable">faze</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入资源C的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> faze 被注入的资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFaze</span><span class="params">(C faze)</span> {</span><br><span class="line">        <span class="built_in">this</span>.faze = faze;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 外部注入需要使用的资源，不需要主动创建</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        faze.func();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的示例代码可以看出，现在在 A 里面写代码的时候，凡是碰到了需要外部资源，那么就提供注入的途径，要求从外部注入，自己只管使用这些对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A1</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，创建资源，从子类注入进来的途径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 资源的对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> C <span class="title function_">createC</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要使用资源C，但是不主动创建，等待注入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        createC().func();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>子类的示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A2</span> <span class="keyword">extends</span> <span class="title class_">A1</span> {</span><br><span class="line">    <span class="keyword">protected</span> C1 <span class="title function_">createC1</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//真正的选择具体实现，并创建对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">C2</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：<strong>从思想层面上，会发现工厂方法模式和 IoC/DI 的思想是相似的，都是 “主动变被动”，进行了 “主从换位”，从而获得了更灵活的程序结构</strong>。</p>
<h2 id="3-3-工厂方法模式的优缺点"><a href="#3-3-工厂方法模式的优缺点" class="headerlink" title="3.3 工厂方法模式的优缺点"></a>3.3 工厂方法模式的优缺点</h2><p><strong>1 可以在不知具体实现的情况下编程</strong></p>
<p>工厂方法模式可以在实现功能的时候，如果需要某个产品对象，只需要使用产品的接口即可，而无需关心具体的实现。<strong>选择具体实现的任务延迟到子类去完成。</strong></p>
<p><strong>更容易扩展对象的新版本。</strong>工厂方法给子类提供了一个挂钩，使得扩展新的对象版本变得非常容易。</p>
<p><strong>2 具体产品对象和工厂方法的耦合性</strong></p>
<p>在工厂方法模式里面，工厂方法是需要创建产品对象的，也就是需要选择具体的产品对象，并创建它们的实例，因此具体产品对象和工厂方法是耦合的。</p>
<h2 id="3-4-思考工厂方法模式"><a href="#3-4-思考工厂方法模式" class="headerlink" title="3.4 思考工厂方法模式"></a>3.4 思考工厂方法模式</h2><h3 id="3-4-1-工厂方法模式的本质"><a href="#3-4-1-工厂方法模式的本质" class="headerlink" title="3.4.1 工厂方法模式的本质"></a>3.4.1 工厂方法模式的本质</h3><p>本质：<strong>延迟到子类来选择实现</strong></p>
<p>工厂方法模式中的工厂方法，在真正实现的时候，一般是先选择具体使用哪一个具体的产品实现对象，然后创建这个具体产品对象的示例，然后返回。也就是说，<strong>工厂方法本身并不会去实现产品接口，具体的产品实现是已经写好了，工厂方法只要去选择实现。</strong></p>
<p><strong>从本质上讲，工厂方法模式和简单工厂模式非常类似，具体实现上都是在 “选择实现”。</strong>但是也存在不同点，简单工厂是直接在工厂类里面进行 “选择实现”；<strong>而工厂方法会把这个工作延迟到子类来实现</strong>，工厂类里面使用工厂方法的地方是依赖于抽象而不是具体的实现，从而使得系统更加灵活，具有更好的可维护性和可扩展性。</p>
<p>如下，工厂方法模式 <code>Creator</code> 退化，只提供工厂方法，且提供默认的实现，这就是简单工厂。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportOperate</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 需要保存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功导出文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">export</span><span class="params">(String data)</span> {</span><br><span class="line">        <span class="comment">// 使用工厂方法</span></span><br><span class="line">        <span class="type">ExportFileApi</span> <span class="variable">api</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">        <span class="keyword">return</span> api.export(data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，创建导出的文件对象的接口对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 导出的文件对象的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ExportFileApi <span class="title function_">factoryMethod</span><span class="params">(<span class="type">int</span> type)</span> {</span><br><span class="line">    		<span class="type">ExportFileApi</span> <span class="variable">api</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      	<span class="comment">// 根据类型选择究竟要创建哪种到处文件对象</span></span><br><span class="line">      	<span class="keyword">if</span> (type == <span class="number">1</span>) {</span><br><span class="line">        		api = <span class="keyword">new</span> <span class="title class_">ExportTxtFile</span>();  </span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) {</span><br><span class="line">        		api = <span class="keyword">new</span> <span class="title class_">ExportDB</span>();</span><br><span class="line">        }</span><br><span class="line">      	<span class="keyword">return</span> api;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-2-对设计原则的体现"><a href="#3-4-2-对设计原则的体现" class="headerlink" title="3.4.2 对设计原则的体现"></a>3.4.2 对设计原则的体现</h3><p>依赖倒置原则告诉我们 “要依赖抽象，不要依赖于具体类”，简单点说就是：<strong>不能让高层组件依赖于低层组件，而且不管高层组件还是低层组件，都应该依赖于抽象</strong>。</p>
<p>如前面的示例，实现客户端请求操作的 <code>ExportOperate</code> 就是高层组件；而具体实现数据导出的对象就是低层组件，比如 <code>ExportTxtFile、ExportDB</code>；而 <code>ExportFileApi</code> 接口就相当于是那个抽象。</p>
<p>对于 ExportOperate 来说，它不关心具体的实现方式，它只是 “面向接口编程”；对于具体的实现来说，只关心自己 “如何实现接口” 所要求的功能。</p>
<p><strong>那么倒置的是什么呢？倒置的是这个接口的 “所有权”</strong>。事实上，<code>ExportFileApi</code> 接口中定义的功能，都是由高层组件 <code>ExportOperate</code> 来提出的要求，也就是说接口中的功能，是高层组件需要的功能。但是高层组件只是提出要求，并不关心如何实现，而低层组件，就是来真正实现高层组件所要求的接口功能的。因此看起来，<strong>低层实现的接口的所有权并不在底层组件手中，而是倒置到高层组件去了</strong>。</p>
<h3 id="3-4-3-何时选用工厂方法模式"><a href="#3-4-3-何时选用工厂方法模式" class="headerlink" title="3.4.3 何时选用工厂方法模式"></a>3.4.3 何时选用工厂方法模式</h3><ul>
<li><strong>如果一个类需要创建某个接口的对象，但是又不知道具体的实现</strong>，这种情况可以选用工厂方法模式，把创建对象的工作延迟到子类去实现。</li>
<li><strong>如果一个类本身就希望由它的子类来创建所需的对象的时候</strong>，应该使用工厂方法模式。</li>
</ul>
<h2 id="3-5-相关模式"><a href="#3-5-相关模式" class="headerlink" title="3.5 相关模式"></a>3.5 相关模式</h2><h3 id="3-5-1-工厂方法模式和抽象工厂模式"><a href="#3-5-1-工厂方法模式和抽象工厂模式" class="headerlink" title="3.5.1 工厂方法模式和抽象工厂模式"></a>3.5.1 工厂方法模式和抽象工厂模式</h3><p>组合使用 - 抽象工厂模式</p>
<h3 id="3-5-2-工厂方法模式和模版方法模式"><a href="#3-5-2-工厂方法模式和模版方法模式" class="headerlink" title="3.5.2 工厂方法模式和模版方法模式"></a>3.5.2 工厂方法模式和模版方法模式</h3><p>这两个模式外观类似，都是有一个抽象类，然后由子类来提供一些实现，<strong>但是工厂方法模式的子类专注的是创建产品对象，而模板方法模式的子类专注的是为固定的算法骨架提供某些步骤的实现</strong>。</p>
<p>这两个模式可以组合使用，通常在模板方法模式里面，使用工厂方法来创建模板方法需要的对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>创建型模式</tag>
        <tag>简单工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>The Google File System 翻译 &amp; 理解</title>
    <url>/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>The Google File System (GFS 或 GoogleFS) 一种专有分布式文件系统，由 Google 公司开发，运行于 Linux 平台上。<br>这篇论文发表在 2003 年，虽然时过多年，但是非常经典，在分布式存储领域具有非常重大的影响力。本篇文章对此篇论文进行一个翻译阅读和理解。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>GFS 是一个可扩展的分布式文件系统，用于大型分布式数据密集型应用程序。它可以在廉价的通用硬件上运行时提供容错功能，并且可以为大量客户端提供高性能的服务。</p>
<blockquote>
<p>我们设计并实现了 Google GFS 文件系统，一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS 虽然运行在廉价的普遍硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。</p>
<p>虽然 GFS 的设计目标与许多传统的分布式文件系统有很多相同之处，但是，我们的设计还是以我们对自己的应用的负载情况和技术环境的分析为基础的，不管现在还是将来，GFS 和早期的分布式文件系统的设想都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。</p>
<p>GFS 完全满足了我们对存储的需求。GFS 作为存储平台已经被广泛的部署在 Google 内部，存储我们的服务产生和处理的数据，同时还用于那些需要大规模数据集的研究和开发工作。目前为止，最大的一个集群利用数千台机器的数千个硬盘，提供了数百 TB 的存储空间，同时为数百个客户机服务。</p>
<p>在本文中，我们展示能够支持分布式应用的文件系统接口的扩展设计，讨论了我们设计的许多方面，最后列出了小规模性能测试以及真实生产系统中性能相关数据。</p>
</blockquote>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>GFS 的设计目标：性能，可伸缩性，可靠性和可用性。</p>
<p>GFS 和传统的分布式文件系统在设计上不同的点：</p>
<ul>
<li>组件故障是正常现象，而不是例外情况；</li>
<li>需要处理的文件通常是大文件，而不是小文件；</li>
<li>大多数文件（<strong>主要是指字节数量占比高，而不是操作次数</strong>）是通过附加新数据而不是覆盖现有数据来进行改变的 appending-only not overwriting</li>
<li> 共同设计应用程序和文件系统的 API 使得整个系统的灵活性更好</li>
</ul>
<blockquote>
<p>为了满足 Google 迅速增长的数据处理需求，我们设计并实现了 Google 文件系统 (Google File System–GFS)。GFS 与传统的分布式文件系统有着很多相同的设计目标，比如，性能、可伸缩性、可靠性以及可用性。但是，我们的设计还基于我们对我们自己的应用的负载情况和技术环境的观察的影响，不管现在还是将来，GFS 和早期文件系统的假设都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。</p>
<p>首先，<strong>分布式组件失效被认为是常态事件，而不是意外事件。</strong>GFS 包括几百甚至几千台普通的廉价设备组装的存储机器，同时被相当数量的客户机访问。GFS 组件的数量和质量导致在事实上，任何给定时间内都有可能发生某些组件无法工作，某些组件无法从它们目前的失效状态中恢复。我们遇到过各种各样的问题，比如应用程序 bug、操作系统的 bug、人为失误，甚至还有硬盘、内存、连接器、网络以及电源失效等造成的问题。所以，持续的监控、错误侦测、灾难冗余以及自动恢复的机制必须集成在 GFS 中。</p>
<p>其次，<strong>以通常的标准衡量，我们的文件非常巨大。数 GB 的文件非常普遍。</strong>每个文件通常都包含许多应用程序对象，比如 web 文档。当我们经常需要处理快速增长的、并且由数亿个对象构成的、数以 TB 的数据集时，采用管理数亿个 KB 大小的小文件的方式是非常不明智的，尽管有些文件系统支持这样的管理方式。因此，设计的假设条件和参数，比如 I/O 操作和 Block 的尺寸都需要重新考虑。</p>
<p>第三，<strong>绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。</strong>对文件的随机写入操作在实际中几乎不存在。一旦写完之后，对文件的操作就只有读，而且通常是按顺序读。大量的数据符合这些特性，比如：数据分析程序扫描的超大的数据集；正在运行的应用程序生成的连续的数据流；存档的数据；由一台机器生成、另外一台机器处理的中间数据，这些中间数据的处理可能是同时进行的、也可能是后续才处理的。对于这种针对海量文件的访问模式，客户端对数据块缓存是没有意义的，数据的追加操作是性能优化和原子性保证的主要考量因素。</p>
<p>第四，<strong>应用程序和文件系统 API 的协同设计提高了整个系统的灵活性。</strong>比如，我们放松了对 GFS 一致性模型的要求，这样就减轻了文件系统对应用程序的苛刻要求，大大简化了 GFS 的设计。我们引入了原子性的记录追加操作，从而保证多个客户端能够同时进行追加操作，不需要额外的同步操作来保证数据的一致性。本文后面还有对这些问题的细节的详细讨论。</p>
<p>Google 已经针对不同的应用部署了多套 GFS 集群。最大的一个集群拥有超过 1000 个存储节点，超过 300TB 的硬盘空间，被不同机器上的数百个客户端连续不断的频繁访问。</p>
</blockquote>
<h1 id="2-设计概述"><a href="#2-设计概述" class="headerlink" title="2 设计概述"></a>2 设计概述</h1><h2 id="2-1-设计预期"><a href="#2-1-设计预期" class="headerlink" title="2.1 设计预期"></a>2.1 设计预期</h2><p>在设计满足我们需求的文件系统时候，我们的设计目标既有机会、又有挑战。之前我们已经提到了一些需要关注的关键点，这里我们将设计的预期目标的细节展开讨论。</p>
<ul>
<li><p>系统由许多廉价的普通组件组成，组件失效是一种常态。系统必须持续监控自身的状态，它必须将组件失效作为一种常态，能够迅速地侦测、冗余并恢复失效的组件。</p>
</li>
<li><p>系统存储一定数量的大文件。我们预期会有几百万文件，文件的大小通常在 100MB 或者以上。数个 GB 大小的文件也是普遍存在，并且要能够被有效的管理。系统也必须支持小文件，但是不需要针对小文件做专门的优化。</p>
</li>
<li><p>系统的工作负载主要由<strong>两种读操作</strong>组成：<strong>大规模的流式读取</strong>和<strong>小规模的随机读取</strong>。大规模的流式读取通常一次读取数百 KB 的数据，更常见的是一次读取 1MB 甚至更多的数据。来自同一个客户机的连续操作通常是读取同一个文件中连续的一个区域。小规模的随机读取通常是在文件某个随机的位置读取几个 KB 数据。如果应用程序对性能非常关注，通常的做法是把小规模的随机读取操作合并并排序，之后按顺序批量读取，这样就避免了在文件中前后来回的移动读取位置。</p>
</li>
<li><p>系统的工作负载还包括许多大规模的、顺序的、数据追加方式的写操作。一般情况下，每次写入的数据的大小和大规模读类似。数据一旦被写入后，文件就很少会被修改了。系统支持小规模的随机位置写入操作，但是可能效率不高。（应当尽量避免使用）</p>
</li>
<li><p>系统必须高效的、行为定义明确的（well-defined）实现多客户端并行追加数据到同一个文件里的语意。我们的文件通常被用于” 生产者 - 消费者 “队列，或者其它多路文件合并操作。通常会有数百个生产者，每个生产者进程运行在一台机器上，同时对一个文件进行追加操作。使用最小的同步开销来实现的原子的多路追加数据操作是必不可少的。文件可以在稍后读取，或者是消费者在追加的操作的同时读取文件。</p>
</li>
<li><p>高性能的稳定网络带宽远比低延迟重要。我们的目标程序绝大部分要求能够高速率的、大批量的处理数据，极少有程序对单一的读写操作有严格的响应时间要求。</p>
<blockquote>
<p>我们可以将带宽和延迟用比喻的方式进行比较：带宽和高速公路上的车道数有关，能同时跑多少量车就是带宽，延迟和路况有关，平均车速就是在描述延迟。带宽和延迟反相关。</p>
<p>具体来说，作为一个文件管理系统可能因为涉及异步异地备份而比较耗时，因此延迟比较大。而对于一个游戏服务来说，延迟就不能高。正是因为如此，一个文件服务器的带宽被占用过多时，下载文件的速率就会明显降低。一个游戏为了保障用户体验，在服务器爆满时会采用排队机制，比如 LOL 或者 WOW 服务器在周末时因为在线玩家较多，就会出现登陆排队，另一方面会国内游戏（包括代理）往往会有多个频道或者区的概念，目的都是为了分流。总之目的都是避免服务器因为带宽被占满导致游戏延迟多大，玩家游戏体验过差。</p>
</blockquote>
</li>
</ul>
<h2 id="2-2-接口"><a href="#2-2-接口" class="headerlink" title="2.2 接口"></a>2.2 接口</h2><p>GFS 提供了一套类似传统文件系统的 API 接口函数，虽然并不是严格按照 POSIX 等标准 API 的形式实现的。文件以分层目录的形式组织，用路径名来标识。我们支持常用的操作，如创建新文件、删除文件、打开文件、关闭文件、读和写文件。</p>
<p>另外，GFS 提供了快照和记录追加操作。快照以很低的成本创建一个文件或者目录树的拷贝。记录追加操作允许多个客户端同时对一个文件进行数据追加操作，同时保证每个客户端的追加操作都是原子性的。这对于实现多路结果合并，以及” 生产者 - 消费者” 队列非常有用，多个客户端可以在不需要额外的同步锁定的情况下，同时对一个文件追加数据。我们发现这些类型的文件对于构建大型分布应用是非常重要的。快照和记录追加操作将在后续章节讨论。</p>
<h2 id="2-3-架构"><a href="#2-3-架构" class="headerlink" title="2.3 架构"></a>2.3 架构</h2><p>一个 GFS cluster（集群）分为两个组件：</p>
<ul>
<li><strong>单个</strong> master 节点；</li>
<li><strong>多个</strong> chunkserver 节点；</li>
</ul>
<blockquote>
<p>可见 GFS 集群是一个典型 Master + Worker 结构<br>Master + Worker 结构说的是存在一个 Master 来管理任务、分配任务，而 Worker 是真正干活的节点。在这里干的活自然是数据的存储和读取。</p>
</blockquote>
<p>一个 GFS 集群同时可以被多个 client（客户）节点访问。所有的这些机器通常都是普通的 Linux 机器，运行着用户级别 (user-level) 的服务进程。我们可以很容易的把 Chunk 服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。</p>
<p>一个 GFS 集群的架构可以用下图表示：</p>
<p><img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220809221532657.png" alt="image-20220809221532657"></p>
<p>GFS 存储的文件都被分割成固定大小的 Chunk。在 Chunk 创建的时候，Master 服务器会给每个 Chunk 分配一个不变的、唯一的 64 位的 Chunk 标识。Chunk 服务器把 Chunk 以 linux 文件的形式保存在本地硬盘上，并且根据指定的 Chunk 标识和字节范围来读写块数据。出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用 3 个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p>
<blockquote>
<p>大文件分多块存储的好处：可以并行操作，提高系统对文件总体的读写速度。<br>例如：原本一个磁盘转速 5400 rpm，那么读完一个 10 GB 的文件可能需要 200 秒（假设），现在 10 GB 的文件分别在 10 个磁盘上存储，转速不变，那么文件读完仅仅需要 20 秒。</p>
</blockquote>
<p>Master 节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和 Chunk 的映射信息、以及当前 Chunk 的位置信息。Master 节点还管理着系统范围内的活动，比如，Chunk 租约管理、孤立 Chunk (orphaned chunks) 的回收、以及 Chunk 在 Chunk 服务器之间的迁移。Master 节点使用心跳信息周期地和每个 Chunk 服务器通讯，发送指令到各个 Chunk 服务器并接收 Chunk 服务器的状态信息。</p>
<p>GFS 客户端代码以库（SDK）的形式被链接到客户程序里。客户端代码实现了 GFS 文件系统的 API 接口函数、应用程序与 Master 节点和 Chunk 服务器通讯、以及对数据进行读写操作。客户端和 Master 节点的通信只获取元数据，所有的数据操作都是由客户端直接和 Chunk 服务器进行交互的。我们不提供 POSIX 标准的 API 的功能，因此，GFS API 调用不需要深入到 Linux vnode 级别。</p>
<p>无论是客户端还是 Chunk 服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现。（不过，客户端会缓存元数据。）Chunk 服务器不需要缓存文件数据的原因是：Chunk 以本地文件的方式保存，Linux 操作系统的文件系统缓存会把经常访问的数据缓存在内存中。</p>
<h2 id="2-4-单一Master节点"><a href="#2-4-单一Master节点" class="headerlink" title="2.4 单一Master节点"></a>2.4 单一 Master 节点</h2><p>单一的 Master 节点的策略大大地简化了我们的设计。单一的 Master 节点可以通过全局的信息精确定位 Chunk 的位置以及进行复制决策。另外，我们必须减少对 Master 节点的读写，避免 Master 节点成为系统的瓶颈。客户端并不通过 Master 节点读写文件数据。反之，客户端向 Master 节点询问它应该联系的 Chunk 服务器。客户端将这些元数据信息缓存一段时间，后续的操作将直接和 Chunk 服务器进行数据读写操作。</p>
<p>我们利用图 1 了解一次简单读取的流程。首先，客户端把文件名和程序指定的字节偏移量，根据固定的 Chunk 大小，转换成文件的 Chunk 索引。然后，它把文件名和 Chunk 索引发送给 Master 节点。Master 节点将相应的 Chunk 标识和副本的位置信息发还给客户端。客户端用文件名和 Chunk 索引作为 key 缓存这些信息。</p>
<p>之后客户端发送请求到其中的一个副本处，一般会选择最近的。请求信息包含了 Chunk 的标识和字节范围。在对这个 Chunk 的后续读取操作中，客户端不必再和 Master 节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。实际上，客户端通常会在一次请求中查询多个 Chunk 信息，Master 节点的回应也可能包含了紧跟着这些被请求的 Chunk 后面的 Chunk 的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避免了客户端和 Master 节点未来可能会发生的几次通讯。</p>
<h2 id="2-5-Chunk-Size"><a href="#2-5-Chunk-Size" class="headerlink" title="2.5 Chunk Size"></a>2.5 Chunk Size</h2><p>Chunk 的大小是关键的设计参数之一。我们选择了 64MB，这个尺寸远远大于一般文件系统的 Blocksize。每个 Chunk 的副本都以普通 Linux 文件的形式保存在 Chunk 服务器上，只有在需要的时候才扩大。惰性空间分配策略避免了因内部碎片造成的空间浪费，内部碎片或许是对选择这么大的 Chunk 尺寸最令人诟病的地方。</p>
<p>选择较大的 Chunk 尺寸有几个重要的优点。首先，<strong>它减少了客户端和 Master 节点通讯的需求</strong>，因为只需要一次和 Mater 节点的通信就可以获取 Chunk 的位置信息，之后就可以对同一个 Chunk 进行多次的读写操作。<strong>这种方式对降低我们的工作负载来说效果显著</strong>，因为我们的应用程序通常是连续读写大文件。即使是小规模的随机读取，采用较大的 Chunk 尺寸也带来明显的好处，客户端可以轻松的缓存一个数 TB 的工作数据集所有的 Chunk 位置信息。其次，采用较大的 Chunk 尺寸，客户端能够对一个块进行多次操作，这样就可以通过与 Chunk 服务器保持较长时间的 TCP 连接来减少网络负载。第三，<strong>选用较大的 Chunk 尺寸减少了 Master 节点需要保存的元数据的数量</strong>。这就允许我们把元数据全部放在内存中，在后续章节我们会讨论元数据全部放在内存中带来的额外的好处。</p>
<p>另一方面，即使配合惰性空间分配，采用较大的 Chunk 尺寸也有其缺陷。小文件由较少的 Chunk 组成，甚至只有一个 Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些 Chunk 的 Chunk 服务器就会变成热点。在实际应用中，由于我们的程序通常是连续的读取包含多个 Chunk 的大文件，热点还不是主要的问题。</p>
<p>然而，当我们第一次把 GFS 用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在 GFS 上保存为 single-chunk 文件，之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个 Chunk 服务器被数百个客户端的并发请求访问导致系统局部过载。我们通过使用更大的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。一个可能的长效解决方案是，在这种的情况下，允许客户端从其它客户端读取数据。</p>
<h2 id="2-6-元数据"><a href="#2-6-元数据" class="headerlink" title="2.6 元数据"></a>2.6 元数据</h2><p>Master 服务器存储 3 种主要类型的元数据，包括：<strong>文件和 Chunk 的命名空间、文件和 Chunk 的对应关系、每个 Chunk 副本的存放地点</strong>。所有的元数据都保存在 Master 服务器的内存中。前两种类型的元数据（命名空间、文件和 Chunk 的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程 Master 服务器上。采用保存变更日志的方式，我们能够简单可靠的更新 Master 服务器的状态，并且不用担心 Master 服务器崩溃导致数据不一致的风险。Master 服务器不会持久保存 Chunk 位置信息。Master 服务器在启动时，或者有新的 Chunk 服务器加入时，向各个 Chunk 服务器轮询它们所存储的 Chunk 的信息。</p>
<h3 id="2-6-1-内存中的数据结构"><a href="#2-6-1-内存中的数据结构" class="headerlink" title="2.6.1 内存中的数据结构"></a>2.6.1 内存中的数据结构</h3><p>因为元数据保存在内存中，所以 Master 服务器的操作速度非常快。并且，Master 服务器可以在后台简单而高效的周期性扫描自己保存的全部状态信息。这种周期性的状态扫描也用于实现 Chunk 垃圾收集、在 Chunk 服务器失效的时重新复制数据、通过 Chunk 的迁移实现跨 Chunk 服务器的负载均衡以及磁盘使用状况统计等功能。</p>
<p>将元数据全部保存在内存中的方法有潜在问题：Chunk 的数量以及整个系统的承载能力都受限于 Master 服务器所拥有的内存大小。但是在实际应用中，这并不是一个严重的问题。Master 服务器只需要不到 64 个字节的元数据就能够管理一个 64MB 的 Chunk。由于大多数文件都包含多个 Chunk，因此绝大多数 Chunk 都是满的，除了文件的最后一个 Chunk 是部分填充的。同样的，每个文件的在命名空间中的数据大小通常在 64 字节以下，因为保存的文件名是用前缀压缩算法压缩过的。</p>
<p>即便是需要支持更大的文件系统，为 Master 服务器增加额外内存的费用是很少的，而通过增加有限的费用，我们就能够把元数据全部保存在内存里，增强了系统的简洁性、可靠性、高性能和灵活性。</p>
<h3 id="2-6-2-Chunk位置信息"><a href="#2-6-2-Chunk位置信息" class="headerlink" title="2.6.2 Chunk位置信息"></a>2.6.2 Chunk 位置信息</h3><p>Master 服务器并不持久化保存哪个 Chunk 服务器存有指定 Chunk 的副本的信息。Master 服务器只是在启动的时候轮询 Chunk 服务器以获取这些信息。Master 服务器能够保证它持有的信息始终是最新的，因为它控制了所有的 Chunk 位置的分配，而且通过周期性的心跳信息监控 Chunk 服务器的状态。</p>
<p>最初设计时，我们试图把 Chunk 的位置信息持久的保存在 Master 服务器上，但是后来我们发现在启动的时候轮询 Chunk 服务器，之后定期轮询更新的方式更简单。这种设计简化了在有 Chunk 服务器加入集群、离开集群、更名、失效、以及重启的时候，Master 服务器和 Chunk 服务器数据同步的问题。在一个拥有数百台服务器的集群中，这类事件会频繁的发生。</p>
<p>可以从另外一个角度去理解这个设计决策：只有 Chunk 服务器才能最终确定一个 Chunk 是否在它的硬盘上。我们从没有考虑过在 Master 服务器上维护这些信息的全局视图，因为 Chunk 服务器的错误可能会导致 Chunk 自动消失 (比如，硬盘损坏了或者无法访问了)，亦或者操作人员可能会重命名一个 Chunk 服务器。</p>
<h3 id="2-6-3-操作日志"><a href="#2-6-3-操作日志" class="headerlink" title="2.6.3 操作日志"></a>2.6.3 操作日志</h3><p>操作日志包含了关键的元数据变更历史记录。这对 GFS 非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线（也就是通过逻辑日志的序号作为操作发生的逻辑时间，类似于事务系统中的 LSN）。文件和 Chunk，连同它们的版本，都由它们创建的逻辑时间唯一的、永久的标识。</p>
<p>操作日志非常重要，我们必须确保日志文件的完整，确保只有在元数据的更新被持久化后，日志才对客户端是可见的。否则，即使 Chunk 本身没有出现任何问题，我们仍有可能丢失整个文件系统，或者丢失客户端最近的操作。所以，我们会把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求。Master 服务器会收集多个日志记录后批量处理，以减少写入磁盘和复制对系统整体性能的影响。</p>
<blockquote>
<p>WAL - Write-Ahead-Log</p>
</blockquote>
<p>Master 服务器在灾难恢复时，通过重演操作日志把文件系统恢复到最近的状态。为了缩短 Master 启动的时间，我们必须使日志足够小（即 replay 系统操作的日志量尽量的少）。Master 服务器在日志增长到一定量时对系统状态做一次 Checkpoint (Checkpoint 是一种行为，一种对数据库状态作一次快照的行为)，将所有的状态数据写入一个 Checkpoint 文件（并删除之前的日志文件）。在灾难恢复的时候，Master 服务器就通过从磁盘上读取这个 Checkpoint 文件，以及重演 Checkpoint 之后的有限个日志文件就能够恢复系统。Checkpoint 文件以压缩 BTree（B+Tree）的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。</p>
<p>由于创建一个 Checkpoint 文件需要一定的时间，所以 Master 服务器的内部状态被组织为一种格式，这种格式要确保在 Checkpoint 过程中不会阻塞正在进行的修改操作。Master 服务器使用独立的线程切换到新的日志文件和创建新的 Checkpoint 文件。新的 Checkpoint 文件包括切换前所有的修改。对于一个包含数百万个文件的集群，创建一个 Checkpoint 文件需要 1 分钟左右的时间。创建完成后，Checkpoint 文件会被写入在本地和远程的硬盘里。</p>
<p>Master 服务器恢复只需要最新的 Checkpoint 文件和后续的日志文件。旧的 Checkpoint 文件和日志文件可以被删除，但是为了应对灾难性的故障（catastrophes，数据备份相关文档中经常会遇到这个词，表示一种超出预期范围的灾难性事件），我们通常会多保存一些历史文件。Checkpoint 失败不会对正确性产生任何影响，因为恢复功能的代码可以检测并跳过没有完成的 Checkpoint 文件。</p>
<h2 id="2-7-一致性模型"><a href="#2-7-一致性模型" class="headerlink" title="2.7 一致性模型"></a>2.7 一致性模型</h2><p>GFS 支持一个宽松的一致性模型，这个模型能够很好的支撑我们的高度分布的应用，同时还保持了相对简单且容易实现的优点。本节我们讨论 GFS 的一致性的保障机制，以及对应用程序的意义。我们也着重描述了 GFS 如何管理这些一致性保障机制，但是实现的细节将在本论文的其它部分讨论。</p>
<h3 id="2-7-1-GFS一致性保障机制"><a href="#2-7-1-GFS一致性保障机制" class="headerlink" title="2.7.1 GFS一致性保障机制"></a>2.7.1 GFS 一致性保障机制</h3><p>文件命名空间的修改（例如，文件创建）是原子性的。它们仅由 Master 节点的控制：命名空间锁提供了原子性和正确性（4.1 章）的保障；Master 节点的操作日志定义了这些操作在全局的顺序（2.6.3 章）。</p>
<img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220809235021154.png" alt="image-20220809235021154" style="zoom:50%;">

<p>数据修改后文件 region（region 这个词用中文非常难以表达，我认为应该是修改操作所涉及的文件中的某个范围）的状态取决于操作的类型、成功与否、以及是否同步修改。表 1 总结了各种操作的结果。如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件 region 是 “<strong>一致的（consistent）</strong>”；如果对文件的数据修改之后，region 是一致的，并且客户端能够看到写入操作全部的内容，那么这个 region 是 “<strong>已定义的（defined）</strong>”。当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰，那么影响的 region 就是<strong>已定义的（隐含了一致性）</strong>：所有的客户端都可以看到写入的内容。并行修改操作成功完成之后，<strong>region 处于一致的、未定义的状态（consistent but undefined）</strong>：所有的客户端看到同样的数据，但是无法读到任何一次写入操作写入的数据。通常情况下，文件 region 内包含了来自多个修改操作的、混杂的数据片段。失败的修改操作导致一个 <strong>region 处于不一致状态（inconsistent）</strong>（同时也是未定义的）：不同的客户在不同的时间会看到不同的数据。后面我们将描述应用如何区分已定义和未定义的 region。应用程序没有必要再去细分未定义 region 的不同类型。</p>
<blockquote>
<ul>
<li>consistent：所有 GFS Client 将总是看到完全相同的数据，无论 GFS Client 最终是从哪一个 GFS chunkserver replica 上进行数据读取；</li>
<li>defined：当一个文件数据修改之后如果 file region 还是保持 consistent 状态，并且所有 client 能够看到全部修改（且已经写入 chunkserver）的内容；<ul>
<li>这种说法相当于并发正确地写入成功，并且我们可以看到 defined 的要求高于 consistent，因为后者是前者的基础；</li>
</ul>
</li>
<li>consistent but undefined：从定义上来看，就是所有 client 能够看到相同的数据，但是并不能及时反映并发修改中的任意修改；<ul>
<li>这通常指写冲突发生了，GFS 并不保证多个客户端的并发覆写请求的最终执行顺序，这种顺序是 undefined，这是因为不能确定真正的执行次序而不确定。但是最终所有客户端查询时能读到相同的结果。</li>
</ul>
</li>
<li>inconsistent：因为处于 inconsistent 状态，因此一定也处于 undeﬁned 状态，造成此状态的操作也被认为是 failed 的。不同的 Client 在能读到的数据不一致，同一个 Client 在不同的时刻读取的文件数据也不一致。</li>
</ul>
</blockquote>
<p>数据修改操作分为<strong>写入</strong>或者<strong>记录追加</strong>两种。写入操作把数据写在应用程序指定的文件偏移位置上。即使有多个修改操作并行执行时，记录追加操作至少可以把数据原子性的追加到文件中一次，但是偏移位置是由 GFS 选择的（3.3）（这句话有点费解，其含义是所有的追加写入都会成功，但是有可能被执行了多次，而且每次追加的文件偏移量由 GFS 自己计算）。（相比而言，通常说的追加操作写的偏移位置是文件的尾部。）GFS 返回给客户端一个偏移量，表示了包含了写入记录的、已定义的 region 的起点。另外，GFS 可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件 region 被认定是不一致的，这些数据通常比用户数据小的多。</p>
<blockquote>
<ul>
<li>Write：修改 File 中的原有数据，具体来说就是在指定文件的偏移地址下写入数据（这就是覆写操作）；<ul>
<li>GFS 没有为这类覆写操作提供完好的一致性保证：如果多个的 Client 并发地写入同一块文件区域，操作完成后这块区域的数据可能由各次写入的数据碎片所组成，此时的状态最好也就是 consistant but undefined 状态。</li>
</ul>
</li>
<li>Record Append：即在原有 File 末尾 Append (追加) 数据，这种操作被 GFS 系统确保为原子操作，这是 GFS 系统最重要的优化之一。GFS 中的 append 操作并不简单地在原文件的末尾对应的 offset 处开始写入数据（这是通常意义下的 append 操作），而是通过选择一个 offset，这一点在下面会详细说到。最后该被选择的 offset 会返回给 Client，代表此次 record 的起始数据偏移量。由于 GFS 对于 Record Append 采用的是 at least once 的消息通信模型，在绝对确保此次写操作成功的情况下，可能造成在重复写数据。</li>
</ul>
</blockquote>
<p>经过了一系列的成功的修改操作之后，GFS 确保被修改的文件 region 是已定义的，并且包含最后一次修改操作写入的数据。GFS 通过以下措施确保上述行为：</p>
<ul>
<li>（a） 对 Chunk 的所有副本的修改操作顺序一致（3.1 章），</li>
<li>（b）使用 Chunk 的版本号来检测副本是否因为它所在的 Chunk 服务器宕机（4.5 章）而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master 服务器也不再返回这个 Chunk 副本的位置信息给客户端。它们会被垃圾收集系统尽快回收。</li>
</ul>
<p>由于 Chunk 位置信息会被客户端缓存，所以在信息刷新前，客户端有可能从一个失效的副本读取了数据。这个时间穿窗口取决于缓存的超时时间设置以及下一次打开同一文件的限制。文件再次被打开后会清除缓存中与该文件有关的所有 Chunk 位置信息。而且，由于我们的文件大多数都是只进行追加操作的，所以，一个失效的副本通常返回一个提前结束的 Chunk 而不是过期的数据（也就是说仅仅没有包含最新的追加内容的 chunk，而不是被覆写了的数据（因为无法覆写），这样造成的影响也不会很大。）。当一个 Reader（Reader 和 Writer，分别表示执行 GFS 读取和写入操作的程序）重新尝试并联络 Master 服务器时，它就会立刻得到最新的 Chunk 位置信息。</p>
<p>即使在修改操作成功执行很长时间之后，组件的失效也可能损坏或者删除数据。GFS 通过 Master 服务器和所有 Chunk 服务器的定期 “握手” 来找到失效的 Chunk 服务器，并且使用 Checksum 来校验数据是否损坏（5.2 章）。一旦发现问题，数据要尽快利用有效的副本进行恢复（4.3 章）。只有当一个 Chunk 的所有副本在 GFS 检测到错误并采取应对措施之前全部丢失，这个 Chunk 才会不可逆转的丢失。在一般情况下 GFS 的反应时间（指 Master 节点检测到错误并采取应对措施）是几分钟。即使在这种情况下，Chunk 也只是不可用了，而不是损坏了：应用程序会收到明确的错误信息而不是损坏的数据。</p>
<h3 id="2-7-2-程序的实现"><a href="#2-7-2-程序的实现" class="headerlink" title="2.7.2 程序的实现"></a>2.7.2 程序的实现</h3><p>使用 GFS 的应用程序可以利用一些简单技术实现这个宽松的一致性模型，这些技术也用来实现一些其它的目标功能，包括：尽量采用追加写入而不是覆盖，Checkpoint，自验证的写入操作，自标识的记录。</p>
<p>在实际应用中，我们所有的应用程序对文件的写入操作都是尽量采用数据追加方式，而不是覆盖方式。一种典型的应用，应用程序从头到尾写入数据，生成了一个文件。写入所有数据之后，应用程序自动将文件改名为一个永久保存的文件名，或者周期性的作 Checkpoint，记录成功写入了多少数据。Checkpoint 文件可以包含程序级别的校验和。Readers 仅校验并处理上个 Checkpoint 之后产生的文件 region，这些文件 region 的状态一定是已定义的。这个方法满足了我们一致性和并发处理的要求。追加写入比随机位置写入更加有效率，对应用程序的失败处理更具有弹性。Checkpoint 可以让 Writer 以渐进的方式重新开始，并且可以防止 Reader 处理已经被成功写入，但是从应用程序的角度来看还并未完成的数据。</p>
<p>我们再来分析另一种典型的应用。许多应用程序并行的追加数据到同一个文件，比如进行结果的合并或者是一个生产者 - 消费者队列。记录追加方式的 “至少一次追加” 的特性保证了 Writer 的输出。Readers 使用下面的方法来处理偶然性的填充数据和重复内容。Writers 在每条写入的记录中都包含了额外的信息，例如 Checksum，用来验证它的有效性。Reader 可以利用 Checksum 识别和抛弃额外的填充数据和记录片段。如果应用不能容忍偶尔的重复内容 (比如，如果这些重复数据触发了非幂等操作)，可以用记录的唯一标识符来过滤它们，这些唯一标识符通常用于命名程序中处理的实体对象，例如 web 文档。这些记录 I/O 功能（These functionalities for record I/O）（除了剔除重复数据）都包含在我们的程序共享的库中，并且适用于 Google 内部的其它的文件接口实现。所以，相同序列的记录，加上一些偶尔出现的重复数据，都被分发到 Reader 了。</p>
<h1 id="3-系统交互"><a href="#3-系统交互" class="headerlink" title="3 系统交互"></a>3 系统交互</h1><p>我们在设计这个系统时，一个重要的原则是最小化所有操作和 Master 节点的交互。带着这样的设计理念，我们现在描述一下客户机、Master 服务器和 Chunk 服务器如何进行交互，以实现数据修改操作、原子的记录追加操作以及快照功能。</p>
<h2 id="3-1-租约（lease）和更新（变更）顺序"><a href="#3-1-租约（lease）和更新（变更）顺序" class="headerlink" title="3.1 租约（lease）和更新（变更）顺序"></a>3.1 租约（lease）和更新（变更）顺序</h2><p>更新是一个会改变 Chunk 内容或者元数据的操作，比如写入操作或者记录追加操作。更新操作会在 Chunk 的所有副本上执行。我们使用租约（lease）机制来保持多个副本间变更顺序的一致性。Master 节点为 Chunk 的一个副本建立一个租约，我们把这个副本叫做主 Chunk。主 Chunk 对 Chunk 的所有更改操作进行序列化。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序首先由 Master 节点选择的租约的顺序决定，然后由租约中主 Chunk 分配的序列号决定。</p>
<p>设计租约机制的目的是为了最小化 Master 节点的管理负担。租约的初始超时设置为 60 秒。不过，只要 Chunk 被修改了，主 Chunk 就可以申请更长的租期，通常会得到 Master 节点的确认并收到租约延长的时间。这些租约延长请求和批准的信息通常都是附加在 Master 节点和 Chunk 服务器之间的心跳消息中来传递。有时 Master 节点会试图提前取消租约（例如，Master 节点想提前取消在一个已经被改名的文件上的修改操作）。即使 Master 节点和主 Chunk 失去联系，它仍然可以安全地在旧的租约到期后和另外一个 Chunk 副本签订新的租约。</p>
<img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220810133527036.png" alt="image-20220810133527036" style="zoom:50%;">

<p>在图 2 中，我们依据步骤编号，展现写入操作的控制流程：</p>
<ol>
<li>客户机向 Master 节点询问哪一个 Chunk 服务器持有当前的租约，以及其它副本的位置。如果没有一个 Chunk 持有租约，Master 节点就选择其中一个副本建立一个租约（这个步骤在图上没有显示）。</li>
<li>Master 节点将主 Chunk 的标识符以及其它副本（又称为 secondary 副本、二级副本）的位置返回给客户机。客户机缓存这些数据以便后续的操作。只有在主 Chunk 不可用，或者主 Chunk 回复信息表明它已不再持有租约的时候，客户机才需要重新跟 Master 节点联系。</li>
<li>客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk 服务器接收到数据并保存在它的内部 LRU 缓存中，一直到数据被使用或者过期交换出去。由于数据流的网络传输负载非常高，通过分离数据流和控制流，我们可以基于网络拓扑情况对数据流进行规划，提高系统性能，而不用去理会哪个 Chunk 服务器保存了主 Chunk。3.2 章节会进一步讨论这点。</li>
<li>当所有的副本都确认接收到了数据，客户机发送写请求到主 Chunk 服务器。这个请求标识了早前推送到所有副本的数据。主 Chunk 为接收到的所有操作分配连续的序列号，这些操作可能来自不同的客户机，序列号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中。</li>
<li>主 Chunk 把写请求传递到所有的二级副本。每个二级副本依照主 Chunk 分配的序列号以相同的顺序执行这些操作。</li>
<li>所有的二级副本回复主 Chunk，它们已经完成了操作。</li>
<li>主 Chunk 服务器回复客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写入操作可能在主 Chunk 和一些二级副本执行成功。（如果操作在主 Chunk 上失败了，操作就不会被分配序列号，也不会被传递。）客户端的请求被确认为失败，被修改的 region 处于不一致的状态。我们的客户机代码通过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤（3）到步骤（7）做几次尝试。</li>
</ol>
<p>如果应用程序一次写入的数据量很大，或者数据跨越了多个 Chunk，GFS 客户机代码（SDK）会把它们分成多个写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。因此，共享的文件 region 的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分解后的写入操作在所有的副本上都以相同的顺序执行完成，Chunk 的所有副本都是一致的。这使文件 region 处于 2.7 节描述的一致的、但是未定义的状态。</p>
<h2 id="3-2-数据流"><a href="#3-2-数据流" class="headerlink" title="3.2 数据流"></a>3.2 数据流</h2><p>为了提高网络效率，我们采取了把数据流和控制流分开的措施。在控制流从客户机到主 Chunk、然后再到所有二级副本的同时，数据以管道的方式，顺序的沿着一个精心选择的 Chunk 服务器链推送。我们的目标是充分利用每台机器的带宽，避免网络瓶颈和高延时的连接，最小化推送所有数据的延时。</p>
<p>为了充分利用每台机器的带宽，数据沿着一个 Chunk 服务器链顺序的推送，而不是以其它拓扑形式分散推送（例如，树型拓扑结构）。线性推送模式下，每台机器所有的出口带宽都用于以最快的速度传输数据，而不是在多个接受者之间分配带宽。</p>
<p>为了尽可能的避免出现网络瓶颈和高延迟的链接（eg，inter-switch 最有可能出现类似问题），每台机器都尽量的在网络拓扑中选择一台还没有接收到数据的、离自己最近的机器作为目标推送数据。假设客户机把数据从 Chunk 服务器 S1 推送到 S4。它把数据推送到最近的 Chunk 服务器 S1。S1 把数据推送到 S2，因为 S2 和 S4 中最接近的机器是 S2。同样的，S2 把数据传递给 S3 和 S4 之间更近的机器，依次类推推送下去。我们的网络拓扑非常简单，通过 IP 地址就可以计算出节点的 “距离”。</p>
<p>最后，我们利用基于 TCP 连接的、管道式数据推送方式来最小化延迟。Chunk 服务器接收到数据后，马上开始向前推送。管道方式的数据推送对我们帮助很大，因为我们采用全双工的交换网络。接收到数据后立刻向前推送不会降低接收的速度。在没有网络拥塞的情况下，传送 B 字节的数据到 R 个副本的理想时间是 B/T+RL ，T 是网络的吞吐量，L 是在两台机器数据传输的延迟。通常情况下，我们的网络连接速度是 100Mbps（T），L 将远小于 1ms。因此，1MB 的数据在理想情况下 80ms 左右就能分发出去。</p>
<h2 id="3-3-原子记录追加"><a href="#3-3-原子记录追加" class="headerlink" title="3.3 原子记录追加"></a>3.3 原子记录追加</h2><p>GFS 提供了一种原子的数据追加操作–记录追加。传统方式的写入操作，客户程序会指定数据写入的偏移量。对同一个 region 的并行写入操作不是串行的：region 尾部可能会包含多个不同客户机写入的数据片段。使用记录追加，客户机只需要指定要写入的数据。GFS 保证至少有一次原子的写入操作成功执行（即写入一个顺序的 byte 流），写入的数据追加到 GFS 指定的偏移位置上，之后 GFS 返回这个偏移量给客户机。这类似于在 Unix 操作系统编程环境中，对以 O_APPEND 模式打开的文件，多个并发写操作在没有竞态条件时的行为。</p>
<blockquote>
<p>具体来说：record append 是指向已经存储的文件的末尾追加数据，因此客户端并不需要像读操作那样提供一个数据范围，因为 record append 操作总是在文件末尾追加数据，这个地址偏移量应当交给 chunksever 来确定。</p>
</blockquote>
<p>记录追加在我们的分布应用中非常频繁的使用，在这些分布式应用中，通常有很多的客户机并行地对同一个文件追加写入数据。如果我们采用传统方式的文件写入操作，客户机需要额外的复杂、昂贵的同步机制，例如使用一个分布式的锁管理器。在我们的工作中，这样的文件通常用于多个生产者 / 单一消费者的队列系统，或者是合并了来自多个客户机的数据的结果文件。</p>
<p>记录追加是一种修改操作，它也遵循 3.1 节描述的控制流程，除了在主 Chunk 有些额外的控制逻辑。客户机把数据推送给文件最后一个 Chunk 的所有副本，之后发送请求给主 Chunk。主 Chunk 会检查这次记录追加操作是否会使 Chunk 超过最大尺寸（64MB）。如果超过了最大尺寸，主 Chunk 首先将当前 Chunk 填充到最大尺寸，之后通知所有二级副本做同样的操作，然后回复客户机要求其对下一个 Chunk 重新进行记录追加操作。（记录追加的数据大小严格控制在 Chunk 最大尺寸的 1/4，这样即使在最坏情况下，数据碎片的数量仍然在可控的范围。）通常情况下追加的记录不超过 Chunk 的最大尺寸，主 Chunk 把数据追加到自己的副本内，然后通知二级副本把数据写在跟主 Chunk 一样的位置上，最后回复客户机操作成功。</p>
<p>如果记录追加操作在任何一个副本上失败了，客户端就需要重新进行操作。重新进行记录追加的结果是，同一个 Chunk 的不同副本可能包含不同的数据–重复包含一个记录全部或者部分的数据。GFS 并不保证 Chunk 的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子被至少写入一次。这个特性可以通过简单观察推导出来：如果操作成功执行，数据一定已经写入到 Chunk 的所有副本的相同偏移位置上。这之后，所有的副本至少都到了记录尾部的长度，任何后续的记录都会追加到更大的偏移地址，或者是不同的 Chunk 上，即使其它的 Chunk 副本被 Master 节点选为了主 Chunk。就我们的一致性保障模型而言，记录追加操作成功写入数据的 region 是已定义的（因此也是一致的），反之则是不一致的（因此也就是未定义的）。正如我们在 2.7.2 节讨论的，我们的程序可以处理不一致的区域。</p>
<h2 id="3-4-快照"><a href="#3-4-快照" class="headerlink" title="3.4 快照"></a>3.4 快照</h2><p>快照操作几乎可以瞬间完成对一个文件或者目录树（“源”）做一个拷贝，并且几乎不会对正在进行的其它操作造成任何干扰。我们的用户可以使用快照迅速的创建一个巨大的数据集的分支拷贝（而且经常是递归拷贝的拷贝），或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的提交或者回滚到备份时的状态。</p>
<p>就像 AFS（即 Andrew File System，一种分布式文件系统），我们用标准的 copy-on-write 技术实现快照。当 Master 节点收到一个快照请求，它首先取消作快照的文件的所有 Chunk 的租约。这个措施保证了后续对这些 Chunk 的写操作都必须与 Master 交互以找到租约持有者。这就给 Master 节点一个率先创建 Chunk 的新拷贝的机会。</p>
<blockquote>
<p>其实现方式是：</p>
<ul>
<li>当一个 Master 节点接收到一个 snapshot 请求，它首先会 revoke（撤销） 对拷贝涉及的 chunk 对应的 lease（租赁），这用于确保后续写操作必须经过 Master 的重新进行交互，进行查找当前租赁的实际持有者，以便于 Master 有机会先创建 chunk 的副本。</li>
<li>当 lease 撤回或者过期后，Master 首先会将操作日志记录到磁盘，然后通过复制源文件以及目录树的 metadata 来将日志记录应用到内存中的状态。</li>
<li>当有关客户端请求 Master 对这些 chunk 进行写操作时，Master 通过这些 chunk 上的引用计数大于 1，于是 Master 就会为这些 chunk 创建相关的 handler，然后通知拥有这些 chunk 的 chunkserver 创建数据相同的 chunk（这种方式不再 Master 上进行复制，目的是节约 Master 带宽与内存）。</li>
<li>最后客户端新的写请求将直接作用于这些新创建的 chunk 上，同时也会被颁发新的 lease；</li>
</ul>
</blockquote>
<p>租约取消或者过期之后，Master 节点把这个操作以日志的方式记录到硬盘上。然后，Master 节点通过复制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件和源文件指向完全相同的 Chunk 地址。</p>
<p>在快照操作之后，当客户机第一次想写入数据到 Chunk C，它首先会发送一个请求到 Master 节点查询当前的租约持有者。Master 节点注意到 Chunke C 的引用计数超过了 1。Master 节点不会马上回复客户机的请求，而是选择一个新的 Chunk 句柄 C。之后，Master 节点要求每个拥有 Chunk C 当前副本的 Chunk 服务器创建一个叫做 C 的新 Chunk。通过在源 Chunk 所在 Chunk 服务器上创建新的 Chunk，我们确保数据在本地而不是通过网络复制（我们的硬盘比我们的 100Mb 以太网大约快 3 倍）。从这点来讲，请求的处理方式和任何其它 Chunk 没什么不同：Master 节点确保新 Chunk C 的一个副本拥有租约，之后回复客户机，客户机得到回复后就可以正常的写这个 Chunk，而不必理会它是从一个已存在的 Chunk 克隆出来的。（复制的源 chunk 被用来做 snapshot）</p>
<h1 id="4-Master节点的操作"><a href="#4-Master节点的操作" class="headerlink" title="4 Master节点的操作"></a>4 Master 节点的操作</h1><p>Master 节点执行所有的名称空间（namespace）操作。此外，它还管理着整个系统里所有 Chunk 的副本：它决定 Chunk 的存储位置，创建新 Chunk 和它的副本，协调各种各样的系统活动以保证 Chunk 被完全复制，在所有的 Chunk 服务器之间的进行负载均衡，回收不再使用的存储空间。本节我们讨论上述的主题。</p>
<h2 id="4-1-名称空间和锁"><a href="#4-1-名称空间和锁" class="headerlink" title="4.1 名称空间和锁"></a>4.1 名称空间和锁</h2><p>Master 节点的很多操作会花费很长的时间：比如，快照操作必须取消 Chunk 服务器上快照所涉及的所有的 Chunk 的租约。我们不希望在这些操作的运行时，延缓了其它的 Master 节点的操作。因此，我们允许多个操作同时进行，使用名称空间的 region 上的锁来保证执行的正确顺序。</p>
<p>不同于许多传统文件系统，GFS 没有针对每个目录实现能够列出目录下所有文件的数据结构。GFS 也不支持文件或者目录的链接（即 Unix 术语中的硬链接或者符号链接）。在逻辑上，GFS 的名称空间就是一个全路径和元数据映射关系的查找表（Key-Value）。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型结构上，每个节点（绝对路径的文件名或绝对路径的目录名）都有一个关联的读写锁。</p>
<p>每个 Master 节点的操作在开始之前都要获得一系列的锁。通常情况下，如果一个操作涉及 <code>/d1/d2/…/dn/leaf</code>，那么操作首先要获得目录 <code>/d1，/d1/d2，…，/d1/d2/…/dn</code> 的读锁，以及 <code>/d1/d2/…/dn/leaf</code> 的读写锁。注意，根据操作的不同，leaf 可以是一个文件，也可以是一个目录。</p>
<p>现在，我们演示一下在 <code>/home/user</code> 被快照到 <code>/save/user</code> 的时候，锁机制如何防止创建文件 <code>/home/user/foo</code>。<strong>快照操作</strong>获取 <code>/home</code> 和 <code>/save</code> 的读取锁，以及 <code>/home/user</code> 和 <code>/save/user</code> 的写入锁。<strong>文件创建操作</strong>获得 <code>/home</code> 和 <code>/home/user</code> 的读取锁，以及 <code>/home/user/foo</code> 的写入锁。这两个操作要顺序执行，因为它们试图获取的 <code>/home/user</code> 的锁是相互冲突。文件创建操作不需要获取父目录的写入锁，因为这里没有” 目录”，或者类似 inode 等用来禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。</p>
<p>采用这种锁方案的优点<strong>是支持对同一目录的并行操作</strong>。比如，可以在同一个目录下同时创建多个文件：每一个操作都获取一个目录名的上的读取锁和文件名上的写入锁。目录名的<strong>读取锁</strong>足以的防止目录被删除、改名以及被快照。文件名的<strong>写入锁</strong>序列化文件创建操作，确保不会多次创建同名的文件。</p>
<p>因为名称空间可能有很多节点，读写锁采用惰性分配策略，在不再使用的时候立刻被删除。同样，锁的获取也要依据一个全局一致的顺序来避免死锁：首先按名称空间的层次排序，在同一个层次内按字典顺序排序。</p>
<h2 id="4-2-副本的位置"><a href="#4-2-副本的位置" class="headerlink" title="4.2 副本的位置"></a>4.2 副本的位置</h2><p>GFS 集群是高度分布的多层布局结构，而不是平面结构。典型的拓扑结构是有数百个 Chunk 服务器安装在许多机架上。Chunk 服务器被来自同一或者不同机架上的数百个客户机轮流访问。不同机架上的两台机器间的通讯可能跨越一个或多个网络交换机。另外，机架的出入带宽可能比机架内所有机器加和在一起的带宽要小。多层分布架构对数据的灵活性、可靠性以及可用性方面提出特有的挑战。</p>
<p>Chunk 副本位置选择的策略服务两大目标：<strong>最大化数据可靠性和可用性，最大化网络带宽利用率</strong>。为了实现这两个目的，仅仅是在多台机器上分别存储这些副本是不够的，这只能预防硬盘损坏或者机器失效带来的影响，以及最大化每台机器的网络带宽利用率。我们必须在多个机架间分布储存 Chunk 的副本。这保证 Chunk 的一些副本在整个机架被破坏或掉线（比如，共享资源，如电源或者网络交换机造成的问题）的情况下依然存在且保持可用状态。这还意味着在网络流量方面，尤其是针对 Chunk 的读操作，能够有效利用多个机架的整合带宽。另一方面，写操作必须和多个机架上的设备进行网络通信，但是这个代价是我们愿意付出的。</p>
<h2 id="4-3-创建、重新复制、重新负载均衡"><a href="#4-3-创建、重新复制、重新负载均衡" class="headerlink" title="4.3 创建、重新复制、重新负载均衡"></a>4.3 创建、重新复制、重新负载均衡</h2><p>Chunk 的副本有三个用途：Chunk 创建，重新复制和重新负载均衡。</p>
<p>当 Master 节点创建一个 Chunk 时，它会选择在哪里放置初始的空的副本。Master 节点会考虑几个因素：</p>
<ol>
<li>我们希望在低于平均硬盘使用率的 Chunk 服务器上存储新的副本。这样的做法最终能够平衡 Chunk 服务器之间的硬盘使用率。</li>
<li>我们希望限制在每个 Chunk 服务器上 “最近” 的 Chunk 创建操作的次数。虽然创建操作本身是廉价的，但是创建操作也意味着随之会有大量的写入数据的操作，因为 Chunk 在 Writer 真正写入数据的时候才被创建，而在我们的” 追加一次，读取多次” 的工作模式下，Chunk 一旦写入成功之后就会变为只读的了。</li>
<li>如上所述，我们希望把 Chunk 的副本分布在多个机架之间。</li>
</ol>
<p>当 Chunk 的有效副本数量少于用户指定的复制因数（默认为 3 份）的时候，Master 节点会重新复制它（chunk recover）。这可能是由几个原因引起的：一个 Chunk 服务器不可用了，Chunk 服务器报告它所存储的一个副本损坏了，Chunk 服务器的一个磁盘因为错误不可用了，或者 Chunk 副本的复制因数提高了。每个需要被重新复制的 Chunk 都会根据几个因素进行排序（chunk recover priority）。一个因素是 Chunk 现有副本数量和复制因数相差多少。例如，丢失两个副本的 Chunk 比丢失一个副本的 Chunk 有更高的优先级。另外，我们优先重新复制活跃（live）文件的 Chunk 而不是最近刚被删除的文件的 Chunk（查看 4.4 节）。最后，为了最小化失效的 Chunk 对正在运行的应用程序的影响，我们提高的复制优先级会阻塞客户机程序处理流程的 Chunk 的优先级。</p>
<p>Master 节点选择优先级最高的 Chunk，然后命令某个 Chunk 服务器直接从可用的副本” 克隆” 一个副本出来。选择新副本的位置的策略和创建时类似：平衡硬盘使用率、限制同一台 Chunk 服务器上的正在进行的克隆操作的数量、在机架间分布副本。为了防止克隆产生的网络流量大大超过客户机的流量，Master 节点对整个集群和每个 Chunk 服务器上的同时进行的克隆操作的数量都进行了限制。另外，Chunk 服务器通过调节它对源 Chunk 服务器读请求的频率来限制它用于克隆操作的带宽。</p>
<p>最后，Master 服务器周期性地对副本进行重新负载均衡（chunk-rebalance）：它检查当前的副本分布情况，然后移动副本以便更好的利用硬盘空间、更有效的进行负载均衡。而且在这个过程中，Master 服务器逐渐的填满一个<strong>新的</strong> Chunk 服务器，而不是在短时间内用新的 Chunk 填满它，以至于过载。新副本的存储位置选择策略和上面讨论的相同。另外，Master 节点必须选择哪个副本要被移走。通常情况，Master 节点移走那些剩余空间低于平均值的 Chunk 服务器上的副本，从而平衡系统整体的硬盘使用率。</p>
<h2 id="4-4-垃圾回收"><a href="#4-4-垃圾回收" class="headerlink" title="4.4 垃圾回收"></a>4.4 垃圾回收</h2><p>GFS 在文件删除后不会立刻回收可用的物理空间。GFS 空间回收采用惰性的策略，只在文件和 Chunk 级的常规垃圾收集时进行。我们发现这个方法使系统更简单、更可靠。</p>
<h3 id="4-4-1-机制"><a href="#4-4-1-机制" class="headerlink" title="4.4.1 机制"></a>4.4.1 机制</h3><p>当一个文件被应用程序删除时，Master 节点像对待其它修改操作一样，立刻把删除操作以日志的方式记录下来。但是，Master 节点并不马上回收资源，而是把文件名改为一个包含删除时间戳的、隐藏的名字。当 Master 节点对文件系统命名空间做常规扫描的时候，它会删除所有三天前的隐藏文件（这个时间间隔是可以设置的）。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式 “反删除”。当隐藏文件被从名称空间中删除，Master 服务器内存中保存的这个文件的相关元数据才会被删除。这也有效的切断了文件和它包含的所有 Chunk 的连接。</p>
<p>在对 Chunk 名字空间做类似的常规扫描时，Master 节点找到孤立 Chunk（不被任何文件包含的 Chunk）并删除它们的元数据。Chunk 服务器在和 Master 节点交互的心跳信息中，报告它拥有的 Chunk 子集的信息，Master 节点回复 Chunk 服务器哪些 Chunk 在 Master 节点保存的元数据中已经不存在了。Chunk 服务器可以任意删除这些 Chunk 的副本。</p>
<h3 id="4-4-2-讨论"><a href="#4-4-2-讨论" class="headerlink" title="4.4.2 讨论"></a>4.4.2 讨论</h3><p>虽然分布式垃圾回收在编程语言领域是一个需要复杂的方案才能解决的难题，但是在 GFS 系统中是非常简单的。我们可以轻易的得到 Chunk 的所有引用：它们都只存储在 Master 服务器上的文件到块的映射表中。我们也可以很轻易的得到所有 Chunk 的副本：它们都以 Linux 文件的形式存储在 Chunk 服务器的指定目录下。所有 Master 节点不能识别的副本都是” 垃圾”。</p>
<p>垃圾回收在空间回收方面相比直接删除有几个优势。首先，对于组件失效是常态的大规模分布式系统，垃圾回收方式简单可靠。Chunk 可能在某些 Chunk 服务器创建成功，某些 Chunk 服务器上创建失败，失败的副本处于无法被 Master 节点识别的状态，不过没有关系，因为 chunkserver 会主动告知其有哪些 chunk，Master 在发现其没有记录此 chunk 信息后，会告知 chunkserver，chunkserver 接下来就会删除这些重复创建的 chunk 数据。副本删除消息可能丢失，Master 节点必须重新发送失败的删除消息，包括自身的和 Chunk 服务器的元数据。垃圾回收提供了一致的、可靠的清除无用副本的方法。第二，垃圾回收把存储空间的回收操作合并到 Master 节点规律性的后台活动中，比如，例行扫描和与 Chunk 服务器握手等。因此，操作被批量的执行，开销会被分散。另外，垃圾回收在 Master 节点相对空闲的时候完成。这样 Master 节点就可以给那些需要快速反应的客户机请求提供更快捷的响应。第三，延缓存储空间回收为意外的、不可逆转的删除操作提供了安全保障。</p>
<p>根据我们的使用经验，延迟回收空间的主要问题是，延迟回收会阻碍用户调优存储空间的使用，特别是当存储空间比较紧缺的时候。当应用程序重复创建和删除临时文件时，释放的存储空间不能马上重用。我们通过显式的再次删除一个已经被删除的文件的方式加速空间回收的速度。我们允许用户为命名空间的不同部分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的、不可恢复的从文件系统移除。</p>
<h2 id="4-5-过期失效的副本检测"><a href="#4-5-过期失效的副本检测" class="headerlink" title="4. 5 过期失效的副本检测"></a>4. 5 过期失效的副本检测</h2><p>当 Chunk 服务器失效时，Chunk 的副本有可能因错失了一些修改操作而过期失效。Master 节点保存了每个 Chunk 的版本号，用来区分当前的副本和过期副本。</p>
<p>无论何时，只要 Master 节点和 Chunk 签订一个新的租约，它就增加 Chunk 的版本号，然后通知最新的副本。Master 节点和这些副本都把新的版本号记录在它们持久化存储的状态信息中。这个动作发生在任何客户机得到通知以前，因此也是对这个 Chunk 开始写之前。如果某个副本所在的 Chunk 服务器正好处于失效状态，那么副本的版本号就不会被增加。Master 节点在这个 Chunk 服务器重新启动，并且向 Master 节点报告它拥有的 Chunk 的集合以及相应的版本号的时候，就会检测出它包含过期的 Chunk。如果 Master 节点看到一个比它记录的版本号更高的版本号，Master 节点会认为它和 Chunk 服务器签订租约的操作失败了，因此会选择更高的版本号作为当前的版本号。</p>
<p>Master 节点在例行的垃圾回收过程中移除所有的过期失效副本。在此之前，Master 节点在回复客户机的 Chunk 信息请求的时候，简单的认为那些过期的块根本就不存在。另外一重保障措施是，Master 节点在通知客户机哪个 Chunk 服务器持有租约、或者指示 Chunk 服务器从哪个 Chunk 服务器进行克隆时，消息中都附带了 Chunk 的版本号。客户机或者 Chunk 服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。</p>
<h1 id="5-容错和诊断"><a href="#5-容错和诊断" class="headerlink" title="5 容错和诊断"></a>5 容错和诊断</h1><p>我们在设计 GFS 时遇到的最大挑战之一是如何处理频繁发生的组件失效。组件的数量和质量让这些问题出现的频率远远超过一般系统意外发生的频率：我们不能完全依赖机器的稳定性，也不能完全相信硬盘的可靠性。组件的失效可能造成系统不可用，更糟糕的是，还可能产生不完整的数据。我们讨论我们如何面对这些挑战，以及当组件失效不可避免的发生时，用 GFS 自带工具诊断系统故障。</p>
<h2 id="5-1-高可用性"><a href="#5-1-高可用性" class="headerlink" title="5. 1 高可用性"></a>5. 1 高可用性</h2><p>在 GFS 集群的数百个服务器之中，在任何给定的时间必定会有些服务器是不可用的。我们使用两条简单但是有效的策略保证整个系统的高可用性：<strong>快速恢复和复制</strong>。</p>
<h3 id="5-1-1-快速恢复"><a href="#5-1-1-快速恢复" class="headerlink" title="5.1.1 快速恢复"></a>5.1.1 快速恢复</h3><p>不管 Master 服务器和 Chunk 服务器是如何关闭的，它们都被设计为可以在数秒钟内恢复它们的状态并重新启动。事实上，我们并不区分正常关闭和异常关闭；通常，我们通过直接 kill 掉进程来关闭服务器。客户机和其它的服务器会感觉到系统有点颠簸 (a minor hiccup)，正在发出的请求会超时，需要重新连接到重启后的服务器，然后重试这个请求。6.6.2 章节记录了实测的启动时间。</p>
<h3 id="5-1-2-Chunk复制"><a href="#5-1-2-Chunk复制" class="headerlink" title="5.1.2 Chunk复制"></a>5.1.2 Chunk 复制</h3><p>正如之前讨论的，每个 Chunk 都被复制到不同机架上的不同的 Chunk 服务器上。用户可以为文件命名空间的不同部分设定不同的复制级别。缺省是 3。当有 Chunk 服务器离线了，或者通过 Checksum 校验（参考 5.2 节）发现了已经损坏的数据，Master 节点通过克隆已有的副本保证每个 Chunk 都被完整复制（即每个 Chunk 都有复制因子制定的个数个副本，缺省是 3）。虽然 Chunk 复制策略对我们非常有效，但是我们也在寻找其它形式的跨服务器的冗余解决方案，比如使用奇偶校验、或者 Erasure Codes（Erasure Codes 用来解决链接层中不相关的错误，以及网络拥塞和 buffer 限制造成的丢包错误）来解决我们日益增长的只读存储需求。我们的系统主要的工作负载是追加方式的写入和读取操作，很少有随机的写入操作，因此，我们认为在我们这个高度解耦合的系统架构下实现这些复杂的冗余方案很有挑战性，但并非不可实现。</p>
<h3 id="5-1-3-Master服务器的复制"><a href="#5-1-3-Master服务器的复制" class="headerlink" title="5.1.3 Master服务器的复制"></a>5.1.3 Master 服务器的复制</h3><p>为了保证 Master 服务器的可靠性，Master 服务器的状态也要复制。Master 服务器所有的操作日志和 checkpoint 文件都被复制到多台机器上。对 Master 服务器状态的修改操作能够提交成功的前提是，操作日志写入到 Master 服务器的备节点和本机的磁盘（分布式事务）。简单说来，一个 Master 服务进程负责所有的修改操作，包括后台的服务，比如垃圾回收等改变系统内部状态活动。当它失效的时，几乎可以立刻重新启动。如果 Master 进程所在的机器或者磁盘失效了，处于 GFS 系统外部的监控进程会在其它的存有完整操作日志的机器上启动一个新的 Master 进程。客户端使用规范的名字访问 Master（比如 gfs-test）节点，这个名字类似 DNS 别名，因此也就可以在 Master 进程转到别的机器上执行时，通过更改别名的实际指向访问新的 Master 节点。</p>
<p>此外，GFS 中还有些 “影子”（shadow）Master 服务器，这些 “影子” 服务器在 “主” Master 服务器宕机的时候提供文件系统的只读访问。它们是影子，而不是镜像，所以它们的数据可能比 “主” Master 服务器更新要慢，通常是不到 1 秒。对于那些不经常改变的文件、或者那些允许获取的数据有少量过期的应用程序，“影子” Master 服务器能够提高读取的效率。事实上，因为文件内容是从 Chunk 服务器上读取的，因此，应用程序不会发现过期的文件内容。在这个短暂的时间窗内，过期的可能是文件的元数据，比如目录的内容或者访问控制信息。</p>
<p>“影子” Master 服务器为了保持自身状态是最新的，它会读取一份当前正在进行的操作的日志副本，并且依照和主 Master 服务器完全相同的顺序来更改内部的数据结构。和主 Master 服务器一样，“影子” Master 服务器在启动的时候也会从 Chunk 服务器轮询数据（之后定期拉数据），数据中包括了 Chunk 副本的位置信息；“影子” Master 服务器也会定期和 Chunk 服务器 “握手” 来确定它们的状态。在主 Master 服务器因创建和删除副本导致副本位置信息更新时，“影子” Master 服务器才和主 Master 服务器通信来更新自身状态。</p>
<h2 id="5-2-数据完整性"><a href="#5-2-数据完整性" class="headerlink" title="5.2 数据完整性"></a>5.2 数据完整性</h2><p>每个 Chunk 服务器都使用 Checksum 来检查保存的数据是否损坏。考虑到一个 GFS 集群通常都有好几百台机器、几千块硬盘，磁盘损坏导致数据在读写过程中损坏或者丢失是非常常见的（第 7 节讲了一个原因）。我们可以通过别的 Chunk 副本来解决数据损坏问题，但是跨越 Chunk 服务器比较副本来检查数据是否损坏很不实际。另外，GFS 允许有歧义的副本存在：GFS 修改操作的语义，特别是早先讨论过的原子纪录追加的操作，并不保证副本完全相同 (副本不是 byte-wise 完全一致的)。因此，每个 Chunk 服务器必须独立维护 Checksum 来校验自己的副本的完整性。</p>
<p>我们把每个 Chunk 都分成 64KB 大小的块。每个块都对应一个 32 位的 Checksum。和其它元数据一样，Checksum 与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。</p>
<p>对于读操作来说，在把数据返回给客户端或者其它的 Chunk 服务器之前，Chunk 服务器会校验读取操作涉及的范围内的块的 Checksum。因此 Chunk 服务器不会把错误数据传递到其它的机器上。如果发生某个块的 Checksum 不正确，Chunk 服务器返回给请求者一个错误信息，并且通知 Master 服务器这个错误。作为回应，请求者应当从其它副本读取数据，Master 服务器也会从其它副本克隆数据进行恢复。当一个新的副本就绪后，Master 服务器通知副本错误的 Chunk 服务器删掉错误的副本。</p>
<p>Checksum 对读操作的性能影响很小，可以基于几个原因来分析一下。因为大部分的读操作都至少要读取几个块，而我们只需要读取一小部分额外的相关数据进行校验。GFS 客户端代码通过每次把读取操作都对齐在 Checksum block 的边界上，进一步减少了这些额外的读取操作的负面影响。另外，在 Chunk 服务器上，Chunksum 的查找和比较不需要 I/O 操作，Checksum 的计算可以和 I/O 操作同时进行。</p>
<p>Checksum 的计算针对在 Chunk 尾部的追加写入操作作了高度优化（与之对应的是覆盖现有数据的写入操作），因为这类操作在我们的工作中占了很大比例。我们只增量更新最后一个不完整的块的 Checksum，并且用所有的追加来的新 Checksum 块来计算新的 Checksum。即使是最后一个不完整的 Checksum 块已经损坏了，而且我们不能够马上检查出来，由于新的 Checksum 和已有数据不吻合，在下次对这个块进行读取操作的时候，会检查出数据已经损坏了。</p>
<p>相比之下，如果写操作覆盖已经存在的一个范围内的 Chunk，我们必须读取和校验被覆盖的第一个和最后一个块，然后再执行写操作；操作完成之后再重新计算和写入新的 Checksum。如果我们不校验第一个和最后一个被写的块，那么新的 Checksum 可能会隐藏没有被覆盖区域内的数据错误。</p>
<p>在 Chunk 服务器空闲的时候，它会扫描和校验每个不活动的 Chunk 的内容。这使得我们能够发现很少被读取的 Chunk 是否完整。一旦发现有 Chunk 的数据损坏，Master 可以创建一个新的、正确的副本，然后把损坏的副本删除掉。这个机制也避免了非活动的、已损坏的 Chunk 欺骗 Master 节点，使 Master 节点认为它们已经有了足够多的副本了。</p>
<h2 id="5-3-诊断工具"><a href="#5-3-诊断工具" class="headerlink" title="5.3 诊断工具"></a>5.3 诊断工具</h2><p>详尽的、深入细节的<strong>诊断日志</strong>，在问题隔离、调试、以及性能分析等方面给我们带来无法估量的帮助，同时也只需要很小的开销。没有日志的帮助，我们很难理解短暂的、不重复的机器之间的消息交互。GFS 的服务器会产生大量的日志，记录了大量关键的事件（比如，Chunk 服务器启动和关闭）以及所有的 RPC 的请求和回复。这些诊断日志可以随意删除，对系统的正确运行不造成任何影响。然而，我们在存储空间允许的情况下会尽量的保存这些日志。</p>
<p>RPC 日志包含了网络上发生的所有请求和响应的详细记录，但是不包括读写的文件数据。通过匹配请求与回应，以及收集不同机器上的 RPC 日志记录，我们可以重演所有的消息交互来诊断问题。日志还用来跟踪负载测试和性能分析。</p>
<p>日志对性能的影响很小（远小于它带来的好处），因为这些日志的写入方式是顺序的、异步的。最近发生的事件日志保存在内存中，可用于持续不断的在线监控。</p>
<h1 id="6-度量"><a href="#6-度量" class="headerlink" title="6 度量"></a>6 度量</h1><p>本节中，我们将使用一些小规模基准测试来展现 GFS 系统架构和实现上的一些固有瓶颈，还有些来自 Google 内部使用的真实的 GFS 集群的基准数据。</p>
<h2 id="6-1-小规模基准测试"><a href="#6-1-小规模基准测试" class="headerlink" title="6.1 小规模基准测试"></a>6.1 小规模基准测试</h2><p>我们在一个包含 1 台 Master 服务器，2 台 Master 服务器复制节点，16 台 Chunk 服务器和 16 个客户机组成的 GFS 集群上测量性能。注意，采用这样的集群配置方案只是为了易于测试。典型的 GFS 集群有数百个 Chunk 服务器和数百个客户机。</p>
<p>所有机器的配置都一样：两个 PIII 1.4GHz 处理器，2GB 内存，两个 80G/5400rpm 的硬盘，以及 100Mbps 全双工以太网连接到一个 HP2524 交换机。GFS 集群中所有的 19 台服务器都连接在一个交换机，所有 16 台客户机连接到另一个交换机上。两个交换机之间使用 1Gbps 的线路连接。</p>
<h3 id="6-1-1-读取"><a href="#6-1-1-读取" class="headerlink" title="6.1.1 读取"></a>6.1.1 读取</h3><p>N 个客户机从 GFS 文件系统同步读取数据。每个客户机从 320GB 的文件集合中随机读取 4MB region 的内容。读取操作重复执行 256 次，因此，每个客户机最终都读取 1GB 的数据。所有的 Chunk 服务器加起来总共只有 32GB 的内存，因此，我们预期只有最多 10% 的读取请求命中 Linux 的文件系统缓冲。我们的测试结果应该和一个在没有文件系统缓存的情况下读取测试的结果接近。</p>
<p><img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220810223510134.png" alt="image-20220810223510134"></p>
<p>图三：合计吞吐量。上边的曲线显示了我们网络拓扑下的合计理论吞吐量上限。下边的曲线显示了观测到的吞吐量。这个曲线有着 95% 的可靠性，因为有时候测量会不够精确。</p>
<p>图 3（a）显示了 N 个客户机整体的读取速度以及这个速度的理论极限。当连接两个交换机的 1Gbps 的链路饱和时，整体读取速度达到理论的极限值是 125MB/S，或者说每个客户机配置的 100Mbps 网卡达到饱和时，每个客户机读取速度的理论极限值是 12.5MB/s。实测结果是，当一个客户机读取的时候，读取的速度是 10MB/s，也就是说达到客户机理论读取速度极限值的 80%。对于 16 个客户机，整体的读取速度达到了 94MB/s，大约是理论整体读取速度极限值的 75%，也就是说每个客户机的读取速度是 6MB/s。读取效率从 80% 降低到了 75%，主要的原因是当读取的客户机增加时，多个客户机同时读取一个 Chunk 服务器的几率也增加了，导致整体的读取效率下降。</p>
<h3 id="6-1-2-写入"><a href="#6-1-2-写入" class="headerlink" title="6.1.2 写入"></a>6.1.2 写入</h3><p>N 个客户机同时向 N 个不同的文件中写入数据。每个客户机以每次 1MB 的速度连续写入 1GB 的数据。图 3（b）显示了整体的写入速度和它们理论上的极限值。理论上的极限值是 67MB/s，因为我们需要把每一 byte 写入到 16 个 Chunk 服务器中的 3 个上，而每个 Chunk 服务器的输入连接速度是 12.5MB/s。</p>
<p>一个客户机的写入速度是 6.3MB/s，大概是理论极限值的一半。导致这个结果的主要原因是我们的网络协议栈。它与我们推送数据到 Chunk 服务器时采用的管道模式不相适应。从一个副本到另一个副本的数据传输延迟降低了整个的写入速度。</p>
<p>16 个客户机整体的写入速度达到了 35MB/s（即每个客户机 2.2MB/s），大约只是理论极限值的一半。和多个客户机读取的情形很类型，随着客户机数量的增加，多个客户机同时写入同一个 Chunk 服务器的几率也增加了。而且，16 个客户机并行写入可能引起的冲突比 16 个客户机并行读取要大得多，因为每个写入都会涉及三个不同的副本。</p>
<p>写入的速度比我们想象的要慢。在实际应用中，这没有成为我们的主要问题，因为即使在单个客户机上能够感受到延时，它也不会在有大量客户机的时候对整体的写入带宽造成显著的影响。</p>
<h3 id="6-1-3-记录追加"><a href="#6-1-3-记录追加" class="headerlink" title="6.1.3 记录追加"></a>6.1.3 记录追加</h3><p>图 3（c）显示了记录追加操作的性能。N 个客户机同时追加数据到一个文件。记录追加操作的性能受限于保存文件最后一个 Chunk 的 Chunk 服务器的带宽，而与客户机的数量无关。记录追加的速度由一个客户机的 6.0MB/s 开始，下降到 16 个客户机的 4.8MB/s 为止，速度的下降主要是由于不同客户端的网络拥塞以及网络传输速度的不同而导致的。</p>
<p>我们的程序倾向于同时处理多个这样的文件。换句话说，即 N 个客户机同时追加数据到 M 个共享文件中，这里 N 和 M 都是数十或者数百以上。所以，在我们的实际应用中，Chunk 服务器的网络拥塞并没有成为一个严重问题，如果 Chunk 服务器的某个文件正在写入，客户机会去写另外一个文件。</p>
<h2 id="6-2-实际应用中的集群"><a href="#6-2-实际应用中的集群" class="headerlink" title="6.2 实际应用中的集群"></a>6.2 实际应用中的集群</h2><p>我们现在来仔细评估一下 Google 内部正在使用的两个集群，它们具有一定的代表性。</p>
<ul>
<li><strong>集群 A</strong> 通常被上百个工程师用于研究和开发。典型的任务是被人工初始化后连续运行数个小时。它通常读取数 MB 到数 TB 的数据，之后进行转化或者分析，最后把结果写回到集群中。</li>
<li><strong>集群 B</strong> 主要用于处理当前的生产数据。集群 B 的任务持续的时间更长，在很少人工干预的情况下，持续的生成和处理数 TB 的数据集。</li>
</ul>
<p>在这两个案例中，一个单独的” 任务” 都是指运行在多个机器上的多个进程，它们同时读取和写入多个文件。下表显示了这两个集群的相关特性：</p>
<img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220810231106599.png" alt="image-20220810231106599" style="zoom:67%;">

<h3 id="6-2-1-存储"><a href="#6-2-1-存储" class="headerlink" title="6.2.1 存储"></a>6.2.1 存储</h3><p>如上表前五行所描述的，两个集群都由上百台 Chunk 服务器组成，支持数 TB 的硬盘空间；两个集群虽然都存储了大量的数据，但是还有剩余的空间。“已用空间（Used disk space）” 包含了所有的 Chunk 副本。实际上所有的文件都复制了三份。因此，集群实际上各存储了 18TB 和 52TB 的文件数据。</p>
<p>两个集群存储的文件数量都差不多，但是集群 B 上有大量的死文件。所谓 “死文件” 是指文件被删除了或者是被新版本的文件替换了，但是存储空间还没有来得及被回收。由于集群 B 存储的文件较大，因此它的 Chunk 数量也比较多。</p>
<h3 id="6-2-2-元数据"><a href="#6-2-2-元数据" class="headerlink" title="6.2.2 元数据"></a>6.2.2 元数据</h3><p>Chunk 服务器总共保存了十几 GB 的元数据，大多数是来自用户数据的 64KB 大小的块的 Checksum。保存在 Chunk 服务器上其它的元数据是 Chunk 的版本号信息，我们在 4.5 节描述过。</p>
<p>在 Master 服务器上保存的元数据就小的多了，大约只有数十 MB，或者说平均每个文件 100 字节的元数据。这和我们设想的是一样的，Master 服务器的内存大小在实际应用中并不会成为 GFS 系统容量的瓶颈。大多数文件的元数据都是以前缀压缩模式存放的文件名。Master 服务器上存放的其它元数据包括了文件的所有者和权限、文件到 Chunk 的映射关系，以及每一个 Chunk 的当前版本号。此外，针对每一个 Chunk，我们都保存了当前的副本位置以及对它的引用计数，这个引用计数用于实现写时拷贝（即 COW，copy-on-write）。</p>
<p>对于每一个单独的服务器，无论是 Chunk 服务器还是 Master 服务器，都只保存了 50MB 到 100MB 的元数据。因此，恢复服务器是非常快速的：在服务器响应客户请求之前，只需要花几秒钟时间从磁盘上读取这些数据就可以了。不过，Master 服务器会持续颠簸一段时间–通常是 30 到 60 秒–直到它完成轮询所有的 Chunk 服务器，并获取到所有 Chunk 的位置信息。</p>
<h3 id="6-2-3-读写速率"><a href="#6-2-3-读写速率" class="headerlink" title="6.2.3 读写速率"></a>6.2.3 读写速率</h3><img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220810231744563.png" alt="image-20220810231744563" style="zoom:67%;">

<p>表三显示了不同时段的读写速率。在测试的时候，这两个集群都运行了一周左右的时间。（这两个集群最近都因为升级新版本的 GFS 重新启动过了）。</p>
<p>集群重新启动后，平均写入速率小于 30MB/s。当我们提取性能数据的时候，集群 B 正进行大量的写入操作，写入速度达到了 100MB/s，并且因为每个 Chunk 都有三个副本的原因，网络负载达到了 300MB/s。读取速率要比写入速率高的多。正如我们设想的那样，总的工作负载中，读取的比例远远高于写入的比例。两个集群都进行着繁重的读取操作。特别是，集群 A 在一周时间内都维持了 580MB/s 的读取速度。集群 A 的网络配置可以支持 750MB/s 的速度，显然，它有效的利用了资源。集群 B 支持的峰值读取速度是 1300MB/s，但是它的应用只用到了 380MB/s。</p>
<h3 id="6-2-4-元数据服务器的负载"><a href="#6-2-4-元数据服务器的负载" class="headerlink" title="6.2.4 元数据服务器的负载"></a>6.2.4 元数据服务器的负载</h3><p>表三的数据显示了发送到 Master 服务器的操作请求大概是每秒钟 200 到 500 个。Master 服务器可以轻松的应付这个请求速度，所以 Master 服务器的处理能力不是系统的瓶颈。</p>
<p>在早期版本的 GFS 中，Master 服务器偶尔会成为瓶颈。它大多数时间里都在顺序扫描某个很大的目录（包含数万个文件）去查找某个特定的文件。因此我们修改了 Master 服务器的数据结构，通过对名字空间进行二分查找来提高效率。现在 Master 服务器可以轻松的每秒钟进行数千次文件访问。如果有需要的话，我们可以通过在名称空间数据结构之前设置名称查询缓冲的方式进一步提高速度。</p>
<h3 id="6-2-5-恢复时间"><a href="#6-2-5-恢复时间" class="headerlink" title="6.2.5 恢复时间"></a>6.2.5 恢复时间</h3><p>当某个 Chunk 服务器失效了，一些 Chunk 副本的数量可能会低于复制因子指定的数量，我们必须通过克隆副本使 Chunk 副本数量达到复制因子指定的数量。恢复所有 Chunk 副本所花费的时间取决于资源的数量。在我们的试验中，我们把集群 B 上的一个 Chunk 服务器 Kill 掉。这个 Chunk 服务器上大约有 15000 个 Chunk，共计 600GB 的数据。为了减小克隆操作对正在运行的应用程序的影响，以及为 GFS 调度决策提供修正空间，我们缺省的把集群中并发克隆操作的数量设置为 91 个（Chunk 服务器的数量的 40%），每个克隆操作最多允许使用的带宽是 6.25MB/s（50mbps）。所有的 Chunk 在 23.2 分钟内恢复了，复制的速度高达 440MB/s。</p>
<p>在另外一个测试中，我们 Kill 掉了两个 Chunk 服务器，每个 Chunk 服务器大约有 16000 个 Chunk，共计 660GB 的数据。这两个故障导致了 266 个 Chunk 只有单个副本。这 266 个 Chunk 被 GFS 优先调度进行复制，在 2 分钟内恢复到至少有两个副本；现在集群被带入到另外一个状态，在这个状态下，系统可以容忍另外一个 Chunk 服务器失效而不丢失数据。</p>
<h2 id="6-3-工作负载分析（Workload-Breakdown）"><a href="#6-3-工作负载分析（Workload-Breakdown）" class="headerlink" title="6.3 工作负载分析（Workload Breakdown）"></a>6.3 工作负载分析（Workload Breakdown）</h2><p>本节中，我们展示了对两个 GFS 集群工作负载情况的详细分析，这两个集群和 6.2 节中的类似，但是不完全相同。集群 X 用于研究和开发，集群 Y 用于生产数据处理。</p>
<h3 id="6-3-1-方法论和注意事项"><a href="#6-3-1-方法论和注意事项" class="headerlink" title="6.3.1 方法论和注意事项"></a>6.3.1 方法论和注意事项</h3><p>本章节列出的这些结果数据只包括客户机发起的原始请求，因此，这些结果能够反映我们的应用程序对 GFS 文件系统产生的全部工作负载。它们不包含那些为了实现客户端请求而在服务器间交互的请求，也不包含 GFS 内部的后台活动相关的请求，比如前向转发的写操作，或者重新负载均衡等操作。</p>
<p>我们从 GFS 服务器记录的真实的 RPC 请求日志中推导重建出关于 IO 操作的统计信息。例如，GFS 客户程序可能会把一个读操作分成几个 RPC 请求来提高并行度，我们可以通过这些 RPC 请求推导出原始的读操作。因为我们的访问模式是高度程式化，所以我们认为任何不符合的数据都是误差。应用程序如果能够记录更详尽的日志，就有可能提供更准确的诊断数据；但是为了这个目的去重新编译和重新启动数千个正在运行的客户机是不现实的，而且从那么多客户机上收集结果也是个繁重的工作。</p>
<p>应该避免从我们的工作负荷数据中过度的归纳出普遍的结论 (即，不要把本节的数据作为基础的指导性数据)。因为 Google 完全控制着 GFS 和使用 GFS 的应用程序，所以，应用程序都针对 GFS 做了优化，同时，GFS 也是为了这些应用程序而设计的。这样的相互作用也可能存在于一般程序和文件系统中，但是在我们的案例中这样的作用影响可能更显著。</p>
<h3 id="6-3-2-Chunk服务器工作负载"><a href="#6-3-2-Chunk服务器工作负载" class="headerlink" title="6.3.2 Chunk服务器工作负载"></a>6.3.2 Chunk 服务器工作负载</h3><img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220810232957574.png" alt="image-20220810232957574" style="zoom:67%;">

<p>表四：操作负载百分比细目。对于读操作，大小是实际读取的数据和传送的数据，而不是实际的请求量。</p>
<p>表四 显示了操作<strong>次数</strong>的大小分布。读操作的大小呈现双峰分布，如下：</p>
<ul>
<li><strong>小读取</strong>：读取大小限制在 <code>(0,64KB)</code> 在大文件中查找小数据片段；</li>
<li><strong>大读取</strong>：读取大小限制在 <code>(512KB,∞)</code> 对整个文件的长时间连续读取；</li>
</ul>
<blockquote>
<p>但是可见小读取的占比还是远远大于大读取的占比。</p>
</blockquote>
<p>GFS 系统一个常见的使用方式就是当做生产 - 消费者队列，生产者并发地给一个文件追加内容，而消费者负责读取文件末尾数据。当消费速度大于生产速度时，读操作就不会返回任何数据。因此对于长期执行任务的 Cluster Y 来说，就存在大量读取不返回任何数据。对于短期执行数据分析任务的 Cluster X 就很少出现这种情况。</p>
<p>写入大小也呈现双峰分布：</p>
<ul>
<li>较大的写操作：较大的写操作 (超过 256kb) 通常是由写入器中的大量缓冲造成的。</li>
<li>较小的写操作：写入器缓冲更少的数据、更频繁的检查点或同步，或者为较小的写操作 (小于 64 KB) 生成更少的数据帐户。</li>
</ul>
<p>至于记录追加，集群 Y 比集群 X 存在更多的大型记录追加操作，因为我们为集群 Y 的生产系统进行了调优。</p>
<img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220810233947082.png" alt="image-20220810233947082" style="zoom: 67%;">

<p>表五 显示了在不同规模的操作中传输的<strong>数据总量</strong>，有如下的特点：表四 中体现了大数据量的读、写、append 操作次数占比不大，但是表 5 体现了在字节量上看，大数据量的操作还是占比最大。</p>
<h3 id="6-3-3-记录追加-vs-写操作"><a href="#6-3-3-记录追加-vs-写操作" class="headerlink" title="6.3.3 记录追加 vs 写操作"></a>6.3.3 记录追加 vs 写操作</h3><p>记录追加操作在我们的生产系统中大量使用。对于集群 X，记录追加操作和普通写操作的比例按照字节比是 108:1，按照操作次数比是 8:1。对于作为我们的生产系统的集群 Y 来说，这两个比例分别是 3.7:1 和 2.5:1。更进一步，这一组数据说明在我们的两个集群上，记录追加操作所占比例都要比写操作要大。对于集群 X，在整个测量过程中，记录追加操作所占比率都比较低，因此结果会受到一两个使用某些特定大小的 buffer 的应用程序的影响。</p>
<p>如同我们所预期的，我们的数据修改操作<strong>主要是记录追加操作</strong>而不是覆盖方式的写操作。我们测量了第一个副本的数据覆盖写的情况。这近似于一个客户机故意覆盖刚刚写入的数据，而不是增加新的数据。对于集群 X，覆盖写操作在写操作所占据字节上的比例小于 0.0001%，在所占据操作数量上的比例小于 0.0003%。对于集群 Y，这两个比率都是 0.05%。虽然这只是某一片断的情况，但是仍然高于我们的预期。这是由于这些覆盖写的操作，大部分是由于客户端在发生错误或者超时以后重试的情况。这在本质上应该不算作工作负荷的一部分，而是重试机制产生的结果。</p>
<h3 id="6-3-4-Master工作负载"><a href="#6-3-4-Master工作负载" class="headerlink" title="6.3.4 Master工作负载"></a>6.3.4 Master 工作负载</h3><img src="/2022/08/08/The-Google-File-System%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3/image-20220810234543068.png" alt="image-20220810234543068" style="zoom:67%;">

<p>表六 显示了 Master 服务器上的请求按类型区分的明细表。大部分的请求都是读取操作查询 Chunk 位置信息（FindLocation）、以及修改操作查询 lease 持有者的信息（FindLease-Locker）。</p>
<p>集群 X 和 Y 在删除请求的数量上有着明显的不同，因为集群 Y 存储了生产数据，一般会重新生成数据以及用新版本的数据替换旧有的数据。数量上的差异也被隐藏在了 Open 请求中，因为旧版本的文件可能在以重新写入的模式打开时，隐式的被删除了（类似 UNIX 的 open 函数中的 “w” 模式）。</p>
<p>FindMatchingFiles 是一个模式匹配请求，支持 “ls” 以及其它类似的文件系统操作。不同于 Master 服务器的其它请求，它可能会检索 namespace 的大部分内容，因此是非常昂贵的操作。集群 Y 的这类请求要多一些，因为自动化数据处理的任务进程需要检查文件系统的各个部分，以便从全局上了解应用程序的状态。与之不同的是，集群 X 的应用程序更加倾向于由单独的用户控制，通常预先知道自己所需要使用的全部文件的名称。</p>
<h1 id="7-经验"><a href="#7-经验" class="headerlink" title="7 经验"></a>7 经验</h1><p>在建造和部署 GFS 的过程中，我们经历了各种各样的问题，有些是操作上的，有些是技术上的。</p>
<p>起初，GFS 被设想为我们的生产系统的后端文件系统。随着时间推移，在 GFS 的使用中逐步的增加了对研究和开发任务的支持。我们开始增加一些小的功能，比如权限和配额，到了现在，GFS 已经初步支持了这些功能。虽然我们生产系统是严格受控的，但是用户层却不总是这样的。需要更多的基础架构来防止用户间的相互干扰。</p>
<p>我们最大的问题是磁盘以及和 Linux 相关的。很多磁盘都声称它们支持某个范围内的 Linux IDE 硬盘驱动程序，但是实际应用中反映出来的情况却不是这样，它们只支持最新的驱动。因为协议版本很接近，所以大部分磁盘都可以用，但是偶尔也会有由于协议不匹配，导致驱动和内核对于驱动器的状态判断失误。这会导致数据因为内核中的问题意外的被破坏了。这个问题促使我们使用 Checksum 来校验数据，同时我们也修改内核来处理这些因为协议不匹配带来的问题。</p>
<p>较早的时候，我们在使用 Linux 2.2 内核时遇到了些问题，主要是 <code>fsync()</code> 的效率问题。它的效率与文件的大小而不是文件修改部分的大小有关。这在我们的操作日志文件过大时给出了难题，尤其是在我们尚未实现 Checkpoint 的时候。我们费了很大的力气用同步写来解决这个问题，但是最后还是移植到了 Linux2.4 内核上。</p>
<p>另一个和 Linux 相关的问题是单个读写锁的问题，也就是说，在某一个地址空间的任意一个线程都必须在从磁盘 <code>page in（读锁）</code>的时候先 hold 住，或者在 <code>mmap()</code> 调用（写锁）的时候改写地址空间。我们发现即使我们的系统负载很轻的情况下也会有偶尔的超时，我们花费了很多的精力去查找资源的瓶颈或者硬件的问题。最后我们终于发现这个单个锁在磁盘线程交换以前映射的数据到磁盘的时候，锁住了当前的网络线程，阻止它把新数据映射到内存。由于我们的性能主要受限于网络接口，而不是内存 <code>copy</code> 的带宽，因此，我们用 <code>pread()</code> 替代 <code>mmap()</code>，用了一个额外的 <code>copy</code> 动作来解决这个问题。</p>
<p>尽管偶尔还是有其它的问题，Linux 的开放源代码还是使我们能够快速探究和理解系统的行为。在适当的时候，我们会改进内核并且和公开源码组织共享这些改动。</p>
<h1 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8 相关工作"></a>8 相关工作</h1><p>和其它的大型分布式文件系统，比如 <code>AFS</code> 类似，GFS 提供了一个与位置无关的名字空间，这使得数据可以为了负载均衡或者灾难冗余等目的在不同位置透明的迁移。不同于 <code>AFS</code> 的是，GFS 把文件分布存储到不同的服务器上，这种方式更类似 <code>Xfs</code> 和 <code>Swift</code>，这是为了提高整体性能以及灾难冗余的能力。</p>
<p>由于磁盘相对来说比较便宜，并且复制的方式比 <code>RAID</code> 方法简单的多，GFS 目前只使用复制的方式来进行冗余，因此要比 <code>Xfs</code> 或者 <code>Swift</code> 占用更多的裸存储空间。</p>
<p>与 <code>AFS、Xfs、Frangipani</code> 以及 <code>Intermezzo</code> 等文件系统不同的是，GFS 并没有在文件系统层面提供任何 Cache 机制。我们主要的工作在单个应用程序执行的时候几乎不会重复读取数据，因为它们的工作方式要么是流式的读取一个大型的数据集，要么是在大型的数据集中随机 Seek 到某个位置，之后每次读取少量的数据。</p>
<p>某些分布式文件系统，比如 <code>Frangipani、Xfs、Minnesota’s GFS、GPFS</code>，去掉了中心服务器，只依赖于分布式算法来保证一致性和可管理性。我们选择了中心服务器的方法，目的是为了简化设计，增加可靠性，能够灵活扩展。特别值得一提的是，由于处于中心位置的 Master 服务器保存有几乎所有的 Chunk 相关信息，并且控制着 Chunk 的所有更新，因此，它极大地简化了原本非常复杂的 Chunk 分配和复制策略的实现方法。我们通过减少 Master 服务器保存的状态信息的数量，以及将 Master 服务器的状态复制到其它节点来保证系统的灾难冗余能力。扩展能力和高可用性（对于读取）目前是通过我们的影子 Master 服务器机制来保证的。对 Master 服务器状态更改是通过预写日志的方式实现持久化。为此，我们可以调整为使用类似 <code>Harp</code> 中的 <code>primary-copy</code> 方案，从而提供比我们现在的方案更严格的一致性保证。</p>
<p>我们解决了一个难题，这个难题类似 <code>Lustre</code> 在如何在有大量客户端时保障系统整体性能遇到的问题。不过，我们通过只关注我们的应用程序的需求，而不是提供一个兼容 POSIX 的文件系统，从而达到了简化问题的目的。此外，GFS 设计预期是使用大量的不可靠节点组建集群，因此，<strong>灾难冗余</strong>方案是我们设计的核心。</p>
<p>GFS 很类似 <code>NASD</code> 架构。<code>NASD</code> 架构是基于网络磁盘的，而 GFS 使用的是普通计算机作为 Chunk 服务器，就像 <code>NASD</code> 原形中方案一样。所不同的是，我们的 Chunk 服务器采用惰性分配固定大小的 Chunk 的方式，而不是分配变长的对象存储空间。此外，GFS 实现了诸如重新负载均衡、复制、恢复机制等等在生产环境中需要的特性。</p>
<p>不同于与 <code>Minnesota’s GFS</code> 和 <code>NASD</code>，我们并不改变存储设备的 Model（？）。我们只关注用普通的设备来解决非常复杂的分布式系统日常的数据处理。</p>
<p>我们通过原子的记录追加操作实现了生产者 - 消费者队列，这个问题类似 <code>River</code> 中的分布式队列。<code>River</code> 使用的是跨主机的、基于内存的分布式队列，为了实现这个队列，必须仔细控制数据流；而 GFS 采用可以被生产者并发追加记录的持久化的文件的方式实现。River 模式支持 m - 到 - n 的分布式队列，但是缺少由持久化存储提供的容错机制，GFS 只支持 m - 到 - 1 的队列。多个消费者可以同时读取一个文件，但是它们输入流的区间必须是对齐的。</p>
<h1 id="9-结束语"><a href="#9-结束语" class="headerlink" title="9 结束语"></a>9 结束语</h1><p>Google 文件系统展示了一个使用普通硬件支持大规模数据处理的系统的特质。虽然一些设计要点都是针对我们的特殊的需要定制的，但是还是有很多特性适用于类似规模的和成本的数据处理任务。</p>
<p>首先，我们根据我们当前的和可预期的将来的应用规模和技术环境来评估传统的文件系统的特性。我们的评估结果将我们引导到一个使用完全不同于传统的设计思路上。根据我们的设计思路，我们认为组件失效是常态而不是异常，针对采用追加方式（有可能是并发追加）写入、然后再读取（通常序列化读取）的大文件进行优化，以及扩展标准文件系统接口、放松接口限制来改进整个系统。</p>
<p>我们系统通过持续监控，复制关键数据，快速和自动恢复提供灾难冗余。Chunk 复制使得我们可以对 Chunk 服务器的失效进行容错。高频率的组件失效要求系统具备在线修复机制，能够周期性的、透明的修复损坏的数据，也能够第一时间重新建立丢失的副本。此外，我们使用 Checksum 在磁盘或者 IDE 子系统级别检测数据损坏，在这样磁盘数量惊人的大系统中，损坏率是相当高的。</p>
<p>我们的设计保证了在有大量的并发读写操作时能够提供很高的合计吞吐量。我们通过分离控制流和数据流来实现这个目标，控制流在 Master 服务器处理，而数据流在 Chunk 服务器和客户端处理。当一般的操作涉及到 Master 服务器时，由于 GFS 选择的 Chunk 尺寸较大 (从而减小了元数据的大小)，以及通过 Chunk Lease 将控制权限移交给主副本，这些措施将 Master 服务器的负担降到最低。这使得一个简单、中心的 Master 不会成为成为瓶颈。我们相信我们对网络协议栈的优化可以提升当前对于每客户端的写入吞吐量限制。</p>
<p>GFS 成功的实现了我们对存储的需求，在 Google 内部，无论是作为研究和开发的存储平台，还是作为生产系统的数据处理平台，都得到了广泛的应用。它是我们持续创新和处理整个 WEB 范围内的难题的一个重要工具。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf">The Google File System</a></li>
<li><a href="https://niceaz.com/2019/03/24/gfs/">GFS 阅读总结</a></li>
<li><a href="https://juejin.cn/post/6964671364745658376">GFS 论文阅读笔记</a></li>
<li><a href="http://nil.csail.mit.edu/6.824/2020/notes/l-gfs.txt">讲义</a></li>
<li><a href="http://nil.csail.mit.edu/6.824/2020/video/3.html">视频</a></li>
<li><a href="https://spongecaptain.cool/post/paper/googlefilesystem/">Google File System-GFS 论文阅读</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/distributed-filesystem-comparison/">分布式文件系统架构对比</a></li>
</ul>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>存储</tag>
        <tag>GFS</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器详解</title>
    <url>/2023/05/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-什么是布隆过滤器"><a href="#1-什么是布隆过滤器" class="headerlink" title="1 什么是布隆过滤器"></a>1 什么是布隆过滤器</h1><p>布隆过滤器 (BloomFilter) 是 1970 布隆<code>（Burton Howard Bloom ）</code>提出的，它是一种节省空间（space efficient）的概率性数据结构，为一个很长的二进制向量，主要<strong>用于判断一个元素是否在一个集合中</strong>。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<p>在程序的世界中，布隆过滤器是程序员的一把利器，利用它可以快速地解决项目中一些比较棘手的问题。如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>其实跟缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，而缓存击穿是一个热点的 Key，有大并发集中对其进行访问，突然间这个 Key 失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>我们使用 Redis 大部分情况都是通过 Key 查询对应的值，假如发送的请求传进来的 key 是不存在 Redis 中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像 “穿透” 了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。</p>
<h1 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2 基本原理"></a>2 基本原理</h1><img src="/2023/05/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220807202018105.png" alt="image-20220807202018105" style="zoom:50%;">

<p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>对一个值进行查询时：</p>
<ol>
<li>对待查询值再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值<strong>可能</strong>在布隆过滤器中，如果存在一个值不为 1，说明该元素<strong>一定</strong>不在布隆过滤器中。</li>
</ol>
<p>因为对于不同的字符串可能得到相同的 hash 值，所以存在概率性的误报。此种情况可以通过增加数组的大小或者调整更好的 hash 函数来提高过滤器的准确率。</p>
<blockquote>
<p>如图：位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。</p>
</blockquote>
<h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h1><h2 id="手动java实现"><a href="#手动java实现" class="headerlink" title="手动java实现"></a>手动 java 实现</h2><p>通过以上介绍可知，布隆过滤器需要具备以下特性：</p>
<ul>
<li>一个合适大小的位数组保存数据；</li>
<li>几个不同的 hash 函数；</li>
<li>添加元素到位数组的方法实践；</li>
<li>判断元素是否存在于位数组的方法实践；</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> BloomFilter.java, v 0.1 2022年08月07日 20:32 mark</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>          <span class="variable">DEFAULT_SIZE</span> <span class="operator">=</span> <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过这个数组可以创建 6 个不同的哈希函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[]        SEEDS        = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">3</span>, <span class="number">13</span>, <span class="number">46</span>, <span class="number">71</span>, <span class="number">91</span>, <span class="number">134</span>};</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组。数组中的元素只能是 0 或者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>        <span class="type">BitSet</span>       <span class="variable">bits</span>         <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(DEFAULT_SIZE);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放包含 hash 函数的类的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>        SimpleHash[] func         = <span class="keyword">new</span> <span class="title class_">SimpleHash</span>[SEEDS.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 初始化多个不同的 Hash 函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SEEDS.length; i++) {</span><br><span class="line">            func[i] = <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(DEFAULT_SIZE, SEEDS[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object value)</span> {</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) {</span><br><span class="line">            bits.set(f.hash(value), <span class="literal">true</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断指定元素是否存在于位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object value)</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) {</span><br><span class="line">            ret = ret &amp;&amp; bits.get(f.hash(value));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类。用于 hash 操作！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleHash</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> seed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SimpleHash</span><span class="params">(<span class="type">int</span> cap, <span class="type">int</span> seed)</span> {</span><br><span class="line">            <span class="built_in">this</span>.cap = cap;</span><br><span class="line">            <span class="built_in">this</span>.seed = seed;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 hash 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object value)</span> {</span><br><span class="line">            <span class="type">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (value == <span class="literal">null</span>) ? <span class="number">0</span> : Math.abs(seed * (cap - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="number">13423</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">22131</span>;</span><br><span class="line">        <span class="type">BloomFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BloomFilter</span>();</span><br><span class="line">        System.out.println(filter.contains(value1));</span><br><span class="line">        System.out.println(filter.contains(value2));</span><br><span class="line">        filter.add(value1);</span><br><span class="line">        filter.add(value2);</span><br><span class="line">        System.out.println(filter.contains(value1));</span><br><span class="line">        System.out.println(filter.contains(value2));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Google开源Guava实现"><a href="#Google开源Guava实现" class="headerlink" title="Google开源Guava实现"></a>Google 开源 Guava 实现</h2><p>日常项目中可以使用 Guava 实现的过滤器布隆过滤器</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;XXXX&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">    Funnels.integerFunnel(),</span><br><span class="line">    <span class="number">1500</span>,</span><br><span class="line">    <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">filter.put(<span class="number">1</span>);</span><br><span class="line">filter.put(<span class="number">2</span>);</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>当 <code>mightContain()</code> 方法返回 <em>true</em> 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 <em>false</em> 时，我们可以 100％确定该元素不存在于过滤器中。</p>
<blockquote>
<p>缺陷: </p>
<p>只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了</p>
</blockquote>
<h2 id="Redis中的过滤器"><a href="#Redis中的过滤器" class="headerlink" title="Redis中的过滤器"></a>Redis 中的过滤器</h2><p> TODO</p>
<h1 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4 使用场景"></a>4 使用场景</h1><ol>
<li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等；</li>
<li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重；</li>
<li>spark 的 jion 操作中 <code>Runtime Filter</code> 的过滤原理实现；</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；</li>
</ol>
<h1 id="5-后续探讨"><a href="#5-后续探讨" class="headerlink" title="5 后续探讨"></a>5 后续探讨</h1><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>因为布隆过滤器的不可逆，我们没法重新建一个更大的布隆过滤器然后去把数据重新导入。可以采取的扩容的方法是，保留原有的布隆过滤器，建立一个更大的，新增数据都放在新的布隆过滤器中，去重的时候检查所有的布隆过滤器。用一个新的布隆过滤器和多个老的布隆过滤器共同组成一个新的过滤器，提供相同的接口。</p>
<h2 id="删除值"><a href="#删除值" class="headerlink" title="删除值"></a>删除值</h2><p>由于判断某个元素在 bloom filter 是否存在是个概率问题，所以导致布隆过滤器不容易删除一个值。可以通过布隆过滤器的变体 CBF (Counting BloomFilter) 来解决。</p>
<p>CBF 将标准 Bloom Filter 位数组的每一位扩展为一个小的计数器（Counter），在插入元素时给对应的 k（k 为哈希函数个数）个 Counter 的值分别加 1，删除元素时给对应的 k 个 Counter 的值分别减 1。Counting Bloom Filter 通过多占用几倍的存储空间的代价，给 Bloom Filter 增加了删除操作。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/346651831">缓存雪崩、缓存击穿、缓存穿透</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/cs-basics/data-structure/bloom-filter.md">布隆过滤器</a></li>
<li><a href="https://segmentfault.com/a/1190000040502512">如何抗住亿级流量之布隆过滤器</a></li>
<li><a href="https://blog.csdn.net/jiangnan2014/article/details/53735429">Java 中 BitSet 的使用及详解</a></li>
<li><a href="https://sustcoder.github.io/2019/01/11/2019-01-11-bloom-filter/">布隆过滤器之 Counting Bloom Filter</a></li>
<li><a href="https://gaoconghui.github.io/2018/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A9%E5%AE%B9%E4%BB%A5%E5%8F%8A%E5%88%A0%E9%99%A4%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE/">布隆过滤器扩容及删除过期数据</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2023/02/09/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实际场景"><a href="#1-实际场景" class="headerlink" title="1 实际场景"></a>1 实际场景</h1><h2 id="1-1-订单处理系统"><a href="#1-1-订单处理系统" class="headerlink" title="1.1 订单处理系统"></a>1.1 订单处理系统</h2><p>考虑实现一个订单处理系统，为了方便订单的后续处理，系统需要在订单保存的时候，每当订单的预定产品数量超过 <code>1000</code> 时，就需要将订单拆成两份订单来保存，若订单拆分后，数量仍然超过 <code>1000</code>，则持续拆分，直到每份订单的预定产品数量不超过 <code>1000</code>。</p>
<p>其中根据当前业务，订单的类型分为两种：一种是个人订单；一种是公司订单；</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h2 id="1-2-不使用设计模式的方案"><a href="#1-2-不使用设计模式的方案" class="headerlink" title="1.2 不使用设计模式的方案"></a>1.2 不使用设计模式的方案</h2><p>1、定义订单接口</p>
<p>要实现通用的订单处理，不用关心具体的订单类型，则订单处理的对象应该面向一个订单的接口或者是一个通用的订单对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OrderApi.java v 0.1 2023/2/9 23:27 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 订单的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单产品数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 订单中产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置订单产品数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 订单产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、个人订单</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> PersonalOrder.java v 0.1 2023/2/9 23:27 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 个人订单对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonalOrder</span> <span class="keyword">implements</span> <span class="title class_">OrderApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订购人员姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String customerName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>    <span class="variable">orderProductNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.orderProductNum = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCustomerName</span><span class="params">(String customerName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.customerName = customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"本个人订单的订购人是="</span> + <span class="built_in">this</span>.customerName + <span class="string">"，订购产品是="</span> + <span class="built_in">this</span>.productId + <span class="string">"，订购数量为="</span> + <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、企业订单</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> EnterpriseOrder.java v 0.1 2023/2/9 23:29 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 企业订单对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnterpriseOrder</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 企业名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String enterpriseName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>    <span class="variable">orderProductNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.orderProductNum = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEnterpriseName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> enterpriseName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnterpriseName</span><span class="params">(String enterpriseName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.enterpriseName = enterpriseName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"本企业订单的订购企业是="</span> + <span class="built_in">this</span>.enterpriseName + <span class="string">"，订购产品是="</span> + <span class="built_in">this</span>.productId + <span class="string">"，订购数量为="</span> + <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：</p>
<p>以上代码主要示意作用，实际场景远比这复杂，为了方便演示，未抽象共同父类</p>
</blockquote>
<p>4、实现通用的订单处理</p>
<p>先定义出订单处理的对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OrderBusiness.java v 0.1 2023/2/9 23:35 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理订单的业务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderBusiness</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order 订单的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOrder</span><span class="params">(OrderApi order)</span> {</span><br><span class="line">        <span class="comment">//等待具体实现</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实现拆分订单逻辑</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OrderBusiness.java v 0.1 2023/2/9 23:35 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理订单的业务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderBusiness</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order 订单的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOrder</span><span class="params">(OrderApi order)</span> {</span><br><span class="line">        <span class="comment">//1：判断当前的预定产品数量是否大于1000</span></span><br><span class="line">        <span class="keyword">while</span> (order.getOrderProductNum() &gt; <span class="number">1000</span>) {</span><br><span class="line">            <span class="comment">//2：如果大于，还需要继续拆分</span></span><br><span class="line">            <span class="comment">//2.1再新建一份订单，跟传入的订单除了数量不一样外，其它都相同</span></span><br><span class="line">            <span class="type">OrderApi</span> <span class="variable">newOrder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">///...</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，拆分订单时，需要将一个订单拆分为多个，则需要新建相应的订单对象，但是由于其中传入的参数是订单接口，则无法确定订单的具体类型，所以无法创建对象，进而无法实现订单的拆分功能。</p>
<p>5、粗暴的方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OrderBusiness.java v 0.1 2023/2/9 23:35 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理订单的业务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderBusiness</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order 订单的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOrder</span><span class="params">(OrderApi order)</span> {</span><br><span class="line">        <span class="comment">//根据业务要求，当订单预定产品数量超过1000时，就要把订单拆成两份订单</span></span><br><span class="line">        <span class="comment">//当然如果要做好，这里的1000应该做成常量，这么做是为了演示简单</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1：判断当前的预定产品数量是否大于1000</span></span><br><span class="line">        <span class="keyword">while</span> (order.getOrderProductNum() &gt; <span class="number">1000</span>) {</span><br><span class="line">            <span class="comment">//2：如果大于，还需要继续拆分</span></span><br><span class="line">            <span class="comment">//2.1再新建一份订单，跟传入的订单除了数量不一样外，其它都相同</span></span><br><span class="line">            <span class="type">OrderApi</span> <span class="variable">newOrder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (order <span class="keyword">instanceof</span> PersonalOrder) {</span><br><span class="line">                <span class="comment">//创建相应的新的订单对象</span></span><br><span class="line">                <span class="type">PersonalOrder</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonalOrder</span>();</span><br><span class="line">                <span class="comment">//然后进行赋值，但是产品数量为1000</span></span><br><span class="line">                <span class="type">PersonalOrder</span> <span class="variable">p1</span> <span class="operator">=</span> (PersonalOrder) order;</span><br><span class="line">                p2.setCustomerName(p1.getCustomerName());</span><br><span class="line">                p2.setProductId(p1.getProductId());</span><br><span class="line">                p2.setOrderProductNum(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">//然后再设置给newOrder</span></span><br><span class="line">                newOrder = p2;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (order <span class="keyword">instanceof</span> EnterpriseOrder) {</span><br><span class="line">                <span class="comment">//创建相应的订单对象</span></span><br><span class="line">                <span class="type">EnterpriseOrder</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnterpriseOrder</span>();</span><br><span class="line">                <span class="comment">//然后进行赋值，但是产品数量为1000</span></span><br><span class="line">                <span class="type">EnterpriseOrder</span> <span class="variable">e1</span> <span class="operator">=</span> (EnterpriseOrder) order;</span><br><span class="line">                e2.setEnterpriseName(e1.getEnterpriseName());</span><br><span class="line">                e2.setProductId(e1.getProductId());</span><br><span class="line">                e2.setOrderProductNum(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">//然后再设置给newOrder</span></span><br><span class="line">                newOrder = (OrderApi) e2;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.2原来的订单保留，把数量设置成减少1000</span></span><br><span class="line">            order.setOrderProductNum(order.getOrderProductNum() - <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后是业务功能处理，省略了，打印输出，看一下</span></span><br><span class="line">            System.out.println(<span class="string">"拆分生成订单=="</span> + newOrder);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//3：不超过1000，那就直接业务功能处理，省略了，打印输出，看一下</span></span><br><span class="line">        System.out.println(<span class="string">"订单=="</span> + order);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>6、客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OrderClient.java v 0.1 2023/2/9 23:56 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//创建订单对象，这里为了演示简单，直接new了</span></span><br><span class="line">        <span class="type">PersonalOrder</span> <span class="variable">op</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonalOrder</span>();</span><br><span class="line">        <span class="comment">//设置订单数据</span></span><br><span class="line">        op.setOrderProductNum(<span class="number">2925</span>);</span><br><span class="line">        op.setCustomerName(<span class="string">"张三"</span>);</span><br><span class="line">        op.setProductId(<span class="string">"P0001"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里获取业务处理的类，也直接new了，为了简单，连业务接口都没有做</span></span><br><span class="line">        <span class="type">OrderBusiness</span> <span class="variable">ob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderBusiness</span>();</span><br><span class="line">        <span class="comment">//调用业务来保存订单对象</span></span><br><span class="line">        ob.saveOrder(op);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">拆分生成订单==本个人订单的订购人是=张三，订购产品是=P0001，订购数量为=1000</span><br><span class="line">拆分生成订单==本个人订单的订购人是=张三，订购产品是=P0001，订购数量为=1000</span><br><span class="line">订单==本个人订单的订购人是=张三，订购产品是=P0001，订购数量为=925</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-存在的问题"><a href="#1-3-存在的问题" class="headerlink" title="1.3 存在的问题"></a>1.3 存在的问题</h2><p>在上面的实现中，看似完成了需求且没有关心订单的具体类型。但事实上，在实现订单处理的时候，上面的实现是按照订单的类型和具体实现来处理的，就是 <code>instanceof</code> 的那一段。会导致几个问题：</p>
<blockquote>
<ul>
<li><strong>既然想要实现通用的订单处理，那么对于订单处理的实现对象，是不应该知道订单的具体实现的，更不应该依赖订单的具体实现。</strong>但是上面的实现中，很明显订单处理的对象依赖了订单的具体实现对象。</li>
<li><strong>难以扩展新的订单类型</strong>。假如现在要加入一个大客户专用订单的类型，那么就需要修改订单处理的对象，要在里面添加对新的订单类型的支持，代码无法适配。</li>
</ul>
</blockquote>
<h1 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h1><h2 id="2-1-原型模式"><a href="#2-1-原型模式" class="headerlink" title="2.1 原型模式"></a>2.1 原型模式</h2><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h3><p>原型模式（<code>Prototype</code>）是创建型模式：用原型实例指定创建对象的种类，并通过拷贝原型来创建新对象。</p>
<h3 id="2-1-2-原型模式解决方案思路"><a href="#2-1-2-原型模式解决方案思路" class="headerlink" title="2.1.2 原型模式解决方案思路"></a>2.1.2 原型模式解决方案思路</h3><p>通过分析上述案例，在方法 <code>saveOrder</code> 中，已经有了订单接口类型的对象实例，是从接口的参数传入的，但是参数封装的是订单的接口类型，并不是具体的实现类型。现在的需求是，需在在 <code>saveOrder</code> 方法中创建订单对象，看起来就像是通过接口的方法来创建。</p>
<p>原型模式就可以解决此类问题：原型模式通过要求对象实现一个可以<code>克隆</code>自身的接口，这样就可以通过拷贝或者克隆一个实例对象本身，来达到创建一个新的实例。使用时只需要调用<code>克隆</code>的接口方法，使用上看就像是通过接口来创建了一个新的对象。<br>如此，通过原型实例创建新的对象，而无需关注这个实例本身的类型，也不用关心对象的具体实现，只要它实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过 <code>new</code> 来创建。</p>
<h3 id="2-1-3-结构说明"><a href="#2-1-3-结构说明" class="headerlink" title="2.1.3 结构说明"></a>2.1.3 结构说明</h3><img src="/2023/02/09/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20230210173431732.png" alt="image-20230210173431732" style="zoom: 50%;">

<blockquote>
<ul>
<li><strong>Prototype：声明一个克隆自身的接口</strong>，用来约束想要克隆自己的类，要求它们都要实现这里定义的克隆方法。</li>
<li><strong>ConcretePrototype：实现 Prototype 接口的类</strong>，这些类真正实现了克隆自身的功能。</li>
<li><strong>Client：使用原型的客户端</strong>，首先要获取到原型实例对象，然后通过原型实例克隆自身来创建新的对象实例。</li>
</ul>
</blockquote>
<h3 id="2-1-4-实例代码"><a href="#2-1-4-实例代码" class="headerlink" title="2.1.4 实例代码"></a>2.1.4 实例代码</h3><p>1、原型接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Prototype.java v 0.1 2023/2/10 18:37 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 声明一个克隆自身的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Prototype</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 克隆自身的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个从自身克隆出来的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、具体原型实现对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConcretePrototype1.java v 0.1 2023/2/10 18:37 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 克隆的具体实现对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype1</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//最简单的克隆，新建一个自身对象，由于没有属性，就不去复制值了</span></span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype1</span>();</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConcretePrototype2.java v 0.1 2023/2/10 19:44 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 克隆的具体实现对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype2</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//最简单的克隆，新建一个自身对象，由于没有属性，就不去复制值了</span></span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype2</span>();</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：</p>
<p>为了示例方便，这两个具体的原型实现对象，都没有定义属性。<strong>事实上，在实际使用原型模式的应用中，原型对象多是有属性的，克隆原型的时候也是需要克隆原型对象的属性</strong>。</p>
</blockquote>
<p>3、客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/10 18:45 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 使用原型的客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有需要使用的原型接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Prototype prototype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入需要使用的原型接口对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototype 需要使用的原型接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(Prototype prototype)</span> {</span><br><span class="line">        <span class="built_in">this</span>.prototype = prototype;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，执行某个功能操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//会需要创建原型接口的对象</span></span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">newPrototype</span> <span class="operator">=</span> prototype.clone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-2-重写方案"><a href="#2-2-重写方案" class="headerlink" title="2.2 重写方案"></a>2.2 重写方案</h2><p>使用原型模式来重写示例，先要在订单的接口上定义出克隆的接口，然后要求各个具体的订单对象克隆自身，这样就可以解决：在订单处理对象里面通过订单接口来创建新的订单对象的问题。</p>
<p>通过接口来强制要求对象有复制的方法，利用这个方法实现对象对自己的复制。</p>
<p>1、订单接口</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OrderApi.java v 0.1 2023/2/13 13:33 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 订单的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单产品数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 订单中产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置订单产品数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 订单产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 订单原型的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OrderApi <span class="title function_">cloneOrder</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：当前例子中，已经有订单的接口存在，就无需重新创建一个原型接口来声明克隆接口；</p>
</blockquote>
<p>2、订单对象定义</p>
<blockquote>
<p>克隆拷贝对象时要求将数据也要复制</p>
</blockquote>
<p>个人订单：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> PersonalOrder.java v 0.1 2023/2/13 13:35 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 个人订单对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonalOrder</span> <span class="keyword">implements</span> <span class="title class_">OrderApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订购人员姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String customerName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>    <span class="variable">orderProductNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.orderProductNum = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCustomerName</span><span class="params">(String customerName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.customerName = customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"本个人订单的订购人是="</span> + <span class="built_in">this</span>.customerName + <span class="string">"，订购产品是="</span> + <span class="built_in">this</span>.productId + <span class="string">"，订购数量为="</span> + <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderApi <span class="title function_">cloneOrder</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//创建一个新的订单，然后把本实例的数据复制过去</span></span><br><span class="line">        <span class="type">PersonalOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonalOrder</span>();</span><br><span class="line">        order.setCustomerName(<span class="built_in">this</span>.customerName);</span><br><span class="line">        order.setProductId(<span class="built_in">this</span>.productId);</span><br><span class="line">        order.setOrderProductNum(<span class="built_in">this</span>.orderProductNum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>企业订单：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> EnterpriseOrder.java v 0.1 2023/2/13 13:36 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 企业订单对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnterpriseOrder</span> <span class="keyword">implements</span> <span class="title class_">OrderApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 企业名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String enterpriseName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>    <span class="variable">orderProductNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.orderProductNum = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEnterpriseName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> enterpriseName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnterpriseName</span><span class="params">(String enterpriseName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.enterpriseName = enterpriseName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"本企业订单的订购企业是="</span> + <span class="built_in">this</span>.enterpriseName + <span class="string">"，订购产品是="</span> + <span class="built_in">this</span>.productId + <span class="string">"，订购数量为="</span> + <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderApi <span class="title function_">cloneOrder</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//创建一个新的订单，然后把本实例的数据复制过去</span></span><br><span class="line">        <span class="type">EnterpriseOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnterpriseOrder</span>();</span><br><span class="line">        order.setEnterpriseName(<span class="built_in">this</span>.enterpriseName);</span><br><span class="line">        order.setProductId(<span class="built_in">this</span>.productId);</span><br><span class="line">        order.setOrderProductNum(<span class="built_in">this</span>.orderProductNum);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、订单处理对象</p>
<blockquote>
<p>这里使用订单接口的克隆方法，是订单的处理对象，也就是说，<strong>订单的处理对象就相当于原型模式结构中的 <code>Client</code>。</strong></p>
<p>当然，客户端在调用 <code>clone</code> 方法之前，还需要先获得相应的实例对象，有了实例对象，才能调用该实例对象的 <code>clone</code> 方法。</p>
<p>这里使用克隆方法，跟标准的原型实现有一些不同，在标准的原型实现的示例代码里面，<strong>客户端是持有需要克隆的对象，而这里是通过方法传入需要使用克隆的对象</strong>，</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OrderBusiness.java v 0.1 2023/2/13 13:37 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理订单的业务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderBusiness</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order 订单的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOrder</span><span class="params">(OrderApi order)</span> {</span><br><span class="line">        <span class="comment">//1：判断当前的预定产品数量是否大于1000</span></span><br><span class="line">        <span class="keyword">while</span> (order.getOrderProductNum() &gt; <span class="number">1000</span>) {</span><br><span class="line">            <span class="comment">//2：如果大于，还需要继续拆分</span></span><br><span class="line">            <span class="comment">//2.1再新建一份订单，跟传入的订单除了数量不一样外，其它都相同</span></span><br><span class="line">            <span class="type">OrderApi</span> <span class="variable">newOrder</span> <span class="operator">=</span> order.cloneOrder();</span><br><span class="line">            <span class="comment">//然后进行赋值，产品数量为1000</span></span><br><span class="line">            newOrder.setOrderProductNum(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.2原来的订单保留，把数量设置成减少1000</span></span><br><span class="line">            order.setOrderProductNum(order.getOrderProductNum() - <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后是业务功能处理，省略了，打印输出，看一下</span></span><br><span class="line">            System.out.println(<span class="string">"拆分生成订单=="</span> + newOrder);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//3：不超过，那就直接业务功能处理，省略了，打印输出，看一下</span></span><br><span class="line">        System.out.println(<span class="string">"订单=="</span> + order);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：</p>
<p>虽然 <code>Java</code> 里面有 <code>clone</code> 方法，上面这么做还是很有意义的，可以让我们更好的、更完整的体会原型这个设计模式。关于 <code>Java</code> 的 <code>clone</code> 方法，后续会讲解。</p>
</blockquote>
<h1 id="3-模式讲解"><a href="#3-模式讲解" class="headerlink" title="3 模式讲解"></a>3 模式讲解</h1><h2 id="3-1-认识模型模式"><a href="#3-1-认识模型模式" class="headerlink" title="3.1 认识模型模式"></a>3.1 认识模型模式</h2><p>模型模式的功能实际包含两个功能：</p>
<blockquote>
<ol>
<li>通过<code>克隆（clone）</code>的方法来创建新的对象实例；</li>
<li>对克隆出来的新对象实例复制原实例属性的值；</li>
</ol>
</blockquote>
<p><strong>一般来讲，新创建出来的实例的数据是和原型实例一样的</strong>。但是具体如何实现克隆，需要由代码自行实现，原型模式并没有统一的要求和实现算法。</p>
<p><code>克隆（clone）</code>与 <code>new</code> 对象的区别：</p>
<blockquote>
<ul>
<li>克隆类似于 <code>new</code>，但是不等于 <code>new</code>；</li>
<li><code>new</code> 一个对象实例，一般属性是没有值的，或者是只有默认值；</li>
<li><strong>如果是克隆得到的一个实例，通常属性是有值的，属性的值就是原型对象实例在克隆的时候，原型对象实例的属性的值</strong>。</li>
</ul>
</blockquote>
<p>所以，通过原型模式生成的新对象实例，实际上与原来的对象实例是没有关联的，即，对象实例在不同的内存空间。</p>
<h2 id="3-2-Java中的拷贝"><a href="#3-2-Java中的拷贝" class="headerlink" title="3.2 Java中的拷贝"></a>3.2 Java 中的拷贝</h2><p><code>Java</code> 中已经提供了 <code>clone</code> 的接口方法，定义在 <code>Object</code> 类中，利用 <code>Java</code> 的 <code>clone</code> 方法来实现上面的案例。</p>
<p>1、订单接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> OrderApi.java v 0.1 2023/2/13 20:33 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单产品数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 订单中产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置订单产品数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 订单产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///**</span></span><br><span class="line">    <span class="comment">// * 拷贝方法</span></span><br><span class="line">    <span class="comment">// *</span></span><br><span class="line">    <span class="comment">// * @return 订单原型的实例</span></span><br><span class="line">    <span class="comment">// */</span></span><br><span class="line">    <span class="comment">//pattern.prototype.renew.OrderApi cloneOrder();</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、实现 <code>java.lang.Cloneable</code> 接口的订单对象，这里就实现一个类作为示例</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> PersonalOrder.java v 0.1 2023/2/13 20:37 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonalOrder</span> <span class="keyword">implements</span> <span class="title class_">OrderApi</span>, Cloneable {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订购人员姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String customerName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单产品数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>    <span class="variable">orderProductNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.orderProductNum = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCustomerName</span><span class="params">(String customerName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.customerName = customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"本个人订单的订购人是="</span> + <span class="built_in">this</span>.customerName + <span class="string">"，订购产品是="</span> + <span class="built_in">this</span>.productId + <span class="string">"，订购数量为="</span> + <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="comment">//public pattern.prototype.renew.OrderApi cloneOrder() {</span></span><br><span class="line">    <span class="comment">//    //创建一个新的订单，然后把本实例的数据复制过去</span></span><br><span class="line">    <span class="comment">//    pattern.prototype.renew.PersonalOrder order = new pattern.prototype.renew.PersonalOrder();</span></span><br><span class="line">    <span class="comment">//    order.setCustomerName(this.customerName);</span></span><br><span class="line">    <span class="comment">//    order.setProductId(this.productId);</span></span><br><span class="line">    <span class="comment">//    order.setOrderProductNum(this.orderProductNum);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    return order;</span></span><br><span class="line">    <span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/13 20:40 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="comment">//先创建原型实例</span></span><br><span class="line">        <span class="type">PersonalOrder</span> <span class="variable">oa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonalOrder</span>();</span><br><span class="line">        <span class="comment">//设置原型实例的订单数量的值</span></span><br><span class="line">        oa1.setOrderProductNum(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"这是第一次获取的对象实例==="</span> + oa1.getOrderProductNum());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过克隆来获取新的实例</span></span><br><span class="line">        <span class="type">PersonalOrder</span> <span class="variable">oa2</span> <span class="operator">=</span> (PersonalOrder) oa1.clone();</span><br><span class="line">        oa2.setOrderProductNum(<span class="number">80</span>);</span><br><span class="line">        System.out.println(<span class="string">"输出克隆出来的实例==="</span> + oa2.getOrderProductNum());</span><br><span class="line">        <span class="comment">//再次输出原型实例的值</span></span><br><span class="line">        System.out.println(<span class="string">"再次输出原型实例==="</span> + oa1.getOrderProductNum());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">这是第一次获取的对象实例===<span class="number">100</span></span><br><span class="line">输出克隆出来的实例===<span class="number">80</span></span><br><span class="line">再次输出原型实例===<span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-3-浅拷贝与深拷贝"><a href="#3-3-浅拷贝与深拷贝" class="headerlink" title="3.3 浅拷贝与深拷贝"></a>3.3 浅拷贝与深拷贝</h2><p>前面提到了 <code>clone</code>，正好引申一下浅拷贝和深拷贝的概念和区别。</p>
<ul>
<li>浅拷贝：只负责拷贝按值传递的数据（比如：基本数据类型、<code>String</code> 类型）</li>
<li>深拷贝：除了浅拷贝要拷贝的值外，还负责拷贝引用类型的数据，基本上就是被拷贝实例所有的属性的数据都会被克隆出来</li>
</ul>
<blockquote>
<p>注：<strong>深拷贝还有一个特点，如果被克隆的对象里面的属性数据是引用类型，也就是属性的类型也是对象，那么需要一直递归的克隆下去。</strong>这也意味着，要想深拷贝成功，必须要整个克隆所涉及的对象都要正确实现克隆方法，如果其中有一个没有正确实现克隆，那么就会导致深拷贝失败。</p>
</blockquote>
<p>上一小结使用的就是浅拷贝。</p>
<h3 id="深拷贝案例"><a href="#深拷贝案例" class="headerlink" title="深拷贝案例"></a>深拷贝案例</h3><h4 id="1-不使用Java的Cloneble方式"><a href="#1-不使用Java的Cloneble方式" class="headerlink" title="1 不使用Java的Cloneble方式"></a>1 不使用 Java 的 Cloneble 方式</h4><p>继续上面的案例，实现一个引用对象给订单对象</p>
<p>1、订单对象的属性所引用的对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ProductPrototype.java v 0.1 2023/2/13 19:48 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 声明一个克隆产品自身的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductPrototype</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 克隆产品自身的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个从自身克隆出来的产品对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ProductPrototype <span class="title function_">cloneProduct</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Product.java v 0.1 2023/2/13 20:49 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 产品对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> <span class="keyword">implements</span> <span class="title class_">ProductPrototype</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产品编号="</span> + <span class="built_in">this</span>.productId + <span class="string">"，产品名称="</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductPrototype <span class="title function_">cloneProduct</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//创建一个新的订单，然后把本实例的数据复制过去</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">        product.setProductId(<span class="built_in">this</span>.productId);</span><br><span class="line">        product.setName(<span class="built_in">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、新的订单对象实现，增加的上面实现的引用对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> PersonalOrder.java v 0.1 2023/2/13 20:50 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonalOrder</span> <span class="keyword">implements</span> <span class="title class_">OrderApi</span> {</span><br><span class="line">    <span class="keyword">private</span> String  customerName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>     <span class="variable">orderProductNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Product</span> <span class="variable">product</span>         <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.orderProductNum = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCustomerName</span><span class="params">(String customerName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.customerName = customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProduct</span><span class="params">(Product product)</span> {</span><br><span class="line">        <span class="built_in">this</span>.product = product;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//简单点输出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"订购产品是="</span> + <span class="built_in">this</span>.product.getName() + <span class="string">"，订购数量为="</span> + <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderApi <span class="title function_">cloneOrder</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//创建一个新的订单，然后把本实例的数据复制过去</span></span><br><span class="line">        <span class="type">PersonalOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonalOrder</span>();</span><br><span class="line">        order.setCustomerName(<span class="built_in">this</span>.customerName);</span><br><span class="line">        order.setOrderProductNum(<span class="built_in">this</span>.orderProductNum);</span><br><span class="line">        <span class="comment">//对于对象类型的数据，深度克隆的时候需要继续调用这个对象的克隆方法</span></span><br><span class="line">        order.setProduct((Product) <span class="built_in">this</span>.product.cloneProduct());</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、客户端代码 - 验证深拷贝</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/13 19:51 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//先创建原型实例</span></span><br><span class="line">        <span class="type">PersonalOrder</span> <span class="variable">oa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonalOrder</span>();</span><br><span class="line">        <span class="comment">//设置原型实例的值</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">        product.setName(<span class="string">"产品1"</span>);</span><br><span class="line">        oa1.setProduct(product);</span><br><span class="line">        oa1.setOrderProductNum(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"这是第一次获取的对象实例="</span> + oa1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过克隆来获取新的实例</span></span><br><span class="line">        <span class="type">PersonalOrder</span> <span class="variable">oa2</span> <span class="operator">=</span> (PersonalOrder) oa1.cloneOrder();</span><br><span class="line">        <span class="comment">//修改它的值</span></span><br><span class="line">        oa2.getProduct().setName(<span class="string">"产品2"</span>);</span><br><span class="line">        oa2.setOrderProductNum(<span class="number">80</span>);</span><br><span class="line">        <span class="comment">//输出克隆出来的对象的值</span></span><br><span class="line">        System.out.println(<span class="string">"输出克隆出来的实例="</span> + oa2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次输出原型实例的值</span></span><br><span class="line">        System.out.println(<span class="string">"再次输出原型实例="</span> + oa1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">这是第一次获取的对象实例=订购产品是=产品<span class="number">1</span>，订购数量为=<span class="number">100</span></span><br><span class="line">输出克隆出来的实例=订购产品是=产品<span class="number">2</span>，订购数量为=<span class="number">80</span></span><br><span class="line">再次输出原型实例=订购产品是=产品<span class="number">1</span>，订购数量为=<span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>深拷贝的实现不复杂，但是比较麻烦，比如多个对象的属性都是引用类型的话，需要循环去实现为 <code>clone</code> 方法，并且每个都要正确实现此方法，如果有一个遗漏，都会引起深拷贝的报错。</p>
</blockquote>
<h4 id="2-使用Java的Cloneable方式"><a href="#2-使用Java的Cloneable方式" class="headerlink" title="2 使用Java的Cloneable方式"></a>2 使用 Java 的 Cloneable 方式</h4><p>1、新增产品类的实现，主要将 <code>ProductPrototype</code> 接口改成 <code>Cloneable</code> 接口实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Product.java v 0.1 2023/2/13 21:01 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> {</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产品编号="</span> + <span class="built_in">this</span>.productId + <span class="string">"，产品名称="</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            obj = <span class="built_in">super</span>.clone();</span><br><span class="line">        } <span class="keyword">catch</span> (CloneNotSupportedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、订单类的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> PersonalOrder.java v 0.1 2023/2/13 20:02 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonalOrder</span> <span class="keyword">implements</span> <span class="title class_">OrderApi</span>, Cloneable {</span><br><span class="line">    <span class="keyword">private</span> String  customerName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Product</span> <span class="variable">product</span>         <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>     <span class="variable">orderProductNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderProductNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderProductNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.orderProductNum = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCustomerName</span><span class="params">(String customerName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.customerName = customerName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProduct</span><span class="params">(Product product)</span> {</span><br><span class="line">        <span class="built_in">this</span>.product = product;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//简单点输出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"订购产品是="</span> + <span class="built_in">this</span>.product.getName() + <span class="string">"，订购数量为="</span> + <span class="built_in">this</span>.orderProductNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">PersonalOrder</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            obj = (PersonalOrder) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//下面这一句话不可少</span></span><br><span class="line">            obj.setProduct((Product) <span class="built_in">this</span>.product.clone());</span><br><span class="line">        } <span class="keyword">catch</span> (CloneNotSupportedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>特别注意：</p>
<p>不可缺少 <code>obj.setProduct((Product)this.product.clone());</code></p>
<p>原因在于调用 <code>super.clone()</code> 方法的时候，<code>Java</code> 是先开辟一块内存的空间，然后把实例对象的值原样拷贝过去，对于基本数据类型这样做是没有问题的，而属性 <code>product</code> 是一个引用类型，把值拷贝过去的意思就是把对应的内存地址拷贝过去了，也就是说克隆后的对象实例的 <code>product</code> 和原型对象实例的 <code>product</code> 指向的是同一块内存空间，是同一个产品实例。</p>
<p>因此要想正确的执行深度拷贝，<strong>必须手工的对每一个引用类型的属性进行克隆，并重新设置，覆盖掉 <code>super.clone()</code> 所拷贝的值</strong>。</p>
</blockquote>
<h2 id="3-4-原型管理器"><a href="#3-4-原型管理器" class="headerlink" title="3.4 原型管理器"></a>3.4 原型管理器</h2><p>有了原型管理器后，一般情况下，除了向原型管理器里面添加原型对象的时候是通过 <code>new</code> 来创造的对象，其余时候都是通过向原型管理器来请求原型实例，然后通过克隆方法来获取新的对象实例，这就可以实现动态管理、或者动态切换具体的实现对象实例。</p>
<p>在很多实际应用场景中，系统的原型数据是不固定的，其中原型是可以被动态的创建和销毁，这种情况下，就需要在系统中维护一个当前可用的原型注册表，这个注册表称为<strong>原型管理器</strong>。</p>
<p>若原型是一个资源的话， 此时原型管理器就相当于是一个资源管理器，系统启动时，管理器就初始化，然后运行期间可以动态的添加资源和销毁资源，类似于一个资源缓存池。</p>
<h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>1、定义原型接口</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Prototype.java v 0.1 2023/2/13 22:04 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Prototype</span> {</span><br><span class="line">    Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、原型实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConcretePrototype1.java v 0.1 2023/2/13 22:05 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype1</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">ConcretePrototype1</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype1</span>();</span><br><span class="line">        prototype.setName(<span class="built_in">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Now in Prototype1，name="</span> + name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConcretePrototype2.java v 0.1 2023/2/13 22:09 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype2</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">ConcretePrototype2</span> <span class="variable">prototype2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype2</span>();</span><br><span class="line">        prototype2.setName(<span class="built_in">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> prototype2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Now in Prototype2，name="</span> + name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、原型管理器</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> PrototypeManager.java v 0.1 2023/2/13 22:12 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 原型管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeManager</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来记录原型的编号和原型实例的对应关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Prototype&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Prototype&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法，避免外部无谓的创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PrototypeManager</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向原型管理器里面添加或是修改某个原型注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId 原型编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototype   原型实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setPrototype</span><span class="params">(String prototypeId, Prototype prototype)</span> {</span><br><span class="line">        map.put(prototypeId, prototype);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从原型管理器里面删除某个原型注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId 原型编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removePrototype</span><span class="params">(String prototypeId)</span> {</span><br><span class="line">        map.remove(prototypeId);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个原型编号对应的原型实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId 原型编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原型编号对应的原型实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 如果原型编号对应的原型实例不存在，报出例外</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Prototype <span class="title function_">getPrototype</span><span class="params">(String prototypeId)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> map.get(prototypeId);</span><br><span class="line">        <span class="keyword">if</span> (prototype == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">"您希望获取的原型还没有注册或已被销毁"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><strong>原型管理器是类似一个工具类的实现方式，而且对外的几个方法都是加了同步的，这主要是因为如果在多线程环境下使用这个原型管理器的话，<code>map</code> 属性容易成为竞争的资源，因此需要加上同步</strong>。</p>
</blockquote>
<p>4、客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/13 22:23 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 初始化原型管理器</span></span><br><span class="line">            <span class="type">Prototype</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype1</span>();</span><br><span class="line">            PrototypeManager.setPrototype(<span class="string">"Prototype1"</span>, p1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取原型来创建对象</span></span><br><span class="line">            <span class="type">Prototype</span> <span class="variable">p3</span> <span class="operator">=</span> PrototypeManager.getPrototype(<span class="string">"Prototype1"</span>).clone();</span><br><span class="line">            p3.setName(<span class="string">"张三"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第一个实例："</span> + p3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有人动态的切换了实现</span></span><br><span class="line">            <span class="type">Prototype</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype2</span>();</span><br><span class="line">            PrototypeManager.setPrototype(<span class="string">"Prototype1"</span>, p2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新获取原型来创建对象</span></span><br><span class="line">            <span class="type">Prototype</span> <span class="variable">p4</span> <span class="operator">=</span> PrototypeManager.getPrototype(<span class="string">"Prototype1"</span>).clone();</span><br><span class="line">            p4.setName(<span class="string">"李四"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第二个实例："</span> + p4);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有人注销了这个原型</span></span><br><span class="line">            PrototypeManager.removePrototype(<span class="string">"Prototype1"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再次获取原型来创建对象</span></span><br><span class="line">            <span class="type">Prototype</span> <span class="variable">p5</span> <span class="operator">=</span> PrototypeManager.getPrototype(<span class="string">"Prototype1"</span>).clone();</span><br><span class="line">            p5.setName(<span class="string">"王五"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第三个实例："</span> + p5);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception err) {</span><br><span class="line">            System.err.println(err.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">第一个实例：Now in Prototype1，name=张三</span><br><span class="line">第二个实例：Now in Prototype2，name=李四</span><br><span class="line">您希望获取的原型还没有注册或已被销毁</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-5-原型模式的优缺点"><a href="#3-5-原型模式的优缺点" class="headerlink" title="3.5 原型模式的优缺点"></a>3.5 原型模式的优缺点</h2><h3 id="1、对客户端隐藏具体的实现类型"><a href="#1、对客户端隐藏具体的实现类型" class="headerlink" title="1、对客户端隐藏具体的实现类型"></a>1、对客户端隐藏具体的实现类型</h3><p>原型模式的客户端，只知道原型接口的类型，并不知道具体的实现类型，从而减少了客户端对这些具体实现类型的依赖。</p>
<h3 id="2、在运行时动态改变具体的实现类型"><a href="#2、在运行时动态改变具体的实现类型" class="headerlink" title="2、在运行时动态改变具体的实现类型"></a>2、在运行时动态改变具体的实现类型</h3><p>原型模式可以在运行期间，有客户端来注册符合原型接口实现类型，也可同台的改变具体的实现类型，看起来接口没有任何变化，但是其实运行的已经是另外一个类的实例了，因为克隆一个原型就类似于实例化一个类。</p>
<h3 id="3、深拷贝实现比较麻烦"><a href="#3、深拷贝实现比较麻烦" class="headerlink" title="3、深拷贝实现比较麻烦"></a>3、深拷贝实现比较麻烦</h3><p>原型模式最大的缺点就在于每个原型的子类都必须实现 <code>clone</code> 的操作，尤其在包含引用类型的对象时，<code>clone</code> 方法会比较麻烦，必须要能够递归的让所有的相关对象都要正确的实现克隆。</p>
<h2 id="3-6-思考"><a href="#3-6-思考" class="headerlink" title="3.6 思考"></a>3.6 思考</h2><h3 id="1、原型模式的本质"><a href="#1、原型模式的本质" class="headerlink" title="1、原型模式的本质"></a>1、原型模式的本质</h3><p>本质：克隆生成对象，克隆是手段，目的还是生成新的对象实例。</p>
<p>原型模式也可以用来解决 “只知接口而不知实现的问题”，使用原型模式，可以出现一种独特的 “接口造接口” 的景象，这在面向接口编程中很有用。同样的功能也可以考虑使用工厂来实现。</p>
<p>需要注意的是，<strong>原型模式的重心还是在创建新的对象实例</strong>，至于创建出来的对象，其属性的值是否一定要和原型对象属性的值完全一样，这个并没有强制规定，在大多数实现中，克隆出来的对象和原型对象的属性值是一样的。</p>
<h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><ul>
<li>当一个系统想要独立于它想要使用的对象时，可以使用原型模式，系统只需要面向接口编程，在系统需要新的对象时，通过克隆原型来得到；</li>
<li>当需要实例化的类是在运行时刻动态指定时</li>
</ul>
<h2 id="3-7-相关模式"><a href="#3-7-相关模式" class="headerlink" title="3.7 相关模式"></a>3.7 相关模式</h2><h3 id="1、原型模式和抽象工厂模式"><a href="#1、原型模式和抽象工厂模式" class="headerlink" title="1、原型模式和抽象工厂模式"></a>1、原型模式和抽象工厂模式</h3><p>功能上有些相似，都是用来获取一个新的对象实例。不同之处在于：</p>
<ul>
<li>原型模式主要关注如何创建出示例对象，选择的方案是克隆；</li>
<li>抽象模式主要关注的如何创建产品簇，并不关注具体如何创建出产品簇中的每个对象实例；</li>
</ul>
<h3 id="2、原型模式和生成器模式"><a href="#2、原型模式和生成器模式" class="headerlink" title="2、原型模式和生成器模式"></a>2、原型模式和生成器模式</h3><p>两种模式可以配合使用。生成器模式关注的是构建的过程，在构建过程中，可能需要某个部件的实例，此时可以搭配原型模式使用，通过原型模式来得到部件的实例。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>创建型模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>容易遗忘的红黑树</title>
    <url>/2022/07/13/%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>作为一个被广泛应用的数据结构，我们必须了解红黑树的前世今生。红黑树是一种特殊平衡二叉树，其特殊的定义可以保证比较高效的查找效率。看了很多相关的博客，但是目前还没有完全理解其中删除后的调整策略。而且特别容易遗忘，所以在这里做个笔记，以便以后的学习和复习。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h4 id="红黑树的特性："><a href="#红黑树的特性：" class="headerlink" title="红黑树的特性："></a>红黑树的特性：</h4><p><strong>（1）每个节点或者是黑色，或者是红色。</strong><br><strong>（2）根节点是黑色。</strong><br><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空 (NIL 或 NULL) 的叶子节点！]</strong><br><strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong><br><strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> data.structure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.print.attribute.standard.NumberUp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 红黑树特点</span></span><br><span class="line"><span class="comment"> * 1、每个节点不是红色就是黑色的；</span></span><br><span class="line"><span class="comment"> * 2、根节点总是黑色的；</span></span><br><span class="line"><span class="comment"> * 3、所有的叶节点都是是黑色的（红黑树的叶子节点都是空节点（NIL或者NULL））；</span></span><br><span class="line"><span class="comment"> * 4、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</span></span><br><span class="line"><span class="comment"> * 5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RBTree</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RBNode&lt;T&gt; mRoot = <span class="literal">null</span>; <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RBNode</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; {</span><br><span class="line">        T key; <span class="comment">// 节点中的值</span></span><br><span class="line">        <span class="type">boolean</span> color; <span class="comment">// 颜色</span></span><br><span class="line">        RBNode&lt;T&gt; parent; <span class="comment">// 父节点</span></span><br><span class="line">        RBNode&lt;T&gt; left; <span class="comment">// 左子节点</span></span><br><span class="line">        RBNode&lt;T&gt; right; <span class="comment">// 右自节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">RBNode</span><span class="params">(T key, <span class="type">boolean</span> color, RBNode&lt;T&gt; parent, RBNode&lt;T&gt; left, RBNode&lt;T&gt; right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span> + <span class="string">"key:"</span> + key + (color == RED ? <span class="string">" R"</span> : <span class="string">" B"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RBTree</span><span class="params">()</span> {</span><br><span class="line">        mRoot = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RBNode&lt;T&gt; <span class="title function_">parentOf</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> ? node.parent : <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(RBNode&lt;T&gt; node, RBNode&lt;T&gt; parent)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            node.parent = parent;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">colorOf</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> ? node.color : BLACK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(RBNode&lt;T&gt; node, <span class="type">boolean</span> color)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            node.color = color;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.color == RED;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setRed</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            node.color = RED;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isBlack</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        <span class="keyword">return</span> !isRed(node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setBlack</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            node.color = BLACK;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历RBTree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> {</span><br><span class="line">        preOrder(mRoot);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(RBNode&lt;T&gt; tree)</span> {</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="literal">null</span>) {</span><br><span class="line">            System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">            preOrder(tree.left);</span><br><span class="line">            preOrder(tree.right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历RBTree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> {</span><br><span class="line">        inOrder(mRoot);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(RBNode&lt;T&gt; tree)</span> {</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="literal">null</span>) {</span><br><span class="line">            inOrder(tree.left);</span><br><span class="line">            System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">            inOrder(tree.right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历RBTree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> {</span><br><span class="line">        postOrder(mRoot);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(RBNode&lt;T&gt; tree)</span> {</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="literal">null</span>) {</span><br><span class="line">            postOrder(tree.left);</span><br><span class="line">            postOrder(tree.right);</span><br><span class="line">            System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RBNode&lt;T&gt; <span class="title function_">search</span><span class="params">(T key)</span> {</span><br><span class="line">        <span class="keyword">return</span> search(mRoot, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找红黑树（node）中，健值为key的节点 (递归查找)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RBNode&lt;T&gt; <span class="title function_">search</span><span class="params">(RBNode&lt;T&gt; node, T key)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> search(node.left, key);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> search(node.right, key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RBNode&lt;T&gt; <span class="title function_">iterativeSearch</span><span class="params">(T key)</span> {</span><br><span class="line">        <span class="keyword">return</span> iterativeSearch(mRoot, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找红黑树（node）中，健值为key的节点 (非递归查找)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RBNode&lt;T&gt; <span class="title function_">iterativeSearch</span><span class="params">(RBNode&lt;T&gt; node, T key)</span> {</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(node.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) {</span><br><span class="line">                node = node.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">minimum</span><span class="params">()</span> {</span><br><span class="line">        RBNode&lt;T&gt; p = minimum(mRoot);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> p.key;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找最小节点： 返回tree为根节点的红黑树的最小节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tree</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RBNode&lt;T&gt; <span class="title function_">minimum</span><span class="params">(RBNode&lt;T&gt; tree)</span> {</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tree.left != <span class="literal">null</span>) {</span><br><span class="line">            tree = tree.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">maximum</span><span class="params">()</span> {</span><br><span class="line">        RBNode&lt;T&gt; p = maximum(mRoot);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> p.key;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找最大节点： 返回tree为更节点的红黑树的最大节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tree</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RBNode&lt;T&gt; <span class="title function_">maximum</span><span class="params">(RBNode&lt;T&gt; tree)</span> {</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tree.right != <span class="literal">null</span>) {</span><br><span class="line">            tree = tree.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找节点x的后继节点。即，查找红黑树中数值大于x的最小节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RBNode&lt;T&gt; <span class="title function_">successor</span><span class="params">(RBNode&lt;T&gt; x)</span> {</span><br><span class="line">        <span class="comment">// 如果x的右子节点存在，则"x的后继节点"为以x右节点为根节点的最小节点</span></span><br><span class="line">        <span class="keyword">if</span> (x.right != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> minimum(x.right);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果x的右子节点不存在，则x有2中可能：</span></span><br><span class="line">        <span class="comment">// 1：x为左节点，那么x的后继节点为x的父节点；</span></span><br><span class="line">        <span class="comment">// 2：x为右节点，那么x的后继节点为x祖父节点，并且x的父节点为祖父节点的左子节点；否则x不存在后继节点；</span></span><br><span class="line">        RBNode&lt;T&gt; y = x.parent;</span><br><span class="line">        <span class="keyword">while</span> ((y != <span class="literal">null</span>) &amp;&amp; x == y.right) {</span><br><span class="line">            x = y;</span><br><span class="line">            y = y.parent;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找节点x的前驱节点。即，查找红黑树中数据值小于该节点的最大节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RBNode&lt;T&gt; <span class="title function_">predecessor</span><span class="params">(RBNode&lt;T&gt; x)</span> {</span><br><span class="line">        <span class="comment">// 若x的左子节点存在，那么x的前驱节点为以x左子节点为根节点的最大子节点</span></span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> maximum(x.left);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果x的左子节点不存在，则x有2中可能：</span></span><br><span class="line">        <span class="comment">// 1： x为左节点，</span></span><br><span class="line">        <span class="comment">// 2： x为右节点，那么x的前驱节点为x的父节点；</span></span><br><span class="line">        RBNode&lt;T&gt; y = x.parent;</span><br><span class="line">        <span class="keyword">while</span> ((y != <span class="literal">null</span>) &amp;&amp; x == y.left) {</span><br><span class="line">            x = y;</span><br><span class="line">            y = y.parent;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*************对红黑树节点x进行左旋操作 ******************/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 左旋示意图：对节点x进行左旋</span></span><br><span class="line"><span class="comment">     *     p                       p</span></span><br><span class="line"><span class="comment">     *    /                       /</span></span><br><span class="line"><span class="comment">     *   x                       y</span></span><br><span class="line"><span class="comment">     *  / \                     / \</span></span><br><span class="line"><span class="comment">     * lx  y      -----&gt;       x  ry</span></span><br><span class="line"><span class="comment">     *    / \                 / \</span></span><br><span class="line"><span class="comment">     *   ly ry               lx ly</span></span><br><span class="line"><span class="comment">     * 左旋做了三件事：</span></span><br><span class="line"><span class="comment">     * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)</span></span><br><span class="line"><span class="comment">     * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span></span><br><span class="line"><span class="comment">     * 3. 将y的左子节点设为x，将x的父节点设为y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(RBNode&lt;T&gt; x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)</span></span><br><span class="line">        RBNode&lt;T&gt; y = x.right;</span><br><span class="line">        x.right = y.left;</span><br><span class="line">        <span class="keyword">if</span> (y.left != <span class="literal">null</span>) {</span><br><span class="line">            y.left.parent = x;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span></span><br><span class="line">        y.parent = x.parent;</span><br><span class="line">        <span class="keyword">if</span> (x.parent == <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.mRoot = y;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (x == x.parent.left) {</span><br><span class="line">                x.parent.left = y;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                x.parent.right = y;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将y的左子节点设为x，将x的父节点设为y</span></span><br><span class="line">        y.left = x;</span><br><span class="line">        x.parent = y;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*************对红黑树节点y进行右旋操作 ******************/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 右旋示意图：对节点y进行右旋</span></span><br><span class="line"><span class="comment">     *        p                   p</span></span><br><span class="line"><span class="comment">     *       /                   /</span></span><br><span class="line"><span class="comment">     *      y                   x</span></span><br><span class="line"><span class="comment">     *     / \                 / \</span></span><br><span class="line"><span class="comment">     *    x  ry   -----&gt;      lx  y</span></span><br><span class="line"><span class="comment">     *   / \                     / \</span></span><br><span class="line"><span class="comment">     * lx  rx                   rx ry</span></span><br><span class="line"><span class="comment">     * 右旋做了三件事：</span></span><br><span class="line"><span class="comment">     * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)</span></span><br><span class="line"><span class="comment">     * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)</span></span><br><span class="line"><span class="comment">     * 3. 将x的右子节点设为y，将y的父节点设为x</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(RBNode&lt;T&gt; x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        RBNode&lt;T&gt; y = x.left;</span><br><span class="line">        x.left = y.right;</span><br><span class="line">        <span class="keyword">if</span> (y.right != <span class="literal">null</span>) {</span><br><span class="line">            y.right.parent = x;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        y.parent = x.parent;</span><br><span class="line">        <span class="keyword">if</span> (x.parent == <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.mRoot = y;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (x == x.parent.left) {</span><br><span class="line">                x.parent.left = y;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                x.parent.right = y;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        y.right = x;</span><br><span class="line">        x.parent = y;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************** 向红黑树中插入节点 **********************/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T data)</span> {</span><br><span class="line">        RBNode&lt;T&gt; node = <span class="keyword">new</span> <span class="title class_">RBNode</span>&lt;&gt;(data, BLACK, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            insert(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、将节点插入到红黑树中，这个过程与二叉搜索树是一样的</span></span><br><span class="line"><span class="comment">     * 2、将插入的节点着色为"红色"；将插入的节点着色为红色，不会违背"特性5"！</span></span><br><span class="line"><span class="comment">     * 少违背了一条特性，意味着我们需要处理的情况越少。</span></span><br><span class="line"><span class="comment">     * 3、通过一系列的旋转或者着色等操作，使之重新成为一颗红黑树。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line">        <span class="comment">// 假设current 为 node 的父节点</span></span><br><span class="line">        RBNode&lt;T&gt; current = <span class="literal">null</span>;</span><br><span class="line">        RBNode&lt;T&gt; x = mRoot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span>) {</span><br><span class="line">            current = x;</span><br><span class="line">            cmp = node.key.compareTo(x.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</span><br><span class="line">                x = x.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                x = x.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 找到了node需要插入的位置，将当前current作为node的父节点</span></span><br><span class="line">        node.parent = current;</span><br><span class="line">        <span class="comment">// 判断node是插在左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span>) {</span><br><span class="line">            cmp = node.key.compareTo(current.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</span><br><span class="line">                current.left = node;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                current.right = node;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">this</span>.mRoot = node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将node标记为红色</span></span><br><span class="line">        node.color = RED;</span><br><span class="line">        insertFixUp(node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertFixUp</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        RBNode&lt;T&gt; parent, gparent;</span><br><span class="line">        <span class="comment">//需要修整的条件：父节点存在，且父节点的颜色是红色</span></span><br><span class="line">        <span class="keyword">while</span> ((parent = parentOf(node)) != <span class="literal">null</span> &amp;&amp; isRed(parent)) {</span><br><span class="line">            <span class="comment">// 祖父节点</span></span><br><span class="line">            gparent = parentOf(parent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若父节点是祖父节点的左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent == gparent.left) {</span><br><span class="line">                <span class="comment">// 获取叔叔节点，叔叔节点为祖父节点的右子节点</span></span><br><span class="line">                RBNode&lt;T&gt; uncle = gparent.right;</span><br><span class="line">                <span class="comment">// case1: 叔叔节点是红色</span></span><br><span class="line">                <span class="keyword">if</span> ((uncle != <span class="literal">null</span>) &amp;&amp; isRed(uncle)) {</span><br><span class="line">                    <span class="comment">// 将父节点和叔叔节点都染成黑色</span></span><br><span class="line">                    setBlack(uncle);</span><br><span class="line">                    setBlack(parent);</span><br><span class="line">                    <span class="comment">// 则祖父节点必须染成红色</span></span><br><span class="line">                    setRed(gparent);</span><br><span class="line">                    <span class="comment">// 将位置放在祖父节点</span></span><br><span class="line">                    node = gparent;</span><br><span class="line">                    <span class="comment">// 为了满足特性5，继续向上循环染色</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// case2: 叔叔节点是黑色，且当前需要插入的节点为有右子节点</span></span><br><span class="line">                <span class="comment">// 将父节点进行左旋，调换父节点与子节点的位置，在按照 case3 继续调整</span></span><br><span class="line">                <span class="keyword">if</span> (node == parent.right) {</span><br><span class="line">                    <span class="comment">// 从父节点处 左旋</span></span><br><span class="line">                    leftRotate(parent);</span><br><span class="line">                    <span class="comment">// 将父节点和自己调换位置，为右旋准备</span></span><br><span class="line">                    RBNode&lt;T&gt; tmp = parent;</span><br><span class="line">                    parent = node;</span><br><span class="line">                    node = tmp;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// case3：叔叔节点为黑色，切当前需要插入的节点为左自节点</span></span><br><span class="line">                <span class="comment">// a.先父节点染成黑色； b.将祖父节点染成红色；c.将父节点进行右旋</span></span><br><span class="line">                setBlack(parent);</span><br><span class="line">                setRed(gparent);</span><br><span class="line">                rightRotate(gparent);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 若父节点为祖父节点的右自节点</span></span><br><span class="line">                RBNode&lt;T&gt; uncle = gparent.left;</span><br><span class="line">                <span class="comment">// case1: 叔叔节点也是红色节点</span></span><br><span class="line">                <span class="keyword">if</span> (uncle != <span class="literal">null</span> &amp;&amp; isRed(uncle)) {</span><br><span class="line">                    setBlack(parent);</span><br><span class="line">                    setBlack(uncle);</span><br><span class="line">                    setRed(gparent);</span><br><span class="line">                    node = gparent;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// case2: 叔叔节点为黑色，当前要插入的节点为父节点的左子节点</span></span><br><span class="line">                <span class="comment">// 将父节点进行右旋</span></span><br><span class="line">                <span class="keyword">if</span> (node == parent.left) {</span><br><span class="line">                    rightRotate(parent);</span><br><span class="line">                    RBNode&lt;T&gt; tmp = parent;</span><br><span class="line">                    parent = node;</span><br><span class="line">                    node = tmp;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// case3: 叔叔节点为黑色，且当前要插入的节点为父节点的右子节点</span></span><br><span class="line">                setBlack(parent);</span><br><span class="line">                setRed(gparent);</span><br><span class="line">                leftRotate(gparent);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//将根节点设置为黑色</span></span><br><span class="line">        setBlack(<span class="built_in">this</span>.mRoot);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T key)</span> {</span><br><span class="line">        RBNode&lt;T&gt; node;</span><br><span class="line">        <span class="keyword">if</span> ((node = search(mRoot, key)) != <span class="literal">null</span>) {</span><br><span class="line">            remove(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、被删除的节点没有儿子，即删除的是叶子节点。那么，直接删除该节点。</span></span><br><span class="line"><span class="comment">     * 2、被删除的节点只有一个儿子。那么直接删除该节点，并用该节点的唯一子节点顶替它的初始位置。</span></span><br><span class="line"><span class="comment">     * 3、被删除的节点有两个儿子。那么先找出它的后继节点（右孩子中的最小的(最左子节点)，该孩子没有子节点或者只有一右孩子）。</span></span><br><span class="line"><span class="comment">     * 然后把"它的后继节点的内容"复制给"该节点的内容"；之后，删除"它的后继节点"。</span></span><br><span class="line"><span class="comment">     * 在这里后继节点相当与替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。</span></span><br><span class="line"><span class="comment">     * ------这样问题就转化为怎么删除后继即节点的问题？</span></span><br><span class="line"><span class="comment">     * 在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子都非空。</span></span><br><span class="line"><span class="comment">     * 注：后继节点为补充被删除的节点；</span></span><br><span class="line"><span class="comment">     * 即：意味着"要么没有儿子，要么只有一个儿子"。</span></span><br><span class="line"><span class="comment">     * 若没有儿子，则回归到（1）。</span></span><br><span class="line"><span class="comment">     * 若只有一个儿子，则回归到（2）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 需要删除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(RBNode&lt;T&gt; node)</span> {</span><br><span class="line">        RBNode&lt;T&gt; child, parent;</span><br><span class="line">        <span class="type">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// case1: 需要删除的节点的左右子节点都不为空</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) {</span><br><span class="line">            RBNode&lt;T&gt; replace = node;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a: 获取后继节点，右孩子中最小（需要被删除节点右子节点中的最左子节点）</span></span><br><span class="line">            replace = replace.right;</span><br><span class="line">            <span class="keyword">while</span> (replace.left != <span class="literal">null</span>) {</span><br><span class="line">                replace = replace.left;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// b: 处理【后继节点的子节点】和【被删除节点的子节点】之间的关系</span></span><br><span class="line">            <span class="comment">//    将后继节点的位置转换至被删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (parentOf(node) != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 要删除的不是根节点</span></span><br><span class="line">                <span class="keyword">if</span> (node == parentOf(node).left) {</span><br><span class="line">                    <span class="comment">// 此时 replace 的父节点还是原来的父节点，因为还没有指定replace.parent = node.parent.</span></span><br><span class="line">                    parentOf(node).left = replace;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    parentOf(node).right = replace;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mRoot = replace;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//c: 处理【后继节点的子节点】和【被删除节点的子节点】之间的关系</span></span><br><span class="line">            <span class="comment">//后继节点肯定不存在左子节点</span></span><br><span class="line">            child = replace.right;</span><br><span class="line">            parent = parentOf(replace);</span><br><span class="line">            color = colorOf(replace);</span><br><span class="line">            <span class="keyword">if</span> (parent == node) {</span><br><span class="line">                <span class="comment">// 如果replace 为删除节点的唯一右节点，则replace直接替换node 的位置</span></span><br><span class="line">                parent = replace;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (child != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">// 如果replace 还有右子节点，则直接更换为replace原来 父节点子节点</span></span><br><span class="line">                    child.parent = parent;</span><br><span class="line">                }</span><br><span class="line">                parent.left = child;</span><br><span class="line">                <span class="comment">// 将node原来的所有关系都复制给replace</span></span><br><span class="line">                replace.right = node.right;</span><br><span class="line">                setParent(node.right, replace);</span><br><span class="line">            }</span><br><span class="line">            replace.parent = node.parent;</span><br><span class="line">            replace.color = node.color;</span><br><span class="line">            replace.left = node.left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果被删除的节点颜色为黑色，则需要调整</span></span><br><span class="line">            <span class="keyword">if</span> (color == BLACK) {</span><br><span class="line">                removeFixUp(child, parent);</span><br><span class="line">            }</span><br><span class="line">            node = <span class="literal">null</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//被删除的节点是叶子节点</span></span><br><span class="line">            <span class="comment">// a.被删除的节点没有儿子，即删除的是叶子节点。那么，直接删除该节点</span></span><br><span class="line">            <span class="comment">// b.被删除的节点只有一个孩子, 那么直接删除该节点，并用该节点的唯一子节点顶替它的初始位置。</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                child = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                child = node.right;</span><br><span class="line">            }</span><br><span class="line">            parent = node.parent;</span><br><span class="line">            color = node.color;</span><br><span class="line">            <span class="keyword">if</span> (child != <span class="literal">null</span>) {</span><br><span class="line">                child.parent = parent;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (parent.left == node) {</span><br><span class="line">                    parent.left = child;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    parent.right = child;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 如果删除的节点是根节点</span></span><br><span class="line">                mRoot = child;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果被删除的节点颜色为黑色，则需要调整</span></span><br><span class="line">            <span class="keyword">if</span> (color == BLACK) {</span><br><span class="line">                removeFixUp(child, parent);</span><br><span class="line">            }</span><br><span class="line">            node = <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树删除修正函数</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；</span></span><br><span class="line"><span class="comment">     * 目的是将它重新塑造成一颗红黑树。</span></span><br><span class="line"><span class="comment">     * 如果当前待删除节点是红色的，它被删除之后对当前树的特性不会造成任何破坏影响。</span></span><br><span class="line"><span class="comment">     * 而如果被删除的节点是黑色的，这就需要进行进一步的调整来保证后续的树结构满足要求。</span></span><br><span class="line"><span class="comment">     * 这里我们只修正删除的节点是黑色的情况：</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 调整思想：</span></span><br><span class="line"><span class="comment">     * 为了保证删除节点的父节点左右两边黑色节点数一致，需要重点关注父节点没删除的那一边节点是不是黑色。</span></span><br><span class="line"><span class="comment">     * 如果删除后父亲节点另一边比删除的一边黑色多，就要想办法搞到平衡。</span></span><br><span class="line"><span class="comment">     * 1、把父亲节点另一边（即删除节点的兄弟树）其中一个节点弄成红色，也少了一个黑色。</span></span><br><span class="line"><span class="comment">     * 2、或者把另一边多的节点（染成黑色）转过来一个</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 1）、当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</span></span><br><span class="line"><span class="comment">     * x是"黑+黑"节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span></span><br><span class="line"><span class="comment">     * 处理策略:</span></span><br><span class="line"><span class="comment">     * (01) 将x的兄弟节点设为“黑色”;</span></span><br><span class="line"><span class="comment">     * (02) 将x的父节点设为“红色”;</span></span><br><span class="line"><span class="comment">     * (03) 对x的父节点进行左旋;</span></span><br><span class="line"><span class="comment">     * (04) 左旋后，重新设置x的兄弟节点。</span></span><br><span class="line"><span class="comment">     * 这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。</span></span><br><span class="line"><span class="comment">     * 对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，</span></span><br><span class="line"><span class="comment">     * 同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 2）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</span></span><br><span class="line"><span class="comment">     * x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span></span><br><span class="line"><span class="comment">     * 处理策略:</span></span><br><span class="line"><span class="comment">     * (01) 将x的兄弟节点设为“红色”;</span></span><br><span class="line"><span class="comment">     * (02) 设置“x的父节点”为“新的x节点”。</span></span><br><span class="line"><span class="comment">     * 这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。</span></span><br><span class="line"><span class="comment">     * x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，</span></span><br><span class="line"><span class="comment">     * 即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。</span></span><br><span class="line"><span class="comment">     * 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；</span></span><br><span class="line"><span class="comment">     * 但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！</span></span><br><span class="line"><span class="comment">     * 为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，</span></span><br><span class="line"><span class="comment">     * 那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。</span></span><br><span class="line"><span class="comment">     * 我们需要将x的父节点设为“新的x节点”进行处理。</span></span><br><span class="line"><span class="comment">     * 若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；</span></span><br><span class="line"><span class="comment">     * 若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 3）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</span></span><br><span class="line"><span class="comment">     * x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</span></span><br><span class="line"><span class="comment">     * 处理策略:</span></span><br><span class="line"><span class="comment">     * (01) 将x兄弟节点的左孩子设为“黑色”;</span></span><br><span class="line"><span class="comment">     * (02) 将x兄弟节点设为“红色”;</span></span><br><span class="line"><span class="comment">     * (03) 对x的兄弟节点进行右旋;</span></span><br><span class="line"><span class="comment">     * (04) 右旋后，重新设置x的兄弟节点。</span></span><br><span class="line"><span class="comment">     * 我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。</span></span><br><span class="line"><span class="comment">     * 转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，</span></span><br><span class="line"><span class="comment">     * 同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 4）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。</span></span><br><span class="line"><span class="comment">     * x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</span></span><br><span class="line"><span class="comment">     * 处理策略:</span></span><br><span class="line"><span class="comment">     * (01) 将x父节点颜色 赋值给 x的兄弟节点;</span></span><br><span class="line"><span class="comment">     * (02) 将x父节点设为“黑色”;</span></span><br><span class="line"><span class="comment">     * (03) 将x兄弟节点的右子节设为“黑色”;</span></span><br><span class="line"><span class="comment">     * (04) 对x的父节点进行左旋;</span></span><br><span class="line"><span class="comment">     * (05) 设置“x”为“根节点”.</span></span><br><span class="line"><span class="comment">     * 我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。</span></span><br><span class="line"><span class="comment">     * 处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。</span></span><br><span class="line"><span class="comment">     * 为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，</span></span><br><span class="line"><span class="comment">     * “兄弟节点的左孩子”为BLS(Brother's Left Son)，“兄弟节点的右孩子”为BRS(Brother's Right Son)，</span></span><br><span class="line"><span class="comment">     * “父节点”为F(Father)。</span></span><br><span class="line"><span class="comment">     * 我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？</span></span><br><span class="line"><span class="comment">     * 因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；</span></span><br><span class="line"><span class="comment">     * 为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：</span></span><br><span class="line"><span class="comment">     * 第一，“同时经过根节点和S的分支的黑色节点个数不变”。</span></span><br><span class="line"><span class="comment">     * 若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；</span></span><br><span class="line"><span class="comment">     * 现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。</span></span><br><span class="line"><span class="comment">     * 第二，“同时经过根节点和BLS的分支的黑色节点数不变”。</span></span><br><span class="line"><span class="comment">     * 若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色"黑色"，赋值给了F)。</span></span><br><span class="line"><span class="comment">     * 至此，我们算是调换了F和B的颜色。</span></span><br><span class="line"><span class="comment">     * 第三，“同时经过根节点和BRS的分支的黑色节点数不变”。</span></span><br><span class="line"><span class="comment">     * 在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。</span></span><br><span class="line"><span class="comment">     * 经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 以上四种情况中，2，3，4都是（当前节点是黑色的，且兄弟节点是黑色的）的子集。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 参数说明：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node   删除之后代替的节点（后序节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 后序节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeFixUp</span><span class="params">(RBNode&lt;T&gt; node, RBNode&lt;T&gt; parent)</span> {</span><br><span class="line">        RBNode&lt;T&gt; other;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((node == <span class="literal">null</span> || isBlack(node)) &amp;&amp; (node != mRoot)) {</span><br><span class="line">            <span class="keyword">if</span> (parent.left == node) {</span><br><span class="line">                other = parent.right;</span><br><span class="line">                <span class="keyword">if</span> (isRed(other)) {</span><br><span class="line">                    <span class="comment">// case 1:</span></span><br><span class="line">                    setBlack(other);</span><br><span class="line">                    setRed(parent);</span><br><span class="line">                    leftRotate(parent);</span><br><span class="line">                    other = parent.right;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((other.left == <span class="literal">null</span> || isBlack(other.left))</span><br><span class="line">                        &amp;&amp; ((other.right == <span class="literal">null</span>) || isBlack(other.right))) {</span><br><span class="line">                    <span class="comment">// case 2:</span></span><br><span class="line">                    setRed(other);</span><br><span class="line">                    node = parent;</span><br><span class="line">                    parent = parentOf(node);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (other.right == <span class="literal">null</span> || isBlack(other.right)) {</span><br><span class="line">                        <span class="comment">// case 3:</span></span><br><span class="line">                        setBlack(other.left);</span><br><span class="line">                        setRed(other);</span><br><span class="line">                        rightRotate(other);</span><br><span class="line">                        other = parent.right;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// case 4:</span></span><br><span class="line">                    setColor(other, colorOf(parent));</span><br><span class="line">                    setBlack(parent);</span><br><span class="line">                    setBlack(other.right);</span><br><span class="line">                    leftRotate(parent);</span><br><span class="line">                    node = mRoot;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                other = parent.left;</span><br><span class="line">                <span class="keyword">if</span> (isRed(other)) {</span><br><span class="line">                    <span class="comment">// case 1:</span></span><br><span class="line">                    setBlack(other);</span><br><span class="line">                    setRed(parent);</span><br><span class="line">                    rightRotate(parent);</span><br><span class="line">                    other = parent.left;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((other.left == <span class="literal">null</span> || isBlack(other.left))</span><br><span class="line">                        &amp;&amp; (other.right == <span class="literal">null</span> || isBlack(other.right))) {</span><br><span class="line">                    <span class="comment">// case 2:</span></span><br><span class="line">                    setRed(other);</span><br><span class="line">                    node = parent;</span><br><span class="line">                    parent = parentOf(node);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (other.left == <span class="literal">null</span> || isBlack(other.left)) {</span><br><span class="line">                        <span class="comment">// case 3:</span></span><br><span class="line">                        setBlack(other.right);</span><br><span class="line">                        setRed(other);</span><br><span class="line">                        leftRotate(other);</span><br><span class="line">                        other = parent.left;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// case 4:</span></span><br><span class="line">                    setColor(other, colorOf(parent));</span><br><span class="line">                    setBlack(parent);</span><br><span class="line">                    setBlack(other.left);</span><br><span class="line">                    rightRotate(parent);</span><br><span class="line">                    node = mRoot;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            setBlack(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> {</span><br><span class="line">        destory(mRoot);</span><br><span class="line">        mRoot = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁红黑树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">(RBNode&lt;T&gt; tree)</span> {</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tree.left != <span class="literal">null</span>) {</span><br><span class="line">            destory(tree.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (tree.right != <span class="literal">null</span>) {</span><br><span class="line">            destory(tree.right);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        tree = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 打印"红黑树"</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key        -- 节点的键值</span></span><br><span class="line"><span class="comment">     * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment">     *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment">     *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(RBNode&lt;T&gt; tree, T key, <span class="type">int</span> direction)</span> {</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (direction == <span class="number">0</span>) { <span class="comment">// tree是根节点</span></span><br><span class="line">                System.out.printf(<span class="string">"%2d(B) is root\n"</span>, tree.key);</span><br><span class="line">            } <span class="keyword">else</span> {<span class="comment">// tree是分支节点</span></span><br><span class="line">                System.out.printf(<span class="string">"%2d(%s) is %2d's %6s child\n"</span>, tree.key, isRed(tree) ? <span class="string">"R"</span> : <span class="string">"B"</span>, key, direction == <span class="number">1</span> ? <span class="string">"right"</span> : <span class="string">"left"</span>);</span><br><span class="line">            }</span><br><span class="line">            print(tree.left, tree.key, -<span class="number">1</span>);</span><br><span class="line">            print(tree.right, tree.key, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (mRoot != <span class="literal">null</span>) {</span><br><span class="line">            print(mRoot, mRoot.key, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> data.structure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RBTreeTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> a[] = {<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>};</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">mDebugInsert</span> <span class="operator">=</span> <span class="literal">true</span>;    <span class="comment">// "插入"动作的检测开关(false，关闭；true，打开)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">mDebugDelete</span> <span class="operator">=</span> <span class="literal">true</span>;    <span class="comment">// "删除"动作的检测开关(false，关闭；true，打开)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> i, ilen = a.length;</span><br><span class="line">        RBTree&lt;Integer&gt; tree=<span class="keyword">new</span> <span class="title class_">RBTree</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"== 原始数据: "</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">            System.out.printf(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">        System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++) {</span><br><span class="line">            tree.insert(a[i]);</span><br><span class="line">            <span class="comment">// 设置mDebugInsert=true,测试"添加函数"</span></span><br><span class="line">            <span class="keyword">if</span> (mDebugInsert) {</span><br><span class="line">                System.out.printf(<span class="string">"== 添加节点: %d\n"</span>, a[i]);</span><br><span class="line">                System.out.printf(<span class="string">"== 树的详细信息: \n"</span>);</span><br><span class="line">                tree.print();</span><br><span class="line">                System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"== 前序遍历: "</span>);</span><br><span class="line">        tree.preOrder();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n== 中序遍历: "</span>);</span><br><span class="line">        tree.inOrder();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n== 后序遍历: "</span>);</span><br><span class="line">        tree.postOrder();</span><br><span class="line">        System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"== 最小值: %s\n"</span>, tree.minimum());</span><br><span class="line">        System.out.printf(<span class="string">"== 最大值: %s\n"</span>, tree.maximum());</span><br><span class="line">        System.out.printf(<span class="string">"== 树的详细信息: \n"</span>);</span><br><span class="line">        tree.print();</span><br><span class="line">        System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置mDebugDelete=true,测试"删除函数"</span></span><br><span class="line">        <span class="keyword">if</span> (mDebugDelete) {</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">            {</span><br><span class="line">                tree.remove(a[i]);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">"== 删除节点: %d\n"</span>, a[i]);</span><br><span class="line">                System.out.printf(<span class="string">"== 树的详细信息: \n"</span>);</span><br><span class="line">                tree.print();</span><br><span class="line">                System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁二叉树</span></span><br><span class="line">        tree.clear();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Output："><a href="#Output：" class="headerlink" title="Output："></a>Output：</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">== 原始数据: <span class="number">10</span> <span class="number">40</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span> <span class="number">70</span> <span class="number">20</span> <span class="number">50</span> <span class="number">80</span> </span><br><span class="line">== 添加节点: <span class="number">10</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">10</span>(B) is root</span><br><span class="line"></span><br><span class="line">== 添加节点: <span class="number">40</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">10</span>(B) is root</span><br><span class="line"><span class="number">40</span>(R) is <span class="number">10</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 添加节点: 30</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">30(B) is root</span></span><br><span class="line"><span class="string">10(R) is 30'</span>s   left child</span><br><span class="line"><span class="number">40</span>(R) is <span class="number">30</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 添加节点: 60</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">30(B) is root</span></span><br><span class="line"><span class="string">10(B) is 30'</span>s   left child</span><br><span class="line"><span class="number">40</span>(B) is <span class="number">30</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">60(R) is 40'</span>s  right child</span><br><span class="line"></span><br><span class="line">== 添加节点: <span class="number">90</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">30</span>(B) is root</span><br><span class="line"><span class="number">10</span>(B) is <span class="number">30</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">60(B) is 30'</span>s  right child</span><br><span class="line"><span class="number">40</span>(R) is <span class="number">60</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">90(R) is 60'</span>s  right child</span><br><span class="line"></span><br><span class="line">== 添加节点: <span class="number">70</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">30</span>(B) is root</span><br><span class="line"><span class="number">10</span>(B) is <span class="number">30</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">60(R) is 30'</span>s  right child</span><br><span class="line"><span class="number">40</span>(B) is <span class="number">60</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">90(B) is 60'</span>s  right child</span><br><span class="line"><span class="number">70</span>(R) is <span class="number">90</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 添加节点: 20</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">30(B) is root</span></span><br><span class="line"><span class="string">10(B) is 30'</span>s   left child</span><br><span class="line"><span class="number">20</span>(R) is <span class="number">10</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">60(R) is 30'</span>s  right child</span><br><span class="line"><span class="number">40</span>(B) is <span class="number">60</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">90(B) is 60'</span>s  right child</span><br><span class="line"><span class="number">70</span>(R) is <span class="number">90</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 添加节点: 50</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">30(B) is root</span></span><br><span class="line"><span class="string">10(B) is 30'</span>s   left child</span><br><span class="line"><span class="number">20</span>(R) is <span class="number">10</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">60(R) is 30'</span>s  right child</span><br><span class="line"><span class="number">40</span>(B) is <span class="number">60</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">50(R) is 40'</span>s  right child</span><br><span class="line"><span class="number">90</span>(B) is <span class="number">60</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">70(R) is 90'</span>s   left child</span><br><span class="line"></span><br><span class="line">== 添加节点: <span class="number">80</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">30</span>(B) is root</span><br><span class="line"><span class="number">10</span>(B) is <span class="number">30</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">20(R) is 10'</span>s  right child</span><br><span class="line"><span class="number">60</span>(R) is <span class="number">30</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">40(B) is 60'</span>s   left child</span><br><span class="line"><span class="number">50</span>(R) is <span class="number">40</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">80(B) is 60'</span>s  right child</span><br><span class="line"><span class="number">70</span>(R) is <span class="number">80</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">90(R) is 80'</span>s  right child</span><br><span class="line"></span><br><span class="line">== 前序遍历: <span class="number">30</span> </span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">60</span> </span><br><span class="line"><span class="number">40</span> </span><br><span class="line"><span class="number">50</span> </span><br><span class="line"><span class="number">80</span> </span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">90</span> </span><br><span class="line"></span><br><span class="line">== 中序遍历: <span class="number">10</span> </span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">30</span> </span><br><span class="line"><span class="number">40</span> </span><br><span class="line"><span class="number">50</span> </span><br><span class="line"><span class="number">60</span> </span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">80</span> </span><br><span class="line"><span class="number">90</span> </span><br><span class="line"></span><br><span class="line">== 后序遍历: <span class="number">20</span> </span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">50</span> </span><br><span class="line"><span class="number">40</span> </span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">90</span> </span><br><span class="line"><span class="number">80</span> </span><br><span class="line"><span class="number">60</span> </span><br><span class="line"><span class="number">30</span> </span><br><span class="line"></span><br><span class="line">== 最小值: <span class="number">10</span></span><br><span class="line">== 最大值: <span class="number">90</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">30</span>(B) is root</span><br><span class="line"><span class="number">10</span>(B) is <span class="number">30</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">20(R) is 10'</span>s  right child</span><br><span class="line"><span class="number">60</span>(R) is <span class="number">30</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">40(B) is 60'</span>s   left child</span><br><span class="line"><span class="number">50</span>(R) is <span class="number">40</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">80(B) is 60'</span>s  right child</span><br><span class="line"><span class="number">70</span>(R) is <span class="number">80</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">90(R) is 80'</span>s  right child</span><br><span class="line"></span><br><span class="line">== 删除节点: <span class="number">10</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">30</span>(B) is root</span><br><span class="line"><span class="number">20</span>(B) is <span class="number">30</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">60(R) is 30'</span>s  right child</span><br><span class="line"><span class="number">40</span>(B) is <span class="number">60</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">50(R) is 40'</span>s  right child</span><br><span class="line"><span class="number">80</span>(B) is <span class="number">60</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">70(R) is 80'</span>s   left child</span><br><span class="line"><span class="number">90</span>(R) is <span class="number">80</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 删除节点: 40</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">30(B) is root</span></span><br><span class="line"><span class="string">20(B) is 30'</span>s   left child</span><br><span class="line"><span class="number">60</span>(R) is <span class="number">30</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">50(B) is 60'</span>s   left child</span><br><span class="line"><span class="number">80</span>(B) is <span class="number">60</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">70(R) is 80'</span>s   left child</span><br><span class="line"><span class="number">90</span>(R) is <span class="number">80</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 删除节点: 30</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">50(B) is root</span></span><br><span class="line"><span class="string">20(B) is 50'</span>s   left child</span><br><span class="line"><span class="number">80</span>(R) is <span class="number">50</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">60(B) is 80'</span>s   left child</span><br><span class="line"><span class="number">70</span>(R) is <span class="number">60</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string">90(B) is 80'</span>s  right child</span><br><span class="line"></span><br><span class="line">== 删除节点: <span class="number">60</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">50</span>(B) is root</span><br><span class="line"><span class="number">20</span>(B) is <span class="number">50</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">80(R) is 50'</span>s  right child</span><br><span class="line"><span class="number">70</span>(B) is <span class="number">80</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">90(B) is 80'</span>s  right child</span><br><span class="line"></span><br><span class="line">== 删除节点: <span class="number">90</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"><span class="number">50</span>(B) is root</span><br><span class="line"><span class="number">20</span>(B) is <span class="number">50</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string">80(B) is 50'</span>s  right child</span><br><span class="line"><span class="number">70</span>(R) is <span class="number">80</span><span class="string">'s   left child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 删除节点: 70</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">50(B) is root</span></span><br><span class="line"><span class="string">20(B) is 50'</span>s   left child</span><br><span class="line"><span class="number">80</span>(B) is <span class="number">50</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 删除节点: 20</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">60(B) is root</span></span><br><span class="line"><span class="string">30(B) is 60'</span>s   left child</span><br><span class="line"><span class="number">70</span>(B) is <span class="number">60</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 删除节点: 50</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">60(B) is root</span></span><br><span class="line"><span class="string">30(B) is 60'</span>s   left child</span><br><span class="line"><span class="number">70</span>(B) is <span class="number">60</span><span class="string">'s  right child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 删除节点: 80</span></span><br><span class="line"><span class="string">== 树的详细信息: </span></span><br><span class="line"><span class="string">60(B) is root</span></span><br><span class="line"><span class="string">30(B) is 60'</span>s   left child</span><br><span class="line"><span class="number">70</span>(B) is <span class="number">60</span><span class="string">'s  right child</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><ol>
<li><a href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树 (一) 之 原理和算法详细介绍</a></li>
<li><a href="http://dandanlove.com/2018/03/18/red-black-tree/">寻找红黑树的操作手册</a></li>
<li><a href="http://dandanlove.com/2017/10/20/about-binary-tree/">二叉树知识点回忆以及整理</a></li>
<li><a href="https://blog.csdn.net/v_JULY_v/article/details/6105630?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase">教你初步了解红黑树</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>理解并实现 LSM Tree</title>
    <url>/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/</url>
    <content><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>对于存储介质为磁盘或 SSD 的数据库，长期以来主流使用 B + 树这种索引结构来实现快速数据查找。当数据量不太大时，B + 树读写性能表现非常好。但是在海量数据情况下，B + 树越来越高，由于 B + 树更新和删除数据时需要沿着 B + 树逐层进行页分裂和页合并，严重影响数据写入性能。为了应对这种情况，google 在论文<code>《Bigtable: A Distributed Storage System for Structured Data》</code>中介绍了一种新的数据组织结构 <code>LSM Tree(Log-Structured Merge Tree)</code>，随后，<code>Bigtable</code> 主要作者 <code>Jeffrey Dean</code> 和 <code>Sanjay Ghemawat</code> 开源了一款基于 LSM Tree 实现的数据库 LevelDB，让大家对 LSM Tree 的思想和实现理解得更为透彻、深入。当前，比较流行的 NoSQL 数据库，如 Cassandra、RocksDB、HBase、LevelDB 等，newSQL 数据库，如 TiDB，均是使用 LSM Tree 来组织磁盘数据的。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2 基本原理"></a>2 基本原理</h1><p>LSM Tree (Log-Structured Merge Tre) 中文名为：日志结构合并树。其实这并不是一种具体的数据结构，更多是一种数据结构的设计思想，是一个分层、有序、针对块存储设备（机械硬盘和 SSD）特点而设计的数据存储结构。它的核心理论基础还是磁盘的顺序写速度比随机写速度快非常多，即使是 SSD，由于块擦除和垃圾回收的影响，顺序写速度还是比随机写速度快很多。如下图所示：</p>
<img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220726235834566.png" alt="image-20220726235834566" style="zoom:50%;">

<p>LSM Tree 将要存储的数据格式化为多个 <strong>SSTable（Sorted String Table）</strong>，一个 <code>SSTable</code> 内的数据是有序的任意字节组（arbitrary byte string），而且，SSTable 写入磁盘后是不可修改的（Log-Structured）。如有更新数据的需求时，LSM Tree 不修改旧数据，直接将新的数据写入新的 SSTable 中。若有删除需求时，而是将删除的标记写入 SSTable 中，等到后面合并的时候直接将该数据删除。所以 LSM Tree 的磁盘写入单位为 SSTable，即对磁盘的操作都是顺序的块写入，没有随机写入操作。从而将磁盘的写性能尽可能发挥出来。</p>
<p><code>LSM Tree</code> 这种独特的写入方式，导致在查找数据时，<code>LSM Tree</code> 就不能像 <code>B+树</code>那样在一个统一的索引表中进行查找，而是从最新的 <code>SSTable</code> 到老的 <code>SSTable</code> 依次进行查找。如果在新 <code>SSTable</code> 中找到了需查找的数据或相应的删除标记，则直接返回查找结果；如果没有找到，再到老的 <code>SSTable</code> 中进行查找，直到最老的 <code>SSTable</code> 查找完。为了提高查找效率，<code>LSM Tree</code> 对 <code>SSTable</code> 进行分层、有序组织，也就是说把 <code>SSTable</code> 组织成多层，同一层可以有多个 <code>SSTable</code>，同一个数据在同一层的多个 <code>SSTable</code> 中可以不重复，而且数据可以做到在同一层中是有序的，即每一个 <code>SSTable</code> 内的数据是有序的，前一个 <code>SSTable</code> 的最大数据值小于后一个 <code>SSTable</code> 的最小数据值。这样可以加快在同一层 <code>SSTable</code> 中的数据查询速度。同时，<code>LSM Tree</code> 会将多个 <code>SSTable</code> 合并（<code>Compact</code>）为一个新的 <code>SSTable</code>，这样可以减少 <code>SSTable</code> 的数量，同时把修改前的数据或删除的数据真正从 <code>SSTable</code> 中删除，减小了 <code>SSTable</code> 的大小（Merge Tree），以提高查找性能。</p>
<h1 id="3-整体框架"><a href="#3-整体框架" class="headerlink" title="3 整体框架"></a>3 整体框架</h1><img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220727210426468.png" alt="image-20220727210426468" style="zoom: 50%;">

<p>WAL（Write Ahead Log）实际上为数据库的日志结构文件，以 Append-Only 方式追加记录到日志文件，并不属于 LSM Tree。在实际的系统实践中，WAL 为系统不可或缺的部分，将 WAL 囊括进来，才能从整体上更准确地理解 LSM Tree。</p>
<p>如上图所示，<code>LSM Tree</code> 的数据由两部分组成：内存部分和持久到磁盘中的部分。内存部分由一个 <code>MemTable</code> 和一个或多个 <code>Immutable MemTable</code> 组成。磁盘中的部分由分布在多个 level 的 <code>SSTable</code> 组成。level 级数越小（<code>level 0</code>）表示处于该 level 的 <code>SSTable</code> 越新，level 级数越大（<code>level 1...level N</code>）表示处于该 level 的 <code>SSTable</code> 越老，最大级数（<code>level N</code>）大小由系统设定。在本图中，磁盘中最小的级数为 <code>level 0</code>，也有的系统把内存中的 <code>Immutable MemTable</code> 定义为 <code>level 0</code>，而磁盘中的数据从 <code>Level 1</code> 开始，这只是 level 定义的不同，并不影响系统的工作流程和对系统的理解。</p>
<p>其中 WAL 可以保证当系统崩溃重启后，内存中 MemTable 和 Immutable MemTable 中未持久化到磁盘中 SSTable 的数据不会丢失。</p>
<p>内存中 MemTable 一般为有序数据结构，实现方式有很多种，如有序数组、红黑树、二叉搜索树，比较常见的方式为跳表，跳表支持高效的动态插入数据，对数据进行排序，也能高效地对数据进行精确查询与范围查询。</p>
<p><code>SSTable</code> 一般由一组数据 block 和一组元数据 block 组成。元数据 block 存储了 <code>SSTable</code> 数据 block 的描述信息，如索引、BloomFilter、压缩、统计等信息。因为 <code>SSTable</code> 是不可更改的，且是有序的，索引往往采用二分法数组结构就可以了。为了节省存储空间和提升数据块 block 的读写效率，可以对数据 block 进行压缩。</p>
<h2 id="数据写入过程"><a href="#数据写入过程" class="headerlink" title="数据写入过程"></a>数据写入过程</h2><img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220727212404732.png" alt="image-20220727212404732" style="zoom:50%;">

<p><code>LSM Tree</code> 写入数据时，先写一条记录到 <code>WAL</code> 中，然后将数据写入内存中的 <code>MemTable</code> 中，这样写入操作就完成了。（写入 WAL 与 MemTable 可以以事务的形式实现，两者成功才算成功）</p>
<p>写 <code>MemTable</code> 时，写入新的数据，与修改现有数据的部分字段以及修改现有数据的所有字段，写入操作过程几乎是一样的，都是把传入的数据（合并）写入到 <code>MemTable</code> 中。删除数据时，则是在 <code>MemTable</code> 中写入一条删除标记。当 <code>MemTable</code> 的大小达到设定的大小（经典值是 64KB）时，<code>LSM Tree</code> 会把当前 <code>MemTable</code> 设置为一个不可修改的 <code>Immutable MemTable</code>，然后创建一个新的 <code>MemTable</code> 供新的数据写入。同时，<code>LSM Tree</code> 一般会有一些与写入线程（或进程）相独立的背景线程（或进程）负责将 <code>Immutable MemTable</code> flush 到磁盘中，将数据持久化。完成持久化的 Immutable MemTable 对应的 <code>WAL</code> 就可以从磁盘中删除了。而内存中 <code>Immutable MemTable</code> 数量的多少取决于 <code>Immutable MemTable</code> flush 的速度与 <code>Immutable MemTable</code> 生成的速度（数据写入速度）的差值。</p>
<p>从上面介绍的写入过程可以知道，LSM Tree 的写入过程非常简单，只需要写 WAL 与 MemTable 即可。其中 WAL 是 Appand-Only 的方式在日志结构文件末尾追加的记录（顺序写），无需其余复杂的操作，写入性能非常好。而 MemTable 虽然需要如跳表的插入和排序，但是都是在内存中的操作，并且 MemTable 的大小也有限（64K），所以 MemTable 的写入性能也非常好。</p>
<p>在 LSM Tree 的结构中，数据的写入性能与系统中的数据总量和数据更新类型（修改还是删除数据）都无关，写入速度比较稳定。</p>
<h3 id="空间放大"><a href="#空间放大" class="headerlink" title="空间放大"></a>空间放大</h3><p>如果同一个数据被多次更新，那这个数据可能存储在多个 SSTable 当中，甚至统一数据的不同部分的最新数据内容存储在不同的 SSTable 中（数据部分更新的场景），因而同一数据在磁盘当中有多份副本，且老的副本已经过时，这导致了数据实际占用的存储空间大于数据的实际大小。这一现象叫做空间放大（space amplification）</p>
<h2 id="数据查找过程"><a href="#数据查找过程" class="headerlink" title="数据查找过程"></a>数据查找过程</h2><img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220727233111681.png" alt="image-20220727233111681" style="zoom:50%;">

<p>因为<a href="#%E7%A9%BA%E9%97%B4%E6%94%BE%E5%A4%A7">空间放大</a>的问题，所以 LSM Tree 的数据查找过程如上图所示：先在内存 <code>MemTable</code> 中查找，然后在内存中的 <code>Immutable MemTable</code> 中查找，然后在 <code>level 0 SSTable</code> 中查找，最后在 <code>level N SSTable</code> 中查找。其中 SSTable 的查找顺序也为从新到老，直到在某个（或某些个）<code>SSTable</code> 中查找到了所需的数据，或者最老的 <code>SSTable</code> 查找完也没有找到需要的数据。</p>
<p>查找某个具体的 SSTable 时，先把 SSTable 的元数据 block 读到内存中，根据 BloomFilter 可以快速确定数据在当前 SSTable 中是否存在，如果存在，则采用二分法确定数据在哪个数据 block，然后将相应数据 block 读到内存中进行精确查找。若不存在，直接跳过，查找下一个更早的 SSTable，重复以上步骤。</p>
<h3 id="读放大"><a href="#读放大" class="headerlink" title="读放大"></a>读放大</h3><p>由于多层 SSTable 结果的存在，查询数据时需要遍历多个可能不包含数据的 SSTable（最坏的情况需要读取所有的 SSTable）。这种现象叫做读放大（read amplification）</p>
<h3 id="读放大优化"><a href="#读放大优化" class="headerlink" title="读放大优化"></a>读放大优化</h3><p>读放大问题严重影响了 LSM Tree 的数据查找性能，特别是当数据不存在或者在非常老的 SSTable 中。在著名的 Google 三驾马车之一的论文 <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">BigTable</a> 提到了几种提升数据查找性能的方法：</p>
<ol>
<li>压缩（<strong>Compression</strong>）：将 SSTable 的 block 进行压缩，降低 block 的磁盘空间占用，也能减少磁盘的读写时间，但是需要消耗 CPU 的性能来进行 block 的压缩和解压缩。</li>
<li>布隆过滤器（<strong>BloomFilter</strong>）：BloomFilter 可以快速确定数据不在 SSTable 中，而不用读取数据 block 内容。</li>
<li>缓存（<strong>Cache</strong>）：SSTable 是不可变的，非常适合缓存。可以将热点数据缓存到到内存中，尽量避免访问磁盘。</li>
<li>SSTable 合并（<strong>Compaction</strong>）：将多个 SSTable 合并为一个 SSTable，删除旧数据或物理删除已经被删除的数据，降低空间放大；同时减少 SSTable 数量，降低读放大。</li>
</ol>
<h2 id="SSTable合并"><a href="#SSTable合并" class="headerlink" title="SSTable合并"></a>SSTable 合并</h2><h3 id="写放大"><a href="#写放大" class="headerlink" title="写放大"></a>写放大</h3><p>SSTable 合是将多 SSTable 合并成一个新的 SSTable 写入下一个 Level，合并过程中，会删除过期重叠数据，并将标记为删除的数据从磁盘中删除，减少了 SSTable 的数据，可以有效缓解读放大和空间放大问题。这个过程需要将所有涉及合并的 SSTable 都读取到内存当中，并将合并的新 SSTable 写入到磁盘，这样会消耗大量的 CPU 时间和磁盘 IO。这种现象叫写放大（write amplification）</p>
<p>SSTable 合并分为 <code>minor compaction</code> 和 <code>major compaction</code></p>
<ul>
<li>Minor Compaction：是指将内存中的 <code>Immutable MemTable</code> 内容 flush 到磁盘中形成 SSTable 时进行的数据处理过程</li>
<li> Major Compaction: 是指相邻的两级 level 将数字小 level（如 level 0）的 SSTable 合并入数字大 level（如 level 1）的 SSTable 中的过程</li>
</ul>
<p>SSTable 合并其实就是在空间放大、写放大、读放大几个相互制约的因素间寻求平衡，不同的应用场景需要重点优化解决某个问题。</p>
<h3 id="Leveled-Compaction"><a href="#Leveled-Compaction" class="headerlink" title="Leveled Compaction"></a>Leveled Compaction</h3><p><img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220728233102326.png" alt="image-20220728233102326"></p>
<p>leveled compaction 的策略为：对每层的 SSTable 的数据总量设置一个阈值，level 数据越大，阈值也越大，如 level 0 的阈值为 10MB，level 1 的阈值为 100MB，level 2 的阈值为 1000MB。当其中某层的 SSTable 数据总量达到阈值后，选取一个 SSTabel 合并到下一个 level 的一个或多个 SSTable 中。合并后会删除重复的数据，也就说，同一层的 SSTable 中，没有重复的数据。</p>
<p>leveled compaction 能保证同一层的 SSTable 没有重复数据，相对来说对空间放大有最好的优化效果。但是，合并时需要读取多个 SSTable，然后写入多个更新后的 SSTable，导致更大的写放大和读放大。但是在数据查找过程中，由于减少了需要查找 SSTable 的数量，降低了数据查找时的读放大，提升了数据查找的性能。所以，leveled compaction 适合比较关注数据查询速度和控制磁盘空间占用的场景。<strong>比如，数据写入一次，但是会被频繁反复查询；数据经常被修改，但是需要控制磁盘空间大小和保证数据查询速度。</strong></p>
<blockquote>
<p>Cassandra 的 LCS（<code>Leveled Compaction Strategy</code>）和 RocksDB 的 <code>Classic Leveled Compaction</code> 采用的就是 leveled compaction 策略。</p>
</blockquote>
<h3 id="Tiered-Compaction"><a href="#Tiered-Compaction" class="headerlink" title="Tiered Compaction"></a>Tiered Compaction</h3><p><img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220728233443623.png" alt="image-20220728233443623"></p>
<p>tiered compaction 的策略为：当某 level 层的 SSTable 数量达到设定的阈值时，则将该层的多个 SSTable 合并为一个新的 SSTable，并放入高一层 level 中。</p>
<p>tiered compaction 比较偏重于控制写放大在一定程度的前提下降低空间放大和提升数据查询性能。但是在同一层的 SSTable 中还是存在数据重叠，数据查询性能不如 leveled compaction。尤其是随着 level 数越来越大，单个 SSTable 数据量也越来越大，合并触发条件也越来越难，这些巨型 SSTable 中的重叠数据和被删除的数据占用的空间也就越来越难被释放掉。tiered compaction 比较适合数据修改频率不高，且最近写入的数据查询频率比较高的场景。</p>
<blockquote>
<p>Cassandra 的 STCS（<code>Size Tiered Compaction Strategy</code>）和 RocksDB 的 <code>universal Compaction</code> 使用的是 tiered compaction 策略。</p>
</blockquote>
<h3 id="leveled-tiered-mixed-compaction"><a href="#leveled-tiered-mixed-compaction" class="headerlink" title="leveled-tiered mixed compaction"></a>leveled-tiered mixed compaction</h3><p>是指在一个系统中，结合上述两者合并策略的优势，在部分 level 之间采用 leveled compaction 策略，另一部分 level 之间采用 tiered compaction 策略。</p>
<blockquote>
<p> RocksDB 的 <code>leveled Compaction</code> 采用的是 <code>leveled-tiered mixed compaction</code> 策略。数据从 <code>Immutable MemTable</code> flush 到 level 0 时采用的是 <code>tiered compaction</code>，也就是说 level0 中是存在重叠数据的。level0 到 levelN 之间采用 <code>leveld compaction</code> 策略。</p>
</blockquote>
<h3 id="FIFO-compaction"><a href="#FIFO-compaction" class="headerlink" title="FIFO compaction"></a>FIFO compaction</h3><p><img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220729000754155.png" alt="image-20220729000754155"></p>
<p><code>FIFO compaction</code> 在磁盘中只有一个 level 层级，SSTable 按生成的时间顺序排列，一旦生成数据就不会再修改，删除过早生成的 SSTable。适合时间序列数据。</p>
<blockquote>
<p>Cassandra 的 TWCS（<code>Time Window Compaction Strategy</code>）、DTCS（<code>Date Tiered Compaction Strategy</code>）和 RocksDB 的 <code>FIFO compaction</code> 使用的是 FIFO 类型的合并策略。</p>
</blockquote>
<h1 id="4-基于LSM-Tree实现简单KV存储"><a href="#4-基于LSM-Tree实现简单KV存储" class="headerlink" title="4 基于LSM Tree实现简单KV存储"></a>4 基于 LSM Tree 实现简单 KV 存储</h1><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h3><p>WAL 是保证系统崩溃重启后恢复内存的数据，即，<strong>能够还原所有对内存表的写操作，重新顺序执行这些操作，使得内存表恢复到上一次的状态</strong>。</p>
<p>当 Immutable MemTable 的数据 flush 到磁盘后，则可以删除 WAL 文件，重新创建一个文件。</p>
<blockquote>
<p>关于 WAL 部分的实现，有不同的做法，有的全局只有唯一一个 WAL 文件，有的则使用多个 WAL 文件，具体的实现会根据场景而变化。</p>
</blockquote>
<p>恢复内存表数据时，需要从 WAL 文件中，读取每一次操作信息，重新作用于内存表，即重新执行各种写入操作。因此，直接对内存表进行写操作，和从 WAL 恢复数据重新对内存表进行写操作，都是一样的。恢复的内存表为实现的数据结构（二叉搜索树）</p>
<p><img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220729003944686.png" alt="image-20220729003944686"></p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>需要将操作信息写到文件中，并且能够从 WAL 文件恢复内存表</p>
<h3 id="MemTable-amp-Immutable-MemTable"><a href="#MemTable-amp-Immutable-MemTable" class="headerlink" title="MemTable &amp; Immutable MemTable"></a>MemTable &amp; Immutable MemTable</h3><p>MemTable 与 Immutable MemTable 使用相同的数据结构（二叉搜索树）</p>
<p>系统初始化时，MemTable 为空，即没有任何数据，Immutable MemTable 为 null，即没有分配任何内存。其中 MemTable 的操作为<strong>插入入 KV 和删除 Key</strong>。</p>
<p>一般当 MemTable 中的 Key 数量达到阈值时，MemTable 就会变成 Immutable MemTable ，然后创建一个新的 MemTable， Immutable MemTable 会在合适的时机，转换为 SSTable，flush 到磁盘文件中。所以 Immutable MemTable 为一个临时对象。</p>
<h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>要实现增删查改、遍历</p>
<h3 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h3><img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220730214859305.png" alt="image-20220730214859305" style="zoom:50%;">

<p>SSTable 结构可区分为多个部分：数据区、KV 索引区、元数据区</p>
<img src="/2023/07/26/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0LSM-Tree/image-20220730215725108.png" alt="image-20220730215725108" style="zoom:50%;">

<p><strong>数据区</strong>：Immutable MemTable 被 flush 到 disk 的 SSTable 中时，顺序将每个 KV 数据都压缩成二进制数据，存储在数据区；<br><strong>KV 索引区</strong>：为增加数据区的查找性能，对数据区的每个 KV 都创建索引，并将索引数据压缩成二进制数据，存储在 KV 索引区；<br><strong>元数据区</strong>：占用固定的数据长度（64K），记录 SSTable 的数据结构，当查询 SSTable 的时候，可以先读取该长度内容获取数据；</p>
<h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p>能够加载文件信息，从中查找对应的数据</p>
<h3 id="SSTable-Tree"><a href="#SSTable-Tree" class="headerlink" title="SSTable Tree"></a>SSTable Tree</h3><p>随着系统的运行，SSTable 会不断增加，则需要对这些 SSTable 进行管理。如当同一 level 的 SSTable 数据大小或者 SSTable 的数量达到一定阈值后，SSTable 进行合并等操作，查询的时候可以增加布隆过滤器快速判断 SSTable 中是否有 Key 等。</p>
<h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><p>负责管理所有 SSTable，进行文件合并等</p>
<h3 id="GIT-代码"><a href="#GIT-代码" class="headerlink" title="GIT 代码"></a>GIT 代码</h3><blockquote>
<p><a href="https://github.com/MarkHe1222/lsm">https://github.com/MarkHe1222/lsm</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>写数据时尽量批量操作。LSM Tree 数据写入性能已经很高了，但是批量操作时可以节省网络传输 RTT 时间。</li>
<li>将数据进行分片。这样多个分片可以并行写，如果数据路由处理得当，也可以提升数据查询速度。但是增加了维护多个分片数据读写的复杂度。</li>
<li>选择合适的主键。两个比较流行的选择是：1）采用递增的数字作为主键；2）采用业务本身标识符作为主键。数字作为主键可以减少写入和查询时进行比较、排序等操作的时间，还能提升索引缓存的效率；递增的数字往往保证是顺序写入的，可以减少排序时间。但是递增的数字往往不具备业务语义，业务实际查询时需要先查二级索引，然后进行主键查找。业务标识符往往是业务实际的身份区分符号，业务也往往通过业务标识符进行数据查询。但是业务标识符往往是一个字符串，可能会比较长，这样比较、排序、缓存效率方面不如数字。一般情况下，本人建议 LSM Tree 数据库采用业务标识符作为主键。因为为业务标识符建立索引以及维护索引的成本是免不了的，与其建立二级索引，不如直接建立主键索引。</li>
<li>设计合理的二级索引，不建立不需要的二级索引。二级索引可以提升相应数据的查询速度，每增加一个二级索引，就需要额外维护相应的二级索引文件，严重影响写入数据性能。</li>
<li>根据具体场景使用合适的 SSTable 合并策略。单次写，频繁读场景选择 leveled compaction 策略。</li>
<li>在允许情况下关闭自动 SSTable 合并，在业务量低的时间段强制执行 SSTable 合并。</li>
<li>数据更新时合理选择全量更新（覆盖写）方式还是部分更新（增量写）方式。全量更新方式增加了传输和写入的数据量，但是可以提升数据查询速度。部分更新方式会使数据分布在多个 SSTable 中，需要查询和合并多个 SSTable 中的数据才能得到完整的数据，会降低数据查询速度。如果数据修改比较频繁，且需要较高查询速度，建议采用全量更新方式。</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://github.com/google/leveldb">LevelDB-GitHub</a></li>
<li><a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">磁盘 I/O 那些事</a></li>
<li><a href="https://mp.weixin.qq.com/s/7kdg7VQMxa4TsYqPfF8Yug">理解 LSM Tree：一种高效读写的存储引擎</a></li>
<li><a href="https://blog.csdn.net/sD7O95O/article/details/125038808?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-125038808-blog-105377370.pc_relevant_sortByAnswer&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-125038808-blog-105377370.pc_relevant_sortByAnswer&amp;utm_relevant_index=1">使用 LSM Tree 思想实现一个 KV 数据库</a></li>
<li><a href="https://www.jianshu.com/p/e89cd503c9ae?utm_campaign=hugo&amp;u_atoken=494fdad0-a3ba-4a73-9b84-abdc66566c50&amp;u_asession=01TB3FROgxhlcU337Vj5OhDfW-5uMmbZWhej68-VdZDB7hG4Th4dX6Ri12I8oRSa5rX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K8vPGlHUZOAPp0aZqGb04UmPpcarp92QKzyJKyYjREPlmBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05g3629DOBq16YsuugxDy6-_PgNsCIk1KzlHLxZMwpQuyM-sEhvkyH52g9myoV99Pf0yUnhYd5Lwx8te7vhKEvO2hgC15vp56N7ZL0cnxqILMi3M1Y69u4lT5J76ILZDYyMRxkMsMt2_RPWXlQL6bz_PpGTky1w9ZyYAQrYHyw4nn9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzZydNbTMws_2ej6_jSbTNa0zrURdqDnre3mKfjk5KqOiWPRPQyB_SKrj-61LB_f61u3h9VXwMyh6PgyDIVSG1W94f1HPDhDW61g-vj2fa5Kq3IQNwfjy1LpNxIdkfKC0bMSjsbsPHULZ941MPP6uvuLnioLscH950VoSx3U92RzpmWspDxyAEEo4kbsryBKb9Q&amp;u_aref=797dMnj5gcoMAnfTFwfKK88d+Co=">LSM Tree-Based 存储引擎的 compaction 策略</a></li>
<li><a href="https://www.jianshu.com/p/b43b856e09bb?u_atoken=223e125a-9ceb-44f3-aca4-40de44b26b96&amp;u_asession=01l0ZXqC0_2UjRL4dYjBVf8DGDPymPwntVaK9_HubLJx_XO-1IAAlyNXZTW6g6WxS7X0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K800Z4SvggDiBaE0u3VZgT4Ppcarp92QKzyJKyYjREPlmBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05_UDHsNjsfU-Q4Sf8CfJcSNOEnQSmonOcsFKx1FeS2zZn_lWBMvwS3KMTKrLDn4hqSGgJVy5kDLRz-Eb02U3Y8e1EIqdi1UzMXN1XaoBW-Dqlt8K-4YJ3upWVIsjBp_ahKd-p2N4z8GBNObYI5tQvrmRkWVA1Hy5RChT83Ff2ut_9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzQwIsqIyyzeuCvmumnEayvSX_smdbLpBZ1MvNL2ZBL7oWPRPQyB_SKrj-61LB_f61u3h9VXwMyh6PgyDIVSG1W-ICVx0Jk-rBFAe5nBXiZ7LzZkRHp6MiWHt6djiloXwCg-BwDnGmhS4JOFiRsa3ooHbCGkeDOqqAHBOzRZIOj1hmWspDxyAEEo4kbsryBKb9Q&amp;u_aref=OI25968K/Bc4pOWTI6RcrH7J15w=">LSM Tree 原理详解</a></li>
<li><a href="https://www.cnblogs.com/yanghuahui/p/3483754.html">LSM 树由来、设计思想以及应用到 HBase 的索引</a></li>
<li><a href="http://chengfeng96.com/blog/2018/08/04/LSM%E8%B0%83%E7%A0%94%E7%AC%94%E8%AE%B0/">LSM 调研</a></li>
<li><a href="https://github.com/burhanxz/Distributed-KV">KV 实现</a></li>
</ul>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>存储</tag>
        <tag>LSM Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2022/09/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><h2 id="1-1-接口回顾"><a href="#1-1-接口回顾" class="headerlink" title="1.1 接口回顾"></a>1.1 接口回顾</h2><p>接口是 Java 的一种特殊抽象类，和一般的抽象类相比，接口里面所有的方法都是抽象方法，接口里面的所有属性都是常量。接口里面只有方法定义而不会有任何的方法实现。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h3 id="1-1-2-接口使用场景"><a href="#1-1-2-接口使用场景" class="headerlink" title="1.1.2 接口使用场景"></a>1.1.2 接口使用场景</h3><p>接口用来定义实现类的外观，约束实现类的行为。相当于一分契约，根据调用方需要的功能，约定了实现类需要实现的方法。但具体的实现类除了实现接口约定的功能外，还可以实现一些以其他的功能，也就是说实现类的功能包含但不仅限于接口约束的功能。</p>
<p>通过使用接口，可以实现不相关类的相同行为，而不需要考虑这些类之间的层次关系，接口就是实现类对外的外观。</p>
<h3 id="1-1-3-接口的思想"><a href="#1-1-3-接口的思想" class="headerlink" title="1.1.3 接口的思想"></a>1.1.3 接口的思想</h3><p><strong>封装隔离</strong></p>
<p>封装：对被隔离体的行为或者指责的封装；<br>隔离：对内部实现和外部调用的隔离；</p>
<p>外部调用只能通过接口进行调用，而外部调用是不知道内部具体实现的，也就是说<strong>外部调用和内部实现是被接口隔离开的</strong>。</p>
<h3 id="1-1-4-接口的好处"><a href="#1-1-4-接口的好处" class="headerlink" title="1.1.4 接口的好处"></a>1.1.4 接口的好处</h3><p>由于外部调用和内部实现被接口隔离开了，<strong>只要接口不变，内部实现的变化就不会影响到外部应用</strong>，从而使得系统更灵活，具有更好的扩展性和可维护性，即 <strong>“接口是系统可插拔性的保证”</strong></p>
<h3 id="1-1-5-接口和抽象类的选择"><a href="#1-1-5-接口和抽象类的选择" class="headerlink" title="1.1.5 接口和抽象类的选择"></a>1.1.5 接口和抽象类的选择</h3><p>接口是特殊的抽象类，日常开发使用中，<strong>优先使用接口</strong>。<strong>如既要定义子类行为，又要为子类提供公用的功能时，使用抽象类。</strong></p>
<h2 id="1-2-面向接口编程"><a href="#1-2-面向接口编程" class="headerlink" title="1. 2 面向接口编程"></a>1. 2 面向接口编程</h2><p>在 Java 项目程序设计中，一般会将整体架构分为不同的层级和模块，一般为三层，分别为表现层（UI 层、视图层、界面层）、业务逻辑层（biz 层、service 层）、数据层（持久层），层级之间通过接口调用来通讯。</p>
<p>在每层中，又分为很多模块，每个模块对外也是一个整体，对外也是提供接口服务，其他地方需要用到此模块功能时，只需要进行接口调用就行了。即：<strong>“接口是被其隔离部分的外观”</strong>。</p>
<img src="/2022/09/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20221016002612355.png" alt="image-20221016002612355" style="zoom: 50%;">

<p>在同一层内部各个模块的交互也是通过接口调用进行。</p>
<img src="/2022/09/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20221016002658296.png" alt="image-20221016002658296" style="zoom:67%;">

<p>其中，所谓组件，<strong>就是能完成一定功能的封装体</strong>。小到一个类，大到一个系统，都可以称之为组件，一个大的系统是由多个小系统组成。事实上，从设计的角度看，系统、子系统、模块、组件等说的其实是同一回事情，都是完成一定功能的封装体，只不过功能多少不同而已。</p>
<p>延续刚才的思路，无论是业务层、业务模块或者一个组件，都是一个被接口隔离的整体，即，接口的隔离体。</p>
<img src="/2022/09/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20221016002741465.png" alt="image-20221016002741465" style="zoom:50%;">

<p>接下来，讨论一个问题，<strong>如何在程序中使用接口，做到面向接口编程？</strong></p>
<h2 id="1-3-非设计模式的方案"><a href="#1-3-非设计模式的方案" class="headerlink" title="1. 3 非设计模式的方案"></a>1. 3 非设计模式的方案</h2><p>例子：假设有个接口 <code>Api</code>，实现类 <code>ApiImpl</code>，客户端如何使用？</p>
<p>一般使用方法是，在客户端创建一个 <code>Impl</code> 的实例，然后将其赋值给 <code>Api</code> 的接口变量，然后客户端可以通过使用这个变量来操作接口的功能。</p>
<img src="/2022/09/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20221016002815604.png" alt="image-20221016002815604" style="zoom:50%;">

<p>代码示例：</p>
<p>1 定义接口 Api</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Api.java v1.0 2022/9/28 23:44 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 某个接口(通用的 、 抽象的 、 非具体的功能)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Api</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 某个具体的功能方法的定义，用test来演示一下。</span></span><br><span class="line"><span class="comment">     * 这里的功能很简单，把传入的s打印输出即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 任意想要打印输出的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String s)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2 实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ApiImpl.java v1.0 2022/9/28 23:47 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiImpl</span> <span class="keyword">implements</span> <span class="title class_">Api</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对接口的实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 任意想要打印输出的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String s)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Now In Impl. The input s=="</span> + s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3 客户端，接口不能直接使用，需要使用接口的实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Client.java v1.0 2022/9/28 23:49 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 客户端：测试使用Api接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Api</span> <span class="variable">api</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiImpl</span>();</span><br><span class="line">        api.test(<span class="string">"This is test!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-4-存在的问题"><a href="#1-4-存在的问题" class="headerlink" title="1.4 存在的问题"></a>1.4 存在的问题</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Api</span> <span class="variable">api</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiImpl</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>从客户端对接口能力的使用来看，<strong>客户端不但知道了接口，同时还知道了具体的实现就是 ApiImpl。而接口的思想是 “封装隔离”，而 ApiImpl 这个实现类，应该是被接口 Api 封装并同客户端隔离开的</strong>，也就是说，<strong>客户端根本就不应该知道具体的实现类是 Impl</strong>。</p>
<p>从封装隔离的角度看，如果将客户端中对接口的实现类去除的话，如何使用接口能力？</p>
<blockquote>
<p>以上问题还可以描述为：</p>
<p>在 Java 编程中，出现只知接口而不知实现，该怎么办？<br>就像现在的 Client，它知道要使用 Api 接口，但是不知由谁实现，也不知道如何实现，从而得不到接口对象，就无法使用接口，该怎么办呢？</p>
</blockquote>
<h1 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2 简单工厂模式"></a>2 简单工厂模式</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>简单工厂模式（Simple Factory Pattern）又称为静态工厂方法（Static Factory Pattern）属于类创建型模式。提供一个创建对象实例的能力，无需关心其内部具体实现。被创建的实例的类型可以是接口、抽象类，也可以是具体的类。</p>
<h2 id="2-2-简单工厂模式解决问题思路"><a href="#2-2-简单工厂模式解决问题思路" class="headerlink" title="2.2 简单工厂模式解决问题思路"></a>2.2 简单工厂模式解决问题思路</h2><p>解决<a href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">上述问题</a>的一个简单方法就是使用简单工厂模式。</p>
<p>上面问题描述中，封装隔离的原则是不能让模块外部知道模块内部的具体实现，但是在模块内部可以知道这些信息，并且创建接口是需要知道具体的实现类。</p>
<p>按照这个思路，可以在模块内部<strong>新建一个类</strong>，在这个类中创建接口，通过这个新建类的方法来创建接口并且返回给客户端。通过这种方式，外部应用只需要根据这个类可以获取相应的接口对象，获得接口能力。这个<strong>新建类</strong>的对象就是简单工厂（Factory）。</p>
<p>通过这个方法，客户端只需要和 Factory 对接，然后创建接口，使用模块内提供的能力，而无需关心内部模块的具体实现逻辑。</p>
<h2 id="2-3-结构说明"><a href="#2-3-结构说明" class="headerlink" title="2.3 结构说明"></a>2.3 结构说明</h2><img src="/2022/09/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20221016002836879.png" alt="image-20221016002836879" style="zoom:50%;">

<blockquote>
<p><code>Api</code>: 定义客户所需要的功能接口<br><code>Impl</code>: 具体实现 Api 的实现类，可能会有多个<br><code>Factory</code>: 工厂，选择合适的实现类来创建 Api 接口对象<br><code>Client</code>: 客户端，通过 Factory 去获取 Api 接口对象，然后面向 Api 接口编程</p>
</blockquote>
<h2 id="2-4-代码示例"><a href="#2-4-代码示例" class="headerlink" title="2.4 代码示例"></a>2.4 代码示例</h2><p><u>Api.java</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Api.java v1.0 2022/10/1 00:12 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 接口的定义，该接口可以通过简单工厂来创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Api</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意，具体的功能方法的定义</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 示意，需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String s)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><u>ApiImplA.java</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ApiImplA.java v1.0 2022/10/1 00:14 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 接口的具体实现对象A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiImplA</span> <span class="keyword">implements</span> <span class="title class_">Api</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现功能的代码，示意一下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 示意，需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String s)</span> {</span><br><span class="line">        System.out.println(<span class="string">"ImplA s=="</span> + s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><u>ApiImplB.java</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ApiImplB.java v1.0 2022/10/1 00:14 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 接口的具体实现对象B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiImplB</span> <span class="keyword">implements</span> <span class="title class_">Api</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现功能的代码，示意一下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 示意，需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String s)</span> {</span><br><span class="line">        System.out.println(<span class="string">"ImplB s=="</span> + s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><u>Factory.java</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Factory.java v1.0 2022/10/1 00:16 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 工厂类，用来创造Api对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的创造Api对象的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition 示意，从外部传入的选择条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创造好的Api对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Api <span class="title function_">createApi</span><span class="params">(<span class="type">int</span> condition)</span> {</span><br><span class="line">        <span class="comment">//应该根据某些条件去选择究竟创建哪一个具体的实现对象，</span></span><br><span class="line">        <span class="comment">//这些条件可以从外部传入，也可以从其它途径获取。</span></span><br><span class="line">        <span class="comment">//如果只有一个实现，可以省略条件，因为没有选择的必要。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//示意使用条件</span></span><br><span class="line">        <span class="type">Api</span> <span class="variable">api</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (condition == <span class="number">1</span>) {</span><br><span class="line">            api = <span class="keyword">new</span> <span class="title class_">ApiImplA</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">2</span>) {</span><br><span class="line">            api = <span class="keyword">new</span> <span class="title class_">ApiImplB</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> api;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><u>Client.java</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Client.java v1.0 2022/10/1 00:19 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 客户端，使用Api接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//通过简单工厂来获取接口对象</span></span><br><span class="line">        <span class="type">Api</span> <span class="variable">api</span> <span class="operator">=</span> Factory.createApi(<span class="number">1</span>);</span><br><span class="line">        api.operation(<span class="string">"正在使用简单工厂"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-5-重写方案"><a href="#2-5-重写方案" class="headerlink" title="2.5 重写方案"></a>2.5 重写方案</h2><p>使用简单工厂模式重写前面提到的<a href="#%E9%9D%9E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%A1%88">方案</a>，主要是创建一个简单工厂对象，让简单工厂来负责创建接口对象，然后通过客户端来获取接口对象，而不用由客户端再去创建接口对象。</p>
<img src="/2022/09/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20221016002857256.png" alt="image-20221016002857256" style="zoom:50%;">

<p>1 定义接口 + 实现类 与前面 例子一致，参见<a href="#%E9%9D%9E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%A1%88">详情</a></p>
<p>2 创建简单工厂类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Factory.java v1.0 2022/10/1 00:31 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 工厂类，用来创造Api对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的创造Api对象的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创造好的Api对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Api <span class="title function_">createApi</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//由于只有一个实现，就不用条件判断了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiImpl</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3 客户端使用工厂类，不需要再自己去创建接口类对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Client.java v1.0 2022/9/28 23:49 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 客户端：测试使用Api接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//Api api = new ApiImpl();</span></span><br><span class="line">        <span class="comment">//api.test("This is test!");</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Api</span> <span class="variable">api</span> <span class="operator">=</span> Factory.createApi();</span><br><span class="line">        api.test(<span class="string">"This is test!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端通过简单工厂创建了一个实现接口的对象，然后面向接口编程，<strong>从客户端来看，它根本就不知道具体的实现是什么，也不知道是如何实现的，它只知道通过工厂获得了一个接口对象，然后就能通过这个接口来获取想要的功能</strong>。</p>
<p>其实简单工厂在实际工作当中使用的比较少，而是帮助我们理解面向接口编程，只用到了接口多态的特性，并没有体现出 “封装隔离”。</p>
<h1 id="3-进一步理解"><a href="#3-进一步理解" class="headerlink" title="3 进一步理解"></a>3 进一步理解</h1><p><strong>接口是用来封装隔离具体的实现的，目标就是不要让客户端知道封装体内部的具体实现</strong>。简单工厂的位置是位于封装体内，也就是<strong>简单工厂是跟接口和具体的实现在一起的，算是封装体内部的一个类，所以简单工厂知道具体的实现类是没有关系的</strong>。</p>
<p>对于客户端而言，只需要了解接口 Api 和简单工厂 Factory，通过 Factory 就可以使用 Api 的能力，而无需了解具体实现。所以看似简单的把 “new Impl ()” 从客户端里移动到了简单工厂里面，其实是有质的变化。</p>
<h2 id="3-1-认识简单工厂"><a href="#3-1-认识简单工厂" class="headerlink" title="3.1 认识简单工厂"></a>3.1 认识简单工厂</h2><h3 id="3-1-1-简单工厂的功能"><a href="#3-1-1-简单工厂的功能" class="headerlink" title="3.1.1 简单工厂的功能"></a>3.1.1 简单工厂的功能</h3><p>通过前面的示例，简单工厂一般用来创建接口的实例。其实不仅如此，简单工厂还可以创建抽象类，具体的类的实例。</p>
<h3 id="3-1-2-静态工厂"><a href="#3-1-2-静态工厂" class="headerlink" title="3.1.2 静态工厂"></a>3.1.2 静态工厂</h3><p>使用简单工厂时，一般不用创建工厂类的实例（没必要），而是将工厂类实现为一个工具类，直接使用静态方法调用接口。此时也将简单工厂称为静态工厂。</p>
<blockquote>
<p>为避免客户端直接创建工厂类的实例，可以将构造方法手动改为私有化</p>
</blockquote>
<h3 id="3-1-3-简单工厂创建对象的范围"><a href="#3-1-3-简单工厂创建对象的范围" class="headerlink" title="3.1.3 简单工厂创建对象的范围"></a>3.1.3 简单工厂创建对象的范围</h3><p>理论上，简单工厂可以创建任意对象，但在实际使用中，建议创建对象的范围不要太大，建议创建的对象为一个独立的组件或者一个独立的模块，即，一个组件或者一个模块对应一个工厂。避免工厂类的职责不明，大杂烩。</p>
<h3 id="3-1-4-简单工厂的命名建议"><a href="#3-1-4-简单工厂的命名建议" class="headerlink" title="3.1.4 简单工厂的命名建议"></a>3.1.4 简单工厂的命名建议</h3><p><strong><u>工厂类名建议：</u></strong></p>
<blockquote>
<p>“模块名称 + Factory”，如：用户模块的工厂称为 -&gt; UserFacotry</p>
</blockquote>
<p><strong><u>方法名建议：</u></strong></p>
<blockquote>
<p>“get + 接口名称 或者”，如：接口名称为 UserApi -&gt; getUserApi 或 createUserApi</p>
<p>不建议命名 “new + 接口名称” ，其中 new 在 java 中为关键词，通过工厂来获取对象实例，不一定每次都需要创建，如果使用 new，容易造成误解</p>
</blockquote>
<h2 id="3-2-简单工厂中方法的写法"><a href="#3-2-简单工厂中方法的写法" class="headerlink" title="3.2 简单工厂中方法的写法"></a>3.2 简单工厂中方法的写法</h2><p>从客户端的角度来看，接口能力的实例是通过工厂类创建的，但真正实现接口功能的是具体的实现类，并且这些实现类是已经实现好，并不是通过工厂类实现的。简单工厂的方法其实是：<strong>实现了选择一个合适的实现类来使用</strong>。</p>
<p>所以工厂方法中实现的是 “如何选择合适的实现类”，大概有以下几种思路：</p>
<blockquote>
<ul>
<li>由客户端 client 传入参数</li>
<li>配置文件配置参数，由配置文件获取判断的值</li>
<li>来源于缓存等运行期的值</li>
</ul>
</blockquote>
<p>如客户端传入参数的例子</p>
<p>1 接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Api</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意，具体的功能方法的定义</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 示意，需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String s)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2 接口的两种实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiImplA</span> <span class="keyword">implements</span> <span class="title class_">Api</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现功能的代码，示意一下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 示意，需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String s)</span> {</span><br><span class="line">        System.out.println(<span class="string">"ImplA s=="</span> + s);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiImplB</span> <span class="keyword">implements</span> <span class="title class_">Api</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现功能的代码，示意一下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 示意，需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String s)</span> {</span><br><span class="line">        System.out.println(<span class="string">"ImplB s=="</span> + s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3 工厂类的方法通过参数来判断具体创建哪个接口实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的创造Api对象的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition 示意，从外部传入的选择条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创造好的Api对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Api <span class="title function_">createApi</span><span class="params">(<span class="type">int</span> condition)</span> {</span><br><span class="line">        <span class="comment">//应该根据某些条件去选择究竟创建哪一个具体的实现对象，</span></span><br><span class="line">        <span class="comment">//这些条件可以从外部传入，也可以从其它途径获取。</span></span><br><span class="line">        <span class="comment">//如果只有一个实现，可以省略条件，因为没有选择的必要。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//示意使用条件</span></span><br><span class="line">        <span class="type">Api</span> <span class="variable">api</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (condition == <span class="number">1</span>) {</span><br><span class="line">            api = <span class="keyword">new</span> <span class="title class_">ApiImplA</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">2</span>) {</span><br><span class="line">            api = <span class="keyword">new</span> <span class="title class_">ApiImplB</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> api;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4 客户端根据需要传入对应的参数</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//通过简单工厂来获取接口对象</span></span><br><span class="line">        <span class="type">Api</span> <span class="variable">api</span> <span class="operator">=</span> Factory.createApi(<span class="number">1</span>);</span><br><span class="line">        api.operation(<span class="string">"正在使用简单工厂"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种方法有个非常明显的缺点：由于是从客户端在调用工厂的时候，传入选择的参数，<strong>这就说明客户端必须知道每个参数的含义，也需要理解每个参数对应的功能处理</strong>。这就<strong>要求必须在一定程度上，向客户暴露一定的内部实现细节</strong>。</p>
<h2 id="3-3-简单工厂的优缺点"><a href="#3-3-简单工厂的优缺点" class="headerlink" title="3.3 简单工厂的优缺点"></a>3.3 简单工厂的优缺点</h2><p><strong><u>优点：</u></strong></p>
<blockquote>
<ul>
<li>封装：简单工厂虽然很简单，但是非常有好地实现了组件的封装，<strong>然后让组件外部能真正面向接口编程</strong>。</li>
<li>解耦：<strong>通过简单工厂，实现了客户端和具体实现类的解耦</strong>。如同上面的例子，客户端根本就不知道具体是由谁来实现，也不知道具体是如何实现的，客户端只是通过工厂获取它需要的接口对象。</li>
</ul>
</blockquote>
<p><strong><u>缺点：</u></strong></p>
<blockquote>
<ul>
<li>增加复杂度：如果通过客户端的参数来选择具体的实现类，那么就必须让客户端能理解各个参数所代表的具体功能和含义，这会增加客户端使用的难度，也部分暴露了内部实现，这种情况可以选用可配置的方式来实现。</li>
<li>不方便拓展：私有化简单工厂的构造方法，使用静态方法来创建接口，也就不能通过写简单工厂类的子类来改变创建接口的方法的行为。</li>
</ul>
</blockquote>
<h2 id="3-4-思考"><a href="#3-4-思考" class="headerlink" title="3.4 思考"></a>3.4 思考</h2><h3 id="3-4-1-简单工厂的本质"><a href="#3-4-1-简单工厂的本质" class="headerlink" title="3.4.1 简单工厂的本质"></a>3.4.1 简单工厂的本质</h3><p>简单工厂的本质是：选择实现</p>
<p><strong>注意简单工厂的重点在选择，实现是已经做好了的。</strong>就算实现再简单，也要由具体的实现类来实现，而不是在简单工厂里面来实现。<strong>简单工厂的目的在于为客户端来选择相应的实现，从而使得客户端和实现之间解耦</strong>，这样一来，具体实现发生了变化，就不用变动客户端了，这个变化会被简单工厂吸收和屏蔽掉。</p>
<p><strong>实现简单工厂的难点就在于 “如何选择” 实现</strong>，前面讲到了几种传递参数的方法，都属于静态的参数，还可实现成动态的参数。比如：在运行期间，由工厂去读取某个内存的值，或者是去读取数据库中的值，然后根据这个值来选择具体的实现等等。</p>
<h3 id="3-4-2-使用场景"><a href="#3-4-2-使用场景" class="headerlink" title="3.4.2 使用场景"></a>3.4.2 使用场景</h3><ol>
<li><strong>如果想要完全封装隔离具体实现，让外部只能通过接口来操作封装体</strong>，那么可以选用简单工厂，让客户端通过工厂来获取相应的接口，而无需关心具体实现；</li>
<li><strong>如果想要把对外创建对象的职责集中管理和控制</strong>，可以选用简单工厂，一个简单工厂可以创建很多的、不相关的对象，可以把对外创建对象的职责集中到一个简单工厂来，从而实现集中管理和控制。</li>
</ol>
<h2 id="3-5-相关设计模式"><a href="#3-5-相关设计模式" class="headerlink" title="3.5 相关设计模式"></a>3.5 相关设计模式</h2><h3 id="3-5-1-简单工厂和抽象工厂"><a href="#3-5-1-简单工厂和抽象工厂" class="headerlink" title="3.5.1 简单工厂和抽象工厂"></a>3.5.1 简单工厂和抽象工厂</h3><p><strong>简单工厂是用来选择实现的</strong>，可以选择任意接口的实现，一个简单工厂可以有多个用于选择并创建对象的方法，多个方法创建的对象可以有关系也可以没有关系。</p>
<p><strong>抽象工厂模式是用来选择产品簇的实现的</strong>，也就是说一般抽象工厂里面有多个用于选择并创建对象的方法，<strong>但是这些方法所创建的对象之间通常是有关系的</strong>，这些被创建的对象通常是构成一个产品簇所需要的部件对象。</p>
<p>所以从某种意义上来说，简单工厂和抽象工厂是类似的，<strong>如果抽象工厂退化成为只有一个实现，不分层次，那么就相当于简单工厂了</strong>。</p>
<h3 id="3-5-2-简单工厂和工厂方法模式"><a href="#3-5-2-简单工厂和工厂方法模式" class="headerlink" title="3.5.2 简单工厂和工厂方法模式"></a>3.5.2 简单工厂和工厂方法模式</h3><p>简单工厂和工厂方法模式也是非常类似的。<strong>工厂方法的本质也是用来选择实现的，跟简单工厂的区别在于工厂方法是把选择具体实现的功能延迟到子类去实现</strong>。如果把工厂方法中选择的实现放到父类直接实现，那就等同于简单工厂。</p>
<h3 id="3-5-3-简单工厂和创建型模式"><a href="#3-5-3-简单工厂和创建型模式" class="headerlink" title="3.5.3 简单工厂和创建型模式"></a>3.5.3 简单工厂和创建型模式</h3><p><strong>简单工厂的本质是选择实现</strong>，所以它可以跟其它任何能够具体的创建对象实例的模式配合使用，比如：单例模式、原型模式、生成器模式等等。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>创建型模式</tag>
        <tag>简单工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>算法的时间与空间复杂度详解</title>
    <url>/2022/08/13/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</p>
<p>那么应该如何去衡量不同算法之间的优劣呢？</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<p>一般是从算法程序占用的<strong>时间</strong>和<strong>空间</strong>两个维度去衡量：</p>
<ul>
<li>时间维度：是指执行算法所消耗的时间，一般用<strong>时间复杂度</strong>来描述； </li>
<li>空间维度：是指执行算法所需要占用的内存空间，一般用<strong>空间复杂度</strong>来描述；</li>
</ul>
<p>因此评价算法效率优劣一般是看它的时间复杂度与空间复杂度情况。而这两者无法兼得，需要用户从中找出一个平衡点。</p>
<p>接下来记录下如何计算算法的时间复杂度与空间复杂度。</p>
<h1 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2 时间复杂度"></a>2 时间复杂度</h1><p>一般在代码运行中统计一个程序运行耗时，可以通过代码的时间埋点，然后将代码执行一遍，就可统计出程序的实际耗时。那么如此是否可以用来计算算法的时间复杂度？</p>
<p>其实是可以的。但是这不能用来作为抽象的、统一标准的计算方法。因为其中有非常多的变量，如程序的运行环境的差距（配置高的机器与配置低的机器对于相同的代码运行速度也有非常大的差距）、如算法执行的数据量（数据规模大小对算法执行速度的影响也非常大）。</p>
<p>因此，我们使用一种更为通用的、抽象的方法：<strong>大 O 符号表示法</strong>，即 <code>T(n) = O(f(n))</code></p>
<p>例子：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">{</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过<strong>大 O 符号表示法</strong> ，这段代码的时间复杂度为：<strong>O(n)</strong> ，如何计算？</p>
<p>在<strong>大 O 符号表示法</strong>中，时间复杂度的公式是： <code>T(n) = O(f(n))</code>，其中 <code>f(n)</code> 表示每行代码执行次数之和，而 <strong>O</strong> 表示正比例关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p>
<p>继续看上面的例子，假设每行代码的执行时间都是一样的，我们用<strong>一个单位时间</strong>来表示，那么这个例子的第一行耗时是<strong>一个单位时间</strong>，第三行的执行时间是 <strong>n 个单位时间</strong>，第四行的执行时间也是 <strong>n 个单位时间</strong>（第二行和第五行是符号，暂时忽略），那么总时间就是一个<strong>单位时间 + n 个单位时间 + n 个单位时间</strong> ，即 <strong>(1+2n) 个单位时间</strong>，即：<code>T(n) = (1+2n)个单位时间</code>，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以将这个算法的时间复杂度<strong>简化</strong>为：<code>T(n) = O(n)</code></p>
<p><strong>重点解释下为何可以简化？</strong><br>如上所述，大 O 符号表示法描述的是算法<strong>渐进时间复杂度</strong>，表示的<strong>代码执行时间的增长变化趋势</strong>，而不是真实的代码的具体执行时间。<br>在例子中的 <code>T(n) =Time (1+2n)</code>, 当 n 趋于无限大时，其中的常量 1 与倍数 2 都没有意义了。所以可以直接简化为 <code>T(n) = O(n)</code></p>
<blockquote>
<p>常见的时间复杂度：</p>
<ul>
<li>常数阶 O (1)</li>
<li> 对数阶 O (logN)</li>
<li> 线性阶 O (n)</li>
<li> 线性对数阶 O (nlogN)</li>
<li> 平方阶 O (n²)</li>
<li> 立方阶 O (n³)</li>
<li>K 次方阶 O (n^k)</li>
<li> 指数阶 (2^n)</li>
</ul>
<p>复杂度的顺序为：</p>
<p>O(1) &lt; O(logN) &lt; O(n) &lt; O(nlogN) &lt; O(n²) &lt; O(n³) &lt; O(n^k) &lt; (2^n)</p>
<p>时间复杂度越来越大，执行的效率越来越低</p>
</blockquote>
<h2 id="2-1-常数阶O-1"><a href="#2-1-常数阶O-1" class="headerlink" title="2.1 常数阶O(1)"></a>2.1 常数阶 O (1)</h2><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 <code>O(1)</code>，如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="type">int</span> m = i + j;</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 **O (1)** 来表示它的时间复杂度。</p>
<h2 id="2-2-对数阶O-logN"><a href="#2-2-对数阶O-logN" class="headerlink" title="2.2 对数阶O(logN)"></a>2.2 对数阶 O (logN)</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">{</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如上代码，在 while 循环里面，每次都将 <code>i</code> 乘以 2，得到结果 <code>i </code>距离 <code>n</code> 就越来越近了。假设循环 <code>x</code> 次之后，<code>i </code>就大于 <code>n</code>，此时这个循环就退出了，也就是说 <code>2</code> 的 <code>x</code> 次方大于等于 <code>n</code>，那么<code> x = log2^n</code> </p>
<p>也就是说当循环 <code>log2^n</code> 次后，这个代码的 while 循环就结束了。因此这个代码的时间复杂度为：<strong>O(logn)</strong></p>
<h2 id="2-3-线性阶O-n"><a href="#2-3-线性阶O-n" class="headerlink" title="2.3 线性阶O(n)"></a>2.3 线性阶 O (n)</h2><p>与开始头的例子一致</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">{</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码，for 循环里面的代码会执行 <code>n</code> 遍，因此它消耗的时间是随着 <code>n</code> 的变化而变化的，因此这类代码都可以用 **O (n)** 来表示它的时间复杂度。</p>
<h2 id="2-4-线性对数阶O-nlogN"><a href="#2-4-线性对数阶O-nlogN" class="headerlink" title="2.4 线性对数阶O(nlogN)"></a>2.4 线性对数阶 O (nlogN)</h2><p>线性对数阶 <code>O(nlogN) </code>其实是将时间复杂度为 <code>O(logn)</code> 的代码循环 <code>n</code> 遍，那么它的时间复杂度就是<code> n * O(logN)</code>，也就是 **O (nlogN)**。如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">{</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    {</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-5-平方阶O-n²"><a href="#2-5-平方阶O-n²" class="headerlink" title="2.5 平方阶O(n²)"></a>2.5 平方阶 O (n²)</h2><p>平方阶 <code>O(n²) </code>就更容易理解了，把 <code>O(n)</code> 的代码再嵌套循环一遍，它的时间复杂度就是 **O (n²) **。如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">{</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    {</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-6-立方阶O-n³-amp-K次方阶O-n-k"><a href="#2-6-立方阶O-n³-amp-K次方阶O-n-k" class="headerlink" title="2.6 立方阶O(n³) &amp; K次方阶O(n^k)"></a>2.6 立方阶 O (n³) &amp; K 次方阶 O (n^k)</h2><p>参考上面的 O (n²) 去理解，O (n³) 相当于三层 <code>n</code> 循环，其它的类似。</p>
<h2 id="2-7-指数阶-2-n"><a href="#2-7-指数阶-2-n" class="headerlink" title="2.7 指数阶(2^n)"></a>2.7 指数阶 (2^n)</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)    <span class="comment">//基本情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 基本情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码为<strong>斐波那契数列</strong><br>显然运行次数，<code>T(0) = T(1) = 1</code>，同时<code> T(n) = T(n - 1) + T(n - 2) + 1</code>，这里的 <code>1</code> 是其中的加法算一次执行。通过归纳证明法可以证明，当 <code>n &gt;= 1</code> 时 <code>T(n) &lt; (5/3)^n</code>，同时当 <code>n &gt; 4</code> 时 <code>T(n) &gt;= (3/2)^n</code>，简化后为 <strong>O(2^n)</strong></p>
<h2 id="2-8-常用排序算法时间复杂度统计"><a href="#2-8-常用排序算法时间复杂度统计" class="headerlink" title="2.8 常用排序算法时间复杂度统计"></a>2.8 常用排序算法时间复杂度统计</h2><p><img src="/2022/08/13/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%A6%E8%A7%A3/image-20220813161637101.png" alt="image-20220813161637101"></p>
<h1 id="3-空间复杂度"><a href="#3-空间复杂度" class="headerlink" title="3 空间复杂度"></a>3 空间复杂度</h1><p>同时间复杂度不是统计程序运行的具体耗时，空间复杂度也不是统计程序运行的具体占用空间。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，用 <strong>S(n)</strong> 来定义。（时间复杂度为 **T (n)**）</p>
<p>空间复杂度比较常用的有：<strong>O(1)、O(n)、O(n²)</strong></p>
<h2 id="3-1-空间复杂度O-1"><a href="#3-1-空间复杂度O-1" class="headerlink" title="3.1 空间复杂度O(1)"></a>3.1 空间复杂度 O (1)</h2><p>空间复杂度为 O (1) 的情况的示例代码与时间复杂度为 O (1) 的实例代码一致：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="type">int</span> m = i + j;</span><br></pre></td></tr></tbody></table></figure>

<p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 <strong>S(n) = O(1)</strong></p>
<h2 id="3-2-空间复杂度O-n"><a href="#3-2-空间复杂度O-n" class="headerlink" title="3.2 空间复杂度O(n)"></a>3.2 空间复杂度 O (n)</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>[] m = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中，只有创建 <code>int</code> 数组分配空间时与 <code>n</code> 的大小有关，而 for 循环内没有再分配新的空间，因此，对应的空间复杂度为 <strong>S(n) = O(n)</strong></p>
<h2 id="3-3-空间复杂度O-n²"><a href="#3-3-空间复杂度O-n²" class="headerlink" title="3.3 空间复杂度O(n²)"></a>3.3 空间复杂度 O (n²)</h2><p>随着数据量的变化，内存消耗为平方变化，如：</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="type">int</span>[n][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">        arr[i][j] = <span class="keyword">new</span> <span class="built_in">Random</span>().<span class="built_in">nextInt</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上二维数组中，当 <code>n+1</code> 的时候，<code>arr</code> 数组大小从 <code>n²</code> 变为了 <code>(n+1)²</code>，其它空间复杂度以此类。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实无论是时间复杂度还是空间复杂度，都是在考虑当 <code>n</code> 变化的时候时间或者空间会呈什么样的<strong>变化趋势</strong>，并最终确定时间和空间的上界问题。</p>
<ul>
<li>考虑<strong>时间复杂度</strong>的时候，我们简化为思考 <code>n+1</code> 的时候，循环次数如何变化，如果不变则 <code>O(1)</code>，线性则 <code>O(n)</code>，对数则 <code>log(n)</code>… 以此类推。也就是说把 <code>n</code> 当作问题规模，当 <code>n</code> 变化的时候，执行次数的变化呈现什么规律。</li>
<li>考虑<strong>空间复杂度</strong>的时候，我们简化为思考 <code>n+1</code> 的时候，内存消耗的数量如何变化，如果不变则为 <code>O(1)</code>，线性则为 <code>O(n)</code>，平方则为 <code>O(n²)</code>… 以此类推。也就是说当 <code>n</code> 变化的时候，内存消耗的变化呈现什么规律。</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/50479555">算法的时间与空间复杂度 (一看就懂)</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1769988">LeetCode0：学习算法必备知识：时间复杂度与空间复杂度的计算</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/f4cca5ce055a">十分钟搞定时间复杂度</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/lay2017/p/10668311.html">算法时间复杂度、空间复杂度 (大 O 表示法)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂方法模式</title>
    <url>/2023/01/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实际场景"><a href="#1-实际场景" class="headerlink" title="1 实际场景"></a>1 实际场景</h1><h2 id="1-1-组装电脑"><a href="#1-1-组装电脑" class="headerlink" title="1.1 组装电脑"></a>1.1 组装电脑</h2><p>设想一个<strong>组装电脑</strong>的场景，在组装电脑时，需要选着一些配件，如：<code>CPU</code>、硬盘、内存、主板、电源、机箱等。为降低复杂度，目前只考虑 <code>CPU</code> 和主板。</p>
<p>事实上，我们在选择 <code>CPU</code> 的时候，面临一系列的问题，比如：品牌、型号、针脚数目、主频等问题，只有把这些都确定下来，才能确定具体的 <code>CPU</code>。同样，在选择主板的时候，也有一系列的问题，比如：品牌、芯片组、集成芯片、总线频率等问题，也只有这些都确定了，才能确定具体的主板。</p>
<p>在最终确定这个装机方案之前，还需要整体考虑各个配件之间的兼容性，比如：<code>CPU</code> 和主板，如果 <code>CPU</code> 针脚数和主板提供的 <code>CPU</code> 插口不兼容，是无法组装的。也就是说，<strong>装机方案是有整体性的，里面选择的各个配件之间是有关联的</strong>。</p>
<p>对于装机工程师而言，他只知道组装一台电脑，需要相应的配件，但是具体使用什么样的配件，还得由客户说了算。<strong>也就是说装机工程师只是负责组装，而客户负责选择装配所需要的具体的配件。</strong>因此，当装机工程师为不同的客户组装电脑时，只需要按照客户的装机方案，去获取相应的配件，然后组装即可。</p>
<p>如何利用代码模拟选择配件进行装机的过程？</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h2 id="1-2-非抽象工厂的解决方案"><a href="#1-2-非抽象工厂的解决方案" class="headerlink" title="1.2 非抽象工厂的解决方案"></a>1.2 非抽象工厂的解决方案</h2><p>考虑客户的功能，需要选择自己需要的 <code>CPU</code> 和主板，然后告诉装机工程师自己的选择，接下来就等着装机工程师组装机器了。</p>
<p>对装机工程师而言，只是知道 <code>CPU</code> 和主板的接口，而不知道具体实现，很明显可以用上简单工厂或工厂方法模式，为了简单，这里选用简单工厂。客户告诉装机工程师自己的选择，然后装机工程师会通过相应的工厂去获取相应的实例对象。</p>
<p>1、<code>cpu</code> 和主板的接口定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> CpuApi.java v1.0 2023/1/7 22:42 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> CPU的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CpuApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，CPU具有运算功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> MainboardApi.java v1.0 2023/1/7 22:43 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 主板的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MainboardApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，主板可以对接CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">installCpu</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、两个品牌的 <code>cpu</code> 实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> IntelCpu.java v1.0 2023/1/7 22:45 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Intel cpu的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> <span class="keyword">implements</span> <span class="title class_">CpuApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cpu针脚数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pins</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntelCpu</span><span class="params">(<span class="type">int</span> pins)</span> {</span><br><span class="line">        <span class="built_in">this</span>.pins = pins;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"now in intel cpu, pins="</span> + pins);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> AmdCpu.java v1.0 2023/1/7 22:47 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> amd cpu的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmdCpu</span> <span class="keyword">implements</span> <span class="title class_">CpuApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cpu针脚数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pins</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AmdCpu</span><span class="params">(<span class="type">int</span> pins)</span> {</span><br><span class="line">        <span class="built_in">this</span>.pins = pins;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"now in amd cpu, pins="</span> + pins);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、两个品牌的主板实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> GAMainboard.java v1.0 2023/1/7 22:49 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 技嘉主板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GAMainboard</span> <span class="keyword">implements</span> <span class="title class_">MainboardApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cpu 插槽数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cpuHoles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GAMainboard</span><span class="params">(<span class="type">int</span> cpuHoles)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cpuHoles = cpuHoles;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installCpu</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"now in GAMainboard, couHoles="</span> + cpuHoles);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> MSIMainboard.java v1.0 2023/1/7 22:50 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 微星的主板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MSIMainboard</span> <span class="keyword">implements</span> <span class="title class_">MainboardApi</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cpuHoles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MSIMainboard</span><span class="params">(<span class="type">int</span> cpuHoles)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cpuHoles = cpuHoles;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installCpu</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"now in MSIMainboard, cpuHoles="</span> + cpuHoles);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、<code>cpu</code> 工厂实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> CpuFactory.java v1.0 2023/1/7 22:53 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> cpu简单工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CpuFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建CPU接口对象的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 选择CPU类型的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CPU接口对象的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CpuApi <span class="title function_">createCpuApi</span><span class="params">(<span class="type">int</span> type)</span> {</span><br><span class="line">        <span class="type">CpuApi</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) {</span><br><span class="line">            cpu = <span class="keyword">new</span> <span class="title class_">IntelCpu</span>(<span class="number">1156</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) {</span><br><span class="line">            cpu = <span class="keyword">new</span> <span class="title class_">AmdCpu</span>(<span class="number">939</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>5、主板工厂实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> MainboardFactory.java v1.0 2023/1/7 22:56 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 主板的简单工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainboardFactory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建主板接口对象的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 选择主板类型的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 主板接口对象的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MainboardApi <span class="title function_">createMainboardApi</span><span class="params">(<span class="type">int</span> type)</span> {</span><br><span class="line">        <span class="type">MainboardApi</span> <span class="variable">mainboard</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 根据参数来选择并创建相应的主板对象</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) {</span><br><span class="line">            mainboard = <span class="keyword">new</span> <span class="title class_">GAMainboard</span>(<span class="number">1156</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) {</span><br><span class="line">            mainboard = <span class="keyword">new</span> <span class="title class_">MSIMainboard</span>(<span class="number">939</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> mainboard;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>6、装机工程师的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ComputerEngineer.java v1.0 2023/1/7 23:01 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 装机工程师</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerEngineer</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CpuApi</span>       <span class="variable">cpu</span>       <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的主板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MainboardApi</span> <span class="variable">mainboard</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装机过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cpuType       客户选择所需cpu的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mainboardType 客户选择所需主板的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assembleComputer</span><span class="params">(<span class="type">int</span> cpuType, <span class="type">int</span> mainboardType)</span> {</span><br><span class="line">        <span class="comment">// 1. 准备好装机所需要的配件</span></span><br><span class="line">        prepareHardwares(cpuType, mainboardType);</span><br><span class="line">        <span class="comment">// 2. 组装机器</span></span><br><span class="line">        <span class="comment">// 3. 测试机器</span></span><br><span class="line">        <span class="comment">// 4. 交付客户</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareHardwares</span><span class="params">(<span class="type">int</span> cpuType, <span class="type">int</span> mainboardType)</span> {</span><br><span class="line">        <span class="comment">// 这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span></span><br><span class="line">        <span class="comment">// 可是，装机工程师并不知道如何去创建，怎么办呢？</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接找相应的工厂获取</span></span><br><span class="line">        <span class="built_in">this</span>.cpu = CpuFactory.createCpuApi(cpuType);</span><br><span class="line">        <span class="built_in">this</span>.mainboard = MainboardFactory.createMainboardApi(mainboardType);</span><br><span class="line">        <span class="comment">// 测试配件是否好用</span></span><br><span class="line">        <span class="built_in">this</span>.cpu.calculate();</span><br><span class="line">        <span class="built_in">this</span>.mainboard.installCpu();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>7、客户端实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Client.java v1.0 2023/1/7 23:09 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 实例化装机工程师对象</span></span><br><span class="line">        <span class="type">ComputerEngineer</span> <span class="variable">engineer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerEngineer</span>();</span><br><span class="line">        <span class="comment">// 客户告诉装机工程师配件方案，装机工程师按要求进行组装</span></span><br><span class="line">        engineer.assembleComputer(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-有何问题"><a href="#1-3-有何问题" class="headerlink" title="1.3 有何问题"></a>1.3 有何问题</h2><p>虽然上面的实现，通过简单工厂解决解决了：对于装机工程师无需感知 <code>CPU</code> 和主板的具体实现的问题。但还有一个问题没有解决：没有解决 <code>CPU</code> 对象与主板对象之间的关系匹配问题。而在上面的实现中，并没有维护这种关联关系，若客户随意选择 <code>CPU</code> 和主板的类型，可能导致针脚不配位的问题。</p>
<p><strong>如何维护对象之间的关系？</strong></p>
<h1 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2 抽象工厂模式"></a>2 抽象工厂模式</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>抽象工厂模式（<code>Abstract Factory Pattern</code>）属于类创建型模式。提供一个创建一系列相关或者相互依赖对象的接口，而无需指定具体的类。</p>
<h2 id="2-2-抽象工厂模式解决问题思路"><a href="#2-2-抽象工厂模式解决问题思路" class="headerlink" title="2.2 抽象工厂模式解决问题思路"></a>2.2 抽象工厂模式解决问题思路</h2><p>上述场景中，实际有两个问题：</p>
<ol>
<li>对于使用者而言，只需要一系列对象的接口，而无需了解对象的具体实现；</li>
<li>对于这些对象是相关的或者说相互依赖，即：创建接口的对象还需要约束这些对象之间的关系；</li>
</ol>
<p>需要明确简单工厂模式、工厂方法模式无法解决上述问题的关键所在：<strong>简单工厂和工厂方法模式关注的单个对象的创建</strong>，如：<code>CPU</code> 如何创建，主板如何创建。无法解决对象之间的关联关系。</p>
<p><strong>解决这个问题的一个解决方案就是抽象工厂模式。</strong>在这个模式里面，会定义一个抽象工厂，在里面虚拟的创建客户端需要的这一系列对象，<strong>所谓虚拟的就是定义创建这些对象的抽象方法，并不去真的实现，然后由具体的抽象工厂的子类来提供这一系列对象的创建</strong>。这样一来可以为同一个抽象工厂提供很多不同的实现，那么创建的这一系列对象也就不一样了，也就是说，<strong>抽象工厂在这里起到一个约束的作用，并提供所有子类的一个统一外观，来让客户端使用</strong>。</p>
<h2 id="2-3-结构说明"><a href="#2-3-结构说明" class="headerlink" title="2.3 结构说明"></a>2.3 结构说明</h2><img src="/2023/01/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20230107235250666.png" alt="image-20230107235250666" style="zoom: 50%;">

<blockquote>
<p><code>AbstractFactory</code>：抽象工厂，定义创建一系列产品对象的操作接口；<br><code>ConcreteFactory</code>：具体的工厂，实现抽象工厂定义的方法，具体操作一系列产品对象的创建；<br><code>AbstractProduct</code>：定义一类产品对象的接口；<br><code>ConcreProduct</code>：具体的产品实现对象，通常在具体工厂里面，会选择具体的产品实现对象，来创建符合抽象工厂定义的方法返回的产品类型的对象；<br><code>Client</code>：客户端，主要使用抽象工厂来获取一系列所需要的产品对象，然后面向这些产品对象的接口编程，以实现需要的功能；</p>
</blockquote>
<h2 id="2-4-示例代码"><a href="#2-4-示例代码" class="headerlink" title="2.4 示例代码"></a>2.4 示例代码</h2><p>1、抽象工厂的定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> AbstractFactory.java v1.0 2023/1/8 00:01 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象工厂的接口，声明创建抽象产品对象的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例方法，创建抽象产品A的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 抽象产品A的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例方法，创建抽象产品B的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 抽象产品B的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、产品定义示意代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> AbstractProductA.java v1.0 2023/1/8 00:01 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象产品A的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractProductA</span> {</span><br><span class="line">    <span class="comment">//定义抽象产品A相关的操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> AbstractProductB.java v1.0 2023/1/8 00:02 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象产品B的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractProductB</span> {</span><br><span class="line">    <span class="comment">//定义抽象产品B相关的操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、具体产品的实现定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ProductA1.java v1.0 2023/1/8 00:03 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 产品A的具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA1</span> <span class="keyword">implements</span> <span class="title class_">AbstractProductA</span> {</span><br><span class="line">    <span class="comment">//实现产品A的接口中定义的操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ProductA2.java v1.0 2023/1/8 00:04 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 产品A的具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA2</span> <span class="keyword">implements</span> <span class="title class_">AbstractProductA</span> {</span><br><span class="line">    <span class="comment">// //实现产品A的接口中定义的操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ProductB1.java v1.0 2023/1/8 00:05 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 产品B的具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB1</span> <span class="keyword">implements</span> <span class="title class_">AbstractProductB</span> {</span><br><span class="line">    <span class="comment">//实现产品B的接口中定义的操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ProductB2.java v1.0 2023/1/8 00:05 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 产品B的具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB2</span> <span class="keyword">implements</span> <span class="title class_">AbstractProductB</span> {</span><br><span class="line">    <span class="comment">//实现产品B的接口中定义的操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、具体工厂的实现 - 维护了不同对象之间的关系</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ConcreteFactory1.java v1.0 2023/1/8 00:06 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 具体的工厂实现对象，实现创建具体的产品对象的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ConcreteFactory2.java v1.0 2023/1/8 00:07 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 具体的工厂实现对象，实现创建具体的产品对象的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>5、客户端实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> FactoryClient.java v1.0 2023/1/8 00:08 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//创建抽象工厂对象</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="comment">//通过抽象工厂来获取一系列的对象，如产品A和产品B</span></span><br><span class="line">        factory.createProductA();</span><br><span class="line">        factory.createProductB();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-5-重写方案"><a href="#2-5-重写方案" class="headerlink" title="2.5 重写方案"></a>2.5 重写方案</h2><p>使用抽象工厂模式重写前面的例子：装机工程师要组装电脑对象，需要一系列的产品对象，比如 <code>CPU</code>、主板等，于是创建一个抽象工厂给装机工程师使用，在这个抽象工厂里面定义抽象的创建 <code>CPU</code> 和主板的方法，<strong>这个抽象工厂就相当于一个抽象的装机方案，在这个装机方案里面，各个配件是能够相互匹配的</strong>。</p>
<img src="/2023/01/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20230108001856205.png" alt="image-20230108001856205" style="zoom:50%;">

<p>1、<code>CPU</code> 与主板的接口定于以及实现同上</p>
<p>2、抽象工厂定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> AbstractFactory.java v1.0 2023/1/8 00:20 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象工厂的接口，声明创建抽象产品对象的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建CPU的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CPU的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> CpuApi <span class="title function_">createCpuApi</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建主板的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 主板的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> MainboardApi <span class="title function_">createMainboardApi</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、装机方案的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Schema1.java v1.0 2023/1/8 00:21 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 装机方案一：Intel 的CPU + 技嘉的主板</span></span><br><span class="line"><span class="comment"> * 这里创建CPU和主板对象的时候，是对应的，能匹配上的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schema1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CpuApi <span class="title function_">createCpuApi</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntelCpu</span>(<span class="number">1156</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MainboardApi <span class="title function_">createMainboardApi</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GAMainboard</span>(<span class="number">1156</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Schema2.java v1.0 2023/1/8 00:21 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 装机方案二：AMD的CPU + 微星的主板</span></span><br><span class="line"><span class="comment"> * 这里创建CPU和主板对象的时候，是对应的，能匹配上的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schema2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CpuApi <span class="title function_">createCpuApi</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmdCpu</span>(<span class="number">939</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MainboardApi <span class="title function_">createMainboardApi</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MSIMainboard</span>(<span class="number">939</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、装机工程师的实现。</p>
<p><strong>装机工程师相当于使用抽象工厂的客户端，虽然是由真正的客户来选择和创建具体的工厂对象，但是使用抽象工厂的是装机工程师对象。</strong></p>
<blockquote>
<p>与前面的实现相比，主要的变化是：从客户端，不再传入选择 <code>CPU</code> 和主板的参数，而是直接传入客户选择并创建好的装机方案对象。<strong>这样就避免了单独去选择 <code>CPU</code> 和主板，客户要选就是一套，就是一个系列</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ComputerEngineer.java v1.0 2023/1/8 00:23 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 装机工程师</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerEngineer</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CpuApi</span>       <span class="variable">cpu</span>       <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的主板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MainboardApi</span> <span class="variable">mainboard</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装机过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schema 客户选择的装机方案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assembleComputer</span><span class="params">(AbstractFactory schema)</span> {</span><br><span class="line">        <span class="comment">//1：首先准备好装机所需要的配件</span></span><br><span class="line">        prepareHardwares(schema);</span><br><span class="line">        <span class="comment">//2：组装机器</span></span><br><span class="line">        <span class="comment">//3：测试机器</span></span><br><span class="line">        <span class="comment">//4：交付客户</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 准备装机所需要的配件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schema 客户选择的装机方案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareHardwares</span><span class="params">(AbstractFactory schema)</span> {</span><br><span class="line">        <span class="comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span></span><br><span class="line">        <span class="comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用抽象工厂来获取相应的接口对象</span></span><br><span class="line">        <span class="built_in">this</span>.cpu = schema.createCpuApi();</span><br><span class="line">        <span class="built_in">this</span>.mainboard = schema.createMainboardApi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下配件是否好用</span></span><br><span class="line">        <span class="built_in">this</span>.cpu.calculate();</span><br><span class="line">        <span class="built_in">this</span>.mainboard.installCpu();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>5、客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Client.java v1.0 2023/1/8 00:25 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//创建装机工程师对象</span></span><br><span class="line">        <span class="type">ComputerEngineer</span> <span class="variable">engineer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerEngineer</span>();</span><br><span class="line">        <span class="comment">//客户选择并创建需要使用的装机方案对象</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">schema</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Schema1</span>();</span><br><span class="line">        <span class="comment">//告诉装机工程师自己选择的装机方案，让装机工程师组装电脑</span></span><br><span class="line">        engineer.assembleComputer(schema);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如同前面的示例，定义了一个抽象工厂 AbstractFactory，在里面定义了创建 CPU 和主板对象的接口的方法，但是在抽象工厂里面，并没有指定具体的 CPU 和主板的实现，也就是无须指定它们具体的实现类。</p>
<p>CPU 和主板是相关的对象，是构建电脑的一系列相关配件，这个抽象工厂就相当于一个装机方案，客户选择装机方案的时候，一选就是一套，CPU 和主板是确定好的，不让客户分开选择，这就避免了出现不匹配的错误。</p>
<h1 id="3-模式讲解"><a href="#3-模式讲解" class="headerlink" title="3 模式讲解"></a>3 模式讲解</h1><h2 id="3-1-认识抽象工厂模式"><a href="#3-1-认识抽象工厂模式" class="headerlink" title="3.1 认识抽象工厂模式"></a>3.1 认识抽象工厂模式</h2><h3 id="3-1-1-功能"><a href="#3-1-1-功能" class="headerlink" title="3.1.1 功能"></a>3.1.1 功能</h3><p>抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口，<strong>一定要注意，这个接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法</strong>，比如上面例子中的 <code>CPU</code> 和主板，都是为了组装一台电脑的相关对象。</p>
<p>从某种意义上看，<strong>抽象工厂其实是一个产品系列，或者是产品簇</strong>。上面例子中的抽象工厂就可以看成是电脑簇，每个不同的装机方案，代表一种具体的电脑系列。</p>
<p>3.1.2 抽象工厂为接口</p>
<p><strong><code>AbstractFactory</code> 在 <code>Java</code> 中通常实现成为接口</strong>，不要被名称所误导，以为是实现成为抽象类，当然，<strong>如果需要为这个产品簇提供公共的功能，也不是不可以把 <code>AbstractFactory</code> 实现成为抽象类</strong>，但一般不这么做。</p>
<blockquote>
<p>关于抽象类与接口选择，可以参考<a href="https://www.cnblogs.com/huche123/p/9048700.html">文章</a></p>
</blockquote>
<h3 id="3-1-3-使用工厂方法"><a href="#3-1-3-使用工厂方法" class="headerlink" title="3.1.3 使用工厂方法"></a>3.1.3 使用工厂方法</h3><p><code>AbstractFactory</code> 定义了创建产品所需要的接口，具体的实现是在实现类里面，通常在实现类里面就需要选择多种更具体的实现，<strong>所以 <code>AbstractFactory</code> 定义的创建产品的方法可以看成是工厂方法，而这些工厂方法的具体实现就延迟到了具体的工厂里面</strong>。也就是说<strong>使用工厂方法来实现抽象工厂</strong>。</p>
<h3 id="3-1-4-产品簇"><a href="#3-1-4-产品簇" class="headerlink" title="3.1.4 产品簇"></a>3.1.4 产品簇</h3><p>由于抽象工厂定义的一系列对象，通常是相关或者相依赖的，这些产品对象就构成了一个产品簇，也就是抽象工厂定义了一个产品簇。这就带来非常大的灵活性，<strong>切换一个产品簇的时候，只要提供不同的抽象工厂实现就好了，也就是说现在是以产品簇做为一个整体被切换</strong>。</p>
<h2 id="3-2-定义可扩展的工厂"><a href="#3-2-定义可扩展的工厂" class="headerlink" title="3.2 定义可扩展的工厂"></a>3.2 定义可扩展的工厂</h2><p>前面组装电脑的示例中，抽象工厂为每一种对象，如 <code>CPU</code>、主板都定义了相应的方法。这有个不灵活的地方，若产品簇中要增加一个对象，所有的具体实现工厂都需要随之改变。</p>
<p>可以有一种不安全（类型强制转换）但是相对灵活的改进方法：将抽象工厂的方法设置为一个带参数的方法，通过参数来判断具体创建何种产品对象；由于只有一个方法，在返回类型上就不能是具体的某个产品类型，只能是某个产品簇的父类或者接口，又或者为 <code>Object</code> 类型。示例代码如下：</p>
<p>1、抽象工厂方法改造</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> AbstractFactory.java v1.0 2023/1/8 21:10 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 可扩展的抽象工厂的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个通用的创建产品对象的方法，为了简单，直接返回Object</span></span><br><span class="line"><span class="comment">     * 也可以为所有被创建的产品定义一个公共的接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 具体创建的产品类型标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建出的产品对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProduct</span><span class="params">(<span class="type">int</span> type)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里要特别注意传入 <code>createProduct</code> 的参数所代表的含义，<strong>这个参数只是用来标识现在是在创建什么类型的产品</strong>，比如标识现在是创建 CPU 还是创建主板，一般这个 type 的含义到此就结束了，不再进一步表示具体是什么样的 CPU 或具体什么样的主板，<strong>也就是说 type 不再表示具体是创建 Intel 的 CPU 还是创建 AMD 的 CPU，这就是一个参数所代表的含义的深度的问题，要注意</strong>。虽然也可以延伸参数的含义到具体的实现上，但这不是可扩展工厂这种设计方式的本意，一般也不这么做。</p>
<p>2、CPU 和主板的实现与前面实例一致：CPU 分为 Intel 和 Amd，主板分为技嘉和微星</p>
<p>3、具体工厂实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Schema1.java v1.0 2023/1/8 21:14 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 装机方案一：Intel 的CPU + 技嘉的主板</span></span><br><span class="line"><span class="comment"> * 这里创建CPU和主板对象的时候，是对应的，能匹配上的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schema1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProduct</span><span class="params">(<span class="type">int</span> type)</span> {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//type为1表示创建CPU，type为2表示创建主板</span></span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>){</span><br><span class="line">            retObj = <span class="keyword">new</span> <span class="title class_">IntelCpu</span>(<span class="number">1156</span>);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>){</span><br><span class="line">            retObj = <span class="keyword">new</span> <span class="title class_">GAMainboard</span>(<span class="number">1156</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retObj;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Schema2.java v1.0 2023/1/8 21:15 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 装机方案二：AMD的CPU + 微星的主板</span></span><br><span class="line"><span class="comment"> * 这里创建CPU和主板对象的时候，是对应的，能匹配上的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schema2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProduct</span><span class="params">(<span class="type">int</span> type)</span> {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//type为1表示创建CPU，type为2表示创建主板</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) {</span><br><span class="line">            retObj = <span class="keyword">new</span> <span class="title class_">AmdCpu</span>(<span class="number">939</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) {</span><br><span class="line">            retObj = <span class="keyword">new</span> <span class="title class_">MSIMainboard</span>(<span class="number">939</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retObj;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、装机工程师的实现，拓展的基本实现与之前有所不同</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> ComputerEngineer.java v1.0 2023/1/8 21:18 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 装机工程师</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerEngineer</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CpuApi</span>       <span class="variable">cpu</span>       <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的主板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MainboardApi</span> <span class="variable">mainboard</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装机过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schema 客户选择的装机方案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assembleComputer</span><span class="params">(AbstractFactory schema)</span> {</span><br><span class="line">        <span class="comment">//1：首先准备好装机所需要的配件</span></span><br><span class="line">        prepareHardwares(schema);</span><br><span class="line">        <span class="comment">//2：组装机器</span></span><br><span class="line">        <span class="comment">//3：测试机器</span></span><br><span class="line">        <span class="comment">//4：交付客户</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 准备装机所需要的配件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schema 客户选择的装机方案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareHardwares</span><span class="params">(AbstractFactory schema)</span> {</span><br><span class="line">        <span class="comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span></span><br><span class="line">        <span class="comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用抽象工厂来获取相应的接口对象</span></span><br><span class="line">        <span class="built_in">this</span>.cpu = (CpuApi) schema.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.mainboard = (MainboardApi) schema.createProduct(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下配件是否好用</span></span><br><span class="line">        <span class="built_in">this</span>.cpu.calculate();</span><br><span class="line">        <span class="built_in">this</span>.mainboard.installCpu();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>5、产品簇新增内存接口，可拓展性体现在已有代码无需改动</p>
<p>接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> MemoryApi.java v1.0 2023/1/8 21:23 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 内存的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemoryApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，内存具有缓存数据的能力</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cacheData</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接口实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> HyMemory.java v1.0 2023/1/8 21:24 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 现代内存的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HyMemory</span> <span class="keyword">implements</span> <span class="title class_">MemoryApi</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cacheData</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"现在正在使用现代内存"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>新增产品簇</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> Schema3.java v1.0 2023/1/8 21:25 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 装机方案三：Intel 的CPU + 技嘉的主板 + 现代的内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schema3</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProduct</span><span class="params">(<span class="type">int</span> type)</span> {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//type为1表示创建CPU，type为2表示创建主板，type为3表示创建内存</span></span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>){</span><br><span class="line">            retObj = <span class="keyword">new</span> <span class="title class_">IntelCpu</span>(<span class="number">1156</span>);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>){</span><br><span class="line">            retObj = <span class="keyword">new</span> <span class="title class_">GAMainboard</span>(<span class="number">1156</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//创建新添加的产品</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>){</span><br><span class="line">            retObj = <span class="keyword">new</span> <span class="title class_">HyMemory</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retObj;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>装机工程师实现改动</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerEngineer</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CpuApi</span>       <span class="variable">cpu</span>       <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的主板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MainboardApi</span> <span class="variable">mainboard</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义组装机器需要的内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MemoryApi</span>    <span class="variable">memory</span>    <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装机过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schema 客户选择的装机方案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assembleComputer</span><span class="params">(AbstractFactory schema)</span> {</span><br><span class="line">        <span class="comment">//1：首先准备好装机所需要的配件</span></span><br><span class="line">        prepareHardwares(schema);</span><br><span class="line">        <span class="comment">//2：组装机器</span></span><br><span class="line">        <span class="comment">//3：测试机器</span></span><br><span class="line">        <span class="comment">//4：交付客户</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 准备装机所需要的配件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schema 客户选择的装机方案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareHardwares</span><span class="params">(AbstractFactory schema)</span> {</span><br><span class="line">        <span class="comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span></span><br><span class="line">        <span class="comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用抽象工厂来获取相应的接口对象</span></span><br><span class="line">        <span class="built_in">this</span>.cpu = (CpuApi) schema.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.mainboard = (MainboardApi) schema.createProduct(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">this</span>.memory = (MemoryApi) schema.createProduct(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下配件是否好用</span></span><br><span class="line">        <span class="built_in">this</span>.cpu.calculate();</span><br><span class="line">        <span class="built_in">this</span>.mainboard.installCpu();</span><br><span class="line">        <span class="keyword">if</span> (memory != <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.memory.cacheData();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-3-抽象工厂模式和DAO"><a href="#3-3-抽象工厂模式和DAO" class="headerlink" title="3.3 抽象工厂模式和DAO"></a>3.3 抽象工厂模式和 DAO</h2><h3 id="3-3-1-什么是DAO"><a href="#3-3-1-什么是DAO" class="headerlink" title="3.3.1 什么是DAO"></a>3.3.1 什么是 DAO</h3><p>DAO（Data Access Object）：数据访问对象</p>
<p>DAO 是 JEE（也称 JavaEE，原 J2EE）中的一个标准模式，通过它来解决访问数据对象所面临的一系列问题，比如：数据源不同、存储类型不同、访问方式不同、供应商不同、版本不同等等，这些不同会造成访问数据的实现上差别很大。</p>
<blockquote>
<ul>
<li><p><strong>数据源的不同</strong>：比如存放于数据库的数据源，存放于 LDAP（轻型目录访问协议）的数据源；又比如存放于本地的数据源和远程服务器上的数据源等等</p>
</li>
<li><p><strong>存储类型的不同</strong>：比如关系型数据库（RDBMS）、面向对象数据库（ODBMS）、纯文件、XML 等等</p>
</li>
<li><p><strong>访问方式的不同</strong>：比如访问关系型数据库，可以用 JDBC、EntityBean、JPA 等来实现，当然也可以采用一些流行的框架，如 Hibernate、IBatis 等等</p>
</li>
<li><p><strong>供应商的不同</strong>：比如关系型数据库，流行如 Oracel、DB2、SqlServer、MySql 等等，它们的供应商是不同的</p>
</li>
<li><p><strong>版本不同</strong>：比如关系型数据库，不同的版本，实现的功能是有差异的，就算是对标准的 SQL 的支持，也是有差异的</p>
</li>
</ul>
</blockquote>
<img src="/2023/01/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20230108222247457.png" alt="image-20230108222247457" style="zoom: 50%;">

<p><strong>DAO 需要抽象和封装所有对数据的访问，DAO 承担和数据仓库交互的职责，意味着，访问数据所面临的所有问题，都需要 DAO 在内部来自行解决。</strong></p>
<h3 id="3-3-2-DAO与抽象工厂的关系"><a href="#3-3-2-DAO与抽象工厂的关系" class="headerlink" title="3.3.2 DAO与抽象工厂的关系"></a>3.3.2 DAO 与抽象工厂的关系</h3><p>事实上，<strong>在实现 DAO 模式的时候，最常见的实现策略就是使用工厂的策略，而且多是通过抽象工厂模式来实现，当然在使用抽象工厂模式来实现的时候，可以结合工厂方法模式</strong>。因此 DAO 模式和抽象工厂模式有很大的联系。</p>
<h3 id="3-3-3-DAO的工厂实现策略"><a href="#3-3-3-DAO的工厂实现策略" class="headerlink" title="3.3.3 DAO的工厂实现策略"></a>3.3.3 DAO 的工厂实现策略</h3><h4 id="3-3-3-1-工厂方法模式"><a href="#3-3-3-1-工厂方法模式" class="headerlink" title="3.3.3.1 工厂方法模式"></a>3.3.3.1 工厂方法模式</h4><p>假设需要实现一个订单处理模块，其中订单一般分为两部分，一是订单主记录或者订单主表，另一个是订单明细记录或者订单子表。业务逻辑一般会对两者都进行操作。</p>
<p>如果业务逻辑比较简单，且对数据的操作是固定的，操作数据库，不管订单的业务如何变化，底层数据存储都一样，此时可以选用工厂方法模式，系统结构为：</p>
<img src="/2023/01/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20230108224002210.png" alt="image-20230108224002210" style="zoom:50%;">

<p>从结构示意图可以看出，如果底层存储固定的时候，DAOFactory 就相当于工厂方法模式中的 Creator，在里面定义两个工厂方法，分别创建订单主记录的 DAO 对象和创建订单子记录的 DAO 对象，因为固定是数据库实现，因此提供一个具体的工厂 RdbDAOFactory（Rdb：关系型数据库），来实现对象的创建。也就是说 DAO 可以采用工厂方法模式来实现。</p>
<p>采用工厂方法模式的情况，要求 DAO 底层存储实现方式是固定的，这种多用在一些简单的小项目开发上。</p>
<h4 id="3-3-3-2-抽象工方法模式"><a href="#3-3-3-2-抽象工方法模式" class="headerlink" title="3.3.3.2 抽象工方法模式"></a>3.3.3.2 抽象工方法模式</h4><p>实际上更多的时候，DAO 底层存储实现方式是不固定的，DAO 通常会支持多种存储实现方式，具体使用哪一种存储方式可能是由应用动态决定，或者是通过配置来指定。这种情况多见于产品开发、或者是稍复杂的应用、或者是较大的项目中。</p>
<p>对于底层存储方式不固定的时候，一般是采用抽象工厂模式来实现 DAO。比如现在的实现除了 RDB 的实现，还会有 Xml 的实现，它们会被应用动态的选择，此时系统结构如图所示：</p>
<img src="/2023/01/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20230108224840673.png" alt="image-20230108224840673" style="zoom:50%;">

<p>从结构示意图可以看出，采用抽象工厂模式来实现 DAO 的时候，DAOFactory 就相当于抽象工厂，里面定义一系列创建相关对象的方法，分别是创建订单主记录的 DAO 对象和创建订单子记录的 DAO 对象，此时 OrderMainDAO 和 OrderDetailDAO 就相当于被创建的产品，RdbDAOFactory 和 XmlDAOFactory 就相当于抽象工厂的具体实现，在它们里面会选择相应的具体的产品实现来创建对象。</p>
<h2 id="3-4-抽象工厂的优缺点"><a href="#3-4-抽象工厂的优缺点" class="headerlink" title="3.4 抽象工厂的优缺点"></a>3.4 抽象工厂的优缺点</h2><h3 id="3-4-1-分离接口和实现"><a href="#3-4-1-分离接口和实现" class="headerlink" title="3.4.1 分离接口和实现"></a>3.4.1 分离接口和实现</h3><p>客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，也就是说，客户端从具体的产品实现中解耦。</p>
<h3 id="3-4-2-产品簇切换"><a href="#3-4-2-产品簇切换" class="headerlink" title="3.4.2 产品簇切换"></a>3.4.2 产品簇切换</h3><p>可以定义产品簇的概念，给出对象之间的关联关系</p>
<h3 id="3-4-3-不容易扩展新产品"><a href="#3-4-3-不容易扩展新产品" class="headerlink" title="3.4.3 不容易扩展新产品"></a>3.4.3 不容易扩展新产品</h3><p>前面也提到这个问题，<strong>如果需要给整个产品簇添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。在前面提供了一个可以扩展工厂的方式来解决这个问题，但是又不够安全</strong>。如何选择，需要根据实际应用来权衡。</p>
<h3 id="3-4-4-容易造成类层次复杂"><a href="#3-4-4-容易造成类层次复杂" class="headerlink" title="3.4.4 容易造成类层次复杂"></a>3.4.4 容易造成类层次复杂</h3><p>在使用抽象工厂模式的时候，如果需要选择的层次过多，那么会造成整个类层次变得复杂。</p>
<p>那么客户端怎么选呢？不会把所有可能的实现情况全部都做到一个层次上吧，这个时候客户端就需要一层一层选择，也就是<strong>整个抽象工厂的实现也需要分出层次来，每一层负责一种选择，也就是一层屏蔽一种变化，这样很容易造成复杂的类层次结构</strong>。</p>
<h2 id="3-5-思考"><a href="#3-5-思考" class="headerlink" title="3.5 思考"></a>3.5 思考</h2><h3 id="3-5-1-抽象工厂模式的本质"><a href="#3-5-1-抽象工厂模式的本质" class="headerlink" title="3.5.1 抽象工厂模式的本质"></a>3.5.1 抽象工厂模式的本质</h3><p>本质：选择产品簇的实现</p>
<h3 id="3-5-2-何时选用"><a href="#3-5-2-何时选用" class="headerlink" title="3.5.2 何时选用"></a>3.5.2 何时选用</h3><ul>
<li>若希望一个系统独立于它的产品的创建、组合和表现时，即：希望一个系统只知道产品的接口，而不需要关心具体的实现。</li>
<li>若系统需要由多个产品系列中的一个来配置时，即：可以动态切换产品簇时。</li>
<li>若需要强调一系列产品的接口，方便联合使用的时候。</li>
</ul>
<h2 id="3-6-相关模式"><a href="#3-6-相关模式" class="headerlink" title="3.6 相关模式"></a>3.6 相关模式</h2><h3 id="3-6-1-抽象工厂模式和工厂方法模式"><a href="#3-6-1-抽象工厂模式和工厂方法模式" class="headerlink" title="3.6.1 抽象工厂模式和工厂方法模式"></a>3.6.1 抽象工厂模式和工厂方法模式</h3><p>工厂方法模式一般针对单独的产品对象的创建，而抽象工厂模式注重产品簇对象的创建。</p>
<p>若将抽象工厂创建的产品簇简化，产品簇只有一个产品，这是抽象工厂和工厂方法是差不多的，即：抽象工厂可以退化成工厂方法，工厂方法可以退化成简单工厂。</p>
<p>在抽象工厂的实现中，可以使用工厂方法提供抽象工厂的具体实现，可以组合使用。</p>
<h3 id="3-6-2-抽象工厂和单例模式"><a href="#3-6-2-抽象工厂和单例模式" class="headerlink" title="3.6.2 抽象工厂和单例模式"></a>3.6.2 抽象工厂和单例模式</h3><p>可以组合使用。在抽象工厂模式例，具体的工厂实现可以实现成单例模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>创建型模式</tag>
        <tag>抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表详解</title>
    <url>/2023/02/12/%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>跳表（<code>SkipList</code> ) 又称跳跃表，是一种随机化的数据结构，可以视作二叉树的一个变种，它在性能上和红黑树，<code>AVL</code> 树不相上下，但是跳表的原理非常简单，在 <code>Redis</code> 和 <code>LeveLDB</code> 中都有用到。同时也是面试中的热门问题。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h1 id="2-原理与实现"><a href="#2-原理与实现" class="headerlink" title="2 原理与实现"></a>2 原理与实现</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>跳跃表 (简称跳表) 由美国计算机科学家<em><strong> William Pugh 发明于 1989 年</strong></em>。他在论文<code>《Skip lists: a probabilistic alternative to balanced trees》</code>中详细介绍了跳表的数据结构和插入删除等操作。</p>
<blockquote>
<p>跳表 (<code>SkipLis</code>t，全称跳跃表) 是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，<code>AVL</code> 树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。</p>
</blockquote>
<p>回顾链表，相对数组，链表的优点是高效的插入、删除，缺点是查询非常慢，复杂度达到 <code>O(n)</code>。</p>
<p><img src="/2023/02/12/%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3/image-20230212201841570.png" alt="image-20230212201841570"></p>
<p>这是一个带头结点的链表（头结点相当于一个固定的入口，不存储具体的值），每次查询请求时，需要重头开始遍历每一个值。参考数组的二叉树遍历，是否可以在链表也能用类似的思想来遍历？以空间换时间，在单链表上增加一层索引，增加索引的范围，可以减少链表的查询时间。</p>
<p><img src="/2023/02/12/%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3/image-20230212235856185.png"></p>
<p>如上，在查询某个结点的时候，首先在上层索引中查找出一个大的范围，然后下降到原始列表中，进行精确查找。查询的时间复杂度平均为 <code>O(n/2)</code>。但是当结点数量很大时，查询速度依旧很慢，还是参考二分查找的思路，<strong>跳表可以通过在链表上增加若干层索引的方法，让链表拥有近乎二分查找的效率</strong>。</p>
<p><img src="/2023/02/12/%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3/image-20230212235910946.png"></p>
<p>如上图，通过这样的一个数据结构对有序链表进行查找都能近乎二分的性能。在上面维护那么多层的索引，首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，此时已经十分接近要查找的元素的位置了 (如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也随之变快。</p>
<p>对于理想的跳表，每向上一层索引结点数量都是下一层的 <code>1/2</code>. 那么如果 <code>n</code> 个结点增加的结点数量 <code>(1/2+1/4+…) &lt; n</code>。并且层数较低，对查找效果影响不大。但是对于这个结构，完美的结构真的存在吗？大概率不存在的，作为一个链表，少不了增删该查的一些操作。而删除和插入可能会改变整个结构，所以上面的这些都是理想的结构，在插入的时候是否添加上层索引是个概率问题 (<code>1/2</code> 的概率)，在后面详细展开。</p>
<h2 id="2-2-方法与实现"><a href="#2-2-方法与实现" class="headerlink" title="2.2 方法与实现"></a>2.2 方法与实现</h2><p>定义跳表的结点</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> SkipNode.java v1.0 2023/2/12 21:01 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipNode</span>&lt;T&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>      key;</span><br><span class="line">    T        value;</span><br><span class="line">    SkipNode right;</span><br><span class="line">    SkipNode down;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SkipNode</span><span class="params">(<span class="type">int</span> key, T value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>跳表的定义（跳表的头结点 <code>(head)</code> 的 <code>key</code> 设为 <code>int</code> 的最小值 (一定满足左小右大方便比较)）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> SkipList.java v1.0 2023/2/12 21:03 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipList</span>&lt;T&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SkipNode headNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前跳表索引层数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>      highLevel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Random   random;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大的层数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SkipList</span><span class="params">()</span> {</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        headNode = <span class="keyword">new</span> <span class="title class_">SkipNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">        highLevel = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-1-查询"><a href="#2-2-1-查询" class="headerlink" title="2.2.1 查询"></a>2.2.1 查询</h3><blockquote>
<p>跳表查询任意结点数据的时间复杂度为 <code>O(logn)</code></p>
</blockquote>
<p>查询步骤：</p>
<ol>
<li>从链表顶层索引的第一个结点开始，从左往右搜索，若当前结点的值与查询的值相等，则直接返回当前结点；</li>
<li>若不相等，且右侧为空，则说明已经到达当前链表尾部，则只能进入下层索引；</li>
<li>若不相等，且右侧不为空，且右侧结点值小于等于待查询的值，则继续向右遍历查询；</li>
<li>若不相等，且右侧不为空，且右侧结点大于待查询的值，说明查询结点（若有）就在该索引结点与下一个索引结点，则进入下层索引查询；</li>
</ol>
<p>如下图，要求查询值为 <code>12</code> 的结点：</p>
<ol>
<li>从顶层 <code>head</code> 索引出发，右侧下一个结点不为空，且 <code>7 &lt; 12</code>；</li>
<li>继续查询下一个结点，为空，则下降到次顶层索引；</li>
<li>右侧下一个结点不为空，且 <code>10 &lt; 12</code> 继续向右；</li>
<li>继续查询下一个结点，为空，则下降到底层链表；</li>
<li>右侧不为空，且小于等于 <code>12</code>，继续向右查询；</li>
<li>当前结点等于待查询结点，直接返回该结点；</li>
</ol>
<p><img src="/2023/02/12/%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3/image-20230212235929179.png"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SkipNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">SkipNode</span> <span class="variable">team</span> <span class="operator">=</span> headNode;</span><br><span class="line">    <span class="keyword">while</span> (team != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (team.key == key) {</span><br><span class="line">            <span class="keyword">return</span> team;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (team.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 右侧没有结点，到达当前层尾部，则下降到下一层索引</span></span><br><span class="line">            team = team.down;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (team.right.key &gt; key) {</span><br><span class="line">            <span class="comment">// 右侧结点大于当期结点，若有目标结点的话，则在当前索引与下个索引直接，则需要下降到下一层索引</span></span><br><span class="line">            team = team.down;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 目标结点小于等于右侧结点</span></span><br><span class="line">            team = team.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> team;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-2-删除"><a href="#2-2-2-删除" class="headerlink" title="2.2.2 删除"></a>2.2.2 删除</h3><blockquote>
<p>跳表插入的时间复杂度为：<code>O(logn)</code></p>
</blockquote>
<p>相比查询操作，删除会更加复杂一些，删除需要改变链表结构以及处理结点之间的联系：</p>
<ol>
<li>删除当前结点以及前后结点的引用；</li>
<li>删除当前层的结点后，其它层的也要相应删除；</li>
</ol>
<p>删除时，需要根据当前链表结点的定义，若是双向链表，则比较方便处理。若是单向链表，则需要保留待删除结点的前一个结点，通过这个结点进行删除操作。删除的具体流程为：</p>
<ol>
<li>若结点右侧为空，则下降到下一层索引；</li>
<li>若结点右侧不为空，且右侧结点等于待删除的结点，则先删除结点，在下降到下一层索引，删除下一层索引的结点；</li>
<li>若结点右侧不为空，且右侧结点小于待删除的结点，则继续向右遍历；</li>
<li>若结点右侧不为空，且右侧结点大于待删除的结点，则下降到下一层索引，继续查询待删除结点；</li>
</ol>
<p>如下图，要求删除值为 <code>10</code> 的结点：</p>
<ol>
<li>从 <code>team = head</code> 出发，<code>7 &lt; 10</code> 向右遍历，</li>
<li>右侧为空，下降到下一层索引；</li>
<li>右侧为 <code>10</code> 在当前层删除 <code>10</code>，然后继续向下查询下一层的 <code>10</code> 结点，</li>
<li><code>8 &lt; 10</code>，继续向右遍历；</li>
<li>右侧为待删除节点 <code>10</code>，继续向下层，但是下层为空，说明删除完毕，返回结果；</li>
</ol>
<p><img src="/2023/02/12/%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3/image-20230213000008873.png"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除结点</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">SkipNode</span> <span class="variable">team</span> <span class="operator">=</span> headNode;</span><br><span class="line">        <span class="keyword">while</span> (team != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (team.right == <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 右侧没有结点，到达当前层尾部，则下降到下一层索引</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (team.right.key == key) {</span><br><span class="line">                <span class="comment">// 找到该层的目标结点，右侧为待删除结点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 删除右侧结点</span></span><br><span class="line">                team.right = team.right.right;</span><br><span class="line">                <span class="comment">// 继续相下层查找删除</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (team.right.key &gt; key) {</span><br><span class="line">                <span class="comment">// 右侧结点大于当期节点，若有目标节点的话，则在当前索引与下个索引直接，则需要下降到下一层索引</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 右侧结点小于team，继续向右侧遍历</span></span><br><span class="line">                team = team.right;</span><br><span class="line">            } </span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-3-插入"><a href="#2-2-3-插入" class="headerlink" title="2.2.3 插入"></a>2.2.3 插入</h3><blockquote>
<p>跳表的插入操作时间复杂度为：O (logn)</p>
</blockquote>
<p>插入操作是最复杂的，需要考虑上层索引是否需要同时插入，需要插入时，应该插入几层索引？</p>
<p>随着删除和插入操作的进行，跳表肯定是无法持续维护理想的索引结构，因为维护的代价非常高。可以考虑使用<strong>随机数</strong>来决定是否向上插入索引。</p>
<p>可以分多种做法：</p>
<ol>
<li>先将值插入最底层，从最底层开始向上层索引的方向，产生一个 <code>[0 - 1]</code> 的随机数，如果随机数小于 <code>0.5</code>，则向上插入索引，当插入成功后，再次使用随机数判断是否向上层插入索引，最多可以多层都插入索引；</li>
<li>先将值插入最底层，产生一个随机数，若随机数为 <code>K</code>，那么则将在第 K 层插入该节点的索引；</li>
</ol>
<blockquote>
<p> 注：一般会设置一个值来限定索引的高度；</p>
</blockquote>
<p>插入的流程：</p>
<ol>
<li>和查询一样的步骤，<strong>找到待插入的左结点</strong>，从底层链表开始插入（需要考虑是否为链表尾部的情况）；</li>
<li>查完下一层，再考虑是否插入上一层，首先判断当前索引层级数，如果达到限制，则停止插入，否则根据随机数判断是否向上层插入索引（理想的结构是每隔 <code>2</code> 个结点向上建立一个索引）；</li>
<li>继续步骤 <code>2</code>，直到概率退出或者达到索引数量最大值；</li>
</ol>
<h4 id="几个关键点"><a href="#几个关键点" class="headerlink" title="几个关键点"></a>几个关键点</h4><p><strong>1、具体向上层索引插入时，需要考虑如何找到上一层的待插入节点？</strong></p>
<p>应该需要根据链表节点的定义来判断。若定义的是双向链表，则只需要根据链表的属性寻找上层需要插入的结点；若定义的是单向链表时，<strong>当时查询的下降路线的逆序为需要插入结点</strong>，最底层也不例外（因为没有匹配值会下降为空时，结束循环），可以使用<strong>栈</strong>的数据结构来保存查询的路线顺序节点。</p>
<p>示意图：</p>
<p><img src="/2023/02/12/%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3/image-20230214004121674.png" alt="image-20230214004121674"></p>
<p><strong>2、如果插入索引达到当前最高索引时，如何继续向上建立索引？</strong></p>
<p>需要改变跳表的 <code>head</code>，新建一个 <code>ListNode</code> 结点作为新的 <code>head</code>，将新 <code>head</code> 的 <code>down</code> 指向老 <code>head</code>，再新将 <code>head</code> 结点加入栈中，后续需要作为插入索引时做准备。</p>
<p>示意图：</p>
<p><img src="/2023/02/12/%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3/image-20230214004543681.png" alt="image-20230214004543681"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加结点</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(SkipNode node)</span> {</span><br><span class="line">       <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> node.key;</span><br><span class="line">       <span class="type">SkipNode</span> <span class="variable">findNode</span> <span class="operator">=</span> search(key);</span><br><span class="line">       <span class="comment">// 如果存在这个点，直接覆盖</span></span><br><span class="line">       <span class="keyword">if</span> (findNode != <span class="literal">null</span>) {</span><br><span class="line">           findNode.value = node.value;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 存储遍历的结点路径，用于后续索引插入使用</span></span><br><span class="line">       Stack&lt;SkipNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       <span class="type">SkipNode</span> <span class="variable">team</span> <span class="operator">=</span> headNode;</span><br><span class="line">       <span class="comment">// 查询待插入的位置</span></span><br><span class="line">       <span class="keyword">while</span> (team != <span class="literal">null</span>) {</span><br><span class="line">           <span class="keyword">if</span> (team.right == <span class="literal">null</span>) {</span><br><span class="line">               <span class="comment">// 右侧没有结点，到达当前层尾部，则下降到下一层索引</span></span><br><span class="line">               stack.add(team); <span class="comment">// 记录路径</span></span><br><span class="line">               team = team.down;</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (team.right.key &gt; key) {</span><br><span class="line">               <span class="comment">// 右侧结点大于当期节点，若有目标节点的话，则在当前索引与下个索引直接，则需要下降到下一层索引</span></span><br><span class="line">               stack.add(team);</span><br><span class="line">               team = team.down;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="comment">// 右侧结点小于team，继续向右侧遍历</span></span><br><span class="line">               team = team.right;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">// 当前跳表层数，从底层开始插入（底层是必须要插入的）</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 保持前驱结点（down的指向，初始为null）</span></span><br><span class="line">       <span class="type">SkipNode</span> <span class="variable">downNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">           <span class="comment">// 出栈 - 待插入的左侧结点</span></span><br><span class="line">           team = stack.pop();</span><br><span class="line">           <span class="comment">// 创建需要插入的节点</span></span><br><span class="line">           <span class="type">SkipNode</span> <span class="variable">nodeTeam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipNode</span>(node.key, node.value);</span><br><span class="line">           <span class="comment">// 层间索引</span></span><br><span class="line">           nodeTeam.down = downNode;</span><br><span class="line">           <span class="comment">// 指针迁移 - 标记新的结点 - 下次循环使用</span></span><br><span class="line">           downNode = nodeTeam;</span><br><span class="line">           <span class="comment">// 若待插入结点的右侧为null，说明插在当前链表尾部</span></span><br><span class="line">           <span class="keyword">if</span> (team.right == <span class="literal">null</span>) {</span><br><span class="line">               team.right = nodeTeam;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="comment">// 非尾部链表位置插入</span></span><br><span class="line">               nodeTeam.right = team.right;</span><br><span class="line">               team.right = nodeTeam;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">// 判断是否需要向上层索引插入</span></span><br><span class="line">           <span class="keyword">if</span> (level &gt; MAX_LEVEL) {</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 使用随机数判断是否要向上插入 - [0 - 1]</span></span><br><span class="line">           <span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line">           <span class="comment">// 小于 0.5 则继续插入索引</span></span><br><span class="line">           <span class="keyword">if</span> (num &gt; <span class="number">0.5</span>) {</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           }</span><br><span class="line">           level++;</span><br><span class="line">           <span class="comment">// 比当前最大高度要高但是依然在允许范围内 需要改变head节点</span></span><br><span class="line">           <span class="keyword">if</span> (level &gt; highLevel) {</span><br><span class="line">               highLevel = level;</span><br><span class="line">               <span class="comment">// 需要创建一个新的结点</span></span><br><span class="line">               <span class="type">SkipNode</span> <span class="variable">highHeadNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">               highHeadNode.down = headNode;</span><br><span class="line">               headNode = highHeadNode;</span><br><span class="line">               <span class="comment">// 最后新添加了一层新的索引层 - 下次循环看是否需要添加添加索引结点</span></span><br><span class="line">               stack.add(headNode);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-3-完整代码"><a href="#2-3-完整代码" class="headerlink" title="2.3 完整代码"></a>2.3 完整代码</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> mark</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> SkipList.java v1.0 2023/2/12 21:03 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipList</span>&lt;T&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SkipNode headNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前跳表索引层数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>      highLevel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Random   random;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大的层数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_LEVEL</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SkipList</span><span class="params">()</span> {</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        headNode = <span class="keyword">new</span> <span class="title class_">SkipNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">        highLevel = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SkipNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">SkipNode</span> <span class="variable">team</span> <span class="operator">=</span> headNode;</span><br><span class="line">        <span class="keyword">while</span> (team != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (team.key == key) {</span><br><span class="line">                <span class="keyword">return</span> team;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (team.right == <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 右侧没有结点，到达当前层尾部，则下降到下一层索引</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (team.right.key &gt; key) {</span><br><span class="line">                <span class="comment">// 右侧节点大于当期节点，若有目标节点的话，则在当前索引与下个索引直接，则需要下降到下一层索引</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 目标节点小于等于右侧节点</span></span><br><span class="line">                team = team.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> team;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">SkipNode</span> <span class="variable">team</span> <span class="operator">=</span> headNode;</span><br><span class="line">        <span class="keyword">while</span> (team != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (team.right == <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 右侧没有结点，到达当前层尾部，则下降到下一层索引</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (team.right.key == key) {</span><br><span class="line">                <span class="comment">// 找到该层的目标结点，右侧为待删除结点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 删除右侧结点</span></span><br><span class="line">                team.right = team.right.right;</span><br><span class="line">                <span class="comment">// 继续相下层查找删除</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (team.right.key &gt; key) {</span><br><span class="line">                <span class="comment">// 右侧结点大于当期节点，若有目标节点的话，则在当前索引与下个索引直接，则需要下降到下一层索引</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 右侧结点小于team，继续向右侧遍历</span></span><br><span class="line">                team = team.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(SkipNode node)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> node.key;</span><br><span class="line">        <span class="type">SkipNode</span> <span class="variable">findNode</span> <span class="operator">=</span> search(key);</span><br><span class="line">        <span class="comment">// 如果存在这个点，直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (findNode != <span class="literal">null</span>) {</span><br><span class="line">            findNode.value = node.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储遍历的结点路径，用于后续索引插入使用</span></span><br><span class="line">        Stack&lt;SkipNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">SkipNode</span> <span class="variable">team</span> <span class="operator">=</span> headNode;</span><br><span class="line">        <span class="comment">// 查询待插入的位置</span></span><br><span class="line">        <span class="keyword">while</span> (team != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (team.right == <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 右侧没有结点，到达当前层尾部，则下降到下一层索引</span></span><br><span class="line">                stack.add(team); <span class="comment">// 记录路径</span></span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (team.right.key &gt; key) {</span><br><span class="line">                <span class="comment">// 右侧结点大于当期节点，若有目标节点的话，则在当前索引与下个索引直接，则需要下降到下一层索引</span></span><br><span class="line">                stack.add(team);</span><br><span class="line">                team = team.down;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 右侧结点小于team，继续向右侧遍历</span></span><br><span class="line">                team = team.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 当前跳表层数，从底层开始插入（底层是必须要插入的）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 保持前驱结点（down的指向，初始为null）</span></span><br><span class="line">        <span class="type">SkipNode</span> <span class="variable">downNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            <span class="comment">// 出栈 - 待插入的左侧结点</span></span><br><span class="line">            team = stack.pop();</span><br><span class="line">            <span class="comment">// 创建需要插入的节点</span></span><br><span class="line">            <span class="type">SkipNode</span> <span class="variable">nodeTeam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipNode</span>(node.key, node.value);</span><br><span class="line">            <span class="comment">// 层间索引</span></span><br><span class="line">            nodeTeam.down = downNode;</span><br><span class="line">            <span class="comment">// 指针迁移 - 标记新的结点 - 下次循环使用</span></span><br><span class="line">            downNode = nodeTeam;</span><br><span class="line">            <span class="comment">// 若待插入结点的右侧为null，说明插在当前链表尾部</span></span><br><span class="line">            <span class="keyword">if</span> (team.right == <span class="literal">null</span>) {</span><br><span class="line">                team.right = nodeTeam;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 非尾部链表位置插入</span></span><br><span class="line">                nodeTeam.right = team.right;</span><br><span class="line">                team.right = nodeTeam;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 判断是否需要向上层索引插入</span></span><br><span class="line">            <span class="keyword">if</span> (level &gt; MAX_LEVEL) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用随机数判断是否要向上插入 - [0 - 1]</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line">            <span class="comment">// 小于 0.5 则继续插入索引</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0.5</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            level++;</span><br><span class="line">            <span class="comment">// 比当前最大高度要高但是依然在允许范围内 需要改变head节点</span></span><br><span class="line">            <span class="keyword">if</span> (level &gt; highLevel) {</span><br><span class="line">                highLevel = level;</span><br><span class="line">                <span class="comment">// 需要创建一个新的结点</span></span><br><span class="line">                <span class="type">SkipNode</span> <span class="variable">highHeadNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">                highHeadNode.down = headNode;</span><br><span class="line">                headNode = highHeadNode;</span><br><span class="line">                <span class="comment">// 最后新添加了一层新的索引层 - 下次循环看是否需要添加添加索引结点</span></span><br><span class="line">                stack.add(headNode);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SkipNode</span> <span class="variable">teamNode</span> <span class="operator">=</span> headNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">SkipNode</span> <span class="variable">last</span> <span class="operator">=</span> teamNode;</span><br><span class="line">        <span class="keyword">while</span> (last.down != <span class="literal">null</span>) {</span><br><span class="line">            last = last.down;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (teamNode != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">SkipNode</span> <span class="variable">enumNode</span> <span class="operator">=</span> teamNode.right;</span><br><span class="line">            <span class="type">SkipNode</span> <span class="variable">enumLast</span> <span class="operator">=</span> last.right;</span><br><span class="line">            System.out.printf(<span class="string">"%-8s"</span>, <span class="string">"head-&gt;"</span>);</span><br><span class="line">            <span class="keyword">while</span> (enumLast != <span class="literal">null</span> &amp;&amp; enumNode != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (enumLast.key == enumNode.key) {</span><br><span class="line">                    System.out.printf(<span class="string">"%-5s"</span>, enumLast.key + <span class="string">"-&gt;"</span>);</span><br><span class="line">                    enumLast = enumLast.right;</span><br><span class="line">                    enumNode = enumNode.right;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    enumLast = enumLast.right;</span><br><span class="line">                    System.out.printf(<span class="string">"%-5s"</span>, <span class="string">""</span>);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            teamNode = teamNode.down;</span><br><span class="line">            index++;</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SkipList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">SkipList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">SkipNode</span>(i, <span class="number">666</span>));</span><br><span class="line">        }</span><br><span class="line">        list.print();</span><br><span class="line">        list.delete(<span class="number">4</span>);</span><br><span class="line">        list.delete(<span class="number">8</span>);</span><br><span class="line">        list.print();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&gt; Task :SkipList.main()</span><br><span class="line">head-&gt;                                               10-&gt;                                    18-&gt; </span><br><span class="line">head-&gt;                                               10-&gt;                                    18-&gt; </span><br><span class="line">head-&gt;       2-&gt;                                     10-&gt;           13-&gt;                     18-&gt; </span><br><span class="line">head-&gt;  1-&gt;  2-&gt;                                     10-&gt;           13-&gt;      15-&gt;           18-&gt; </span><br><span class="line">head-&gt;  1-&gt;  2-&gt;                      7-&gt;  8-&gt;       10-&gt;      12-&gt; 13-&gt;      15-&gt; 16-&gt;      18-&gt; </span><br><span class="line">head-&gt;  1-&gt;  2-&gt;  3-&gt;  4-&gt;  5-&gt;  6-&gt;  7-&gt;  8-&gt;  9-&gt;  10-&gt; 11-&gt; 12-&gt; 13-&gt; 14-&gt; 15-&gt; 16-&gt; 17-&gt; 18-&gt; 19-&gt; </span><br><span class="line">head-&gt;                                     10-&gt;                                    18-&gt; </span><br><span class="line">head-&gt;                                     10-&gt;                                    18-&gt; </span><br><span class="line">head-&gt;       2-&gt;                           10-&gt;           13-&gt;                     18-&gt; </span><br><span class="line">head-&gt;  1-&gt;  2-&gt;                           10-&gt;           13-&gt;      15-&gt;           18-&gt; </span><br><span class="line">head-&gt;  1-&gt;  2-&gt;                 7-&gt;       10-&gt;      12-&gt; 13-&gt;      15-&gt; 16-&gt;      18-&gt; </span><br><span class="line">head-&gt;  1-&gt;  2-&gt;  3-&gt;  5-&gt;  6-&gt;  7-&gt;  9-&gt;  10-&gt; 11-&gt; 12-&gt; 13-&gt; 14-&gt; 15-&gt; 16-&gt; 17-&gt; 18-&gt; 19-&gt; </span><br></pre></td></tr></tbody></table></figure>

<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><ul>
<li>跳表使用的是空间换时间的思想，通过构建多级索引来提高查询效率，实现基于链表的 “二分查找”，跳表是一种动态的数据结构，支持快速的查找、插入和删除操作，时间复杂度是 <code>O(logn)</code>；</li>
<li>跳表的空间复杂度是 <code>O(n)</code>，不过跳表可以通过改变索引策略，动态的平衡执行效率和内存消耗；</li>
<li><code>Redis</code> 的有序集合 <code>zset</code> 使用跳表而不使用红黑树的原因主要是，链表能进行范围区间的查询，而树结构不太方便；</li>
<li><code>Java</code> 中 <code>ConcurrentSkipListSet</code> 和 <code>ConcurrentSkipListMap</code> 使用了跳表；</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651453211&amp;idx=1&amp;sn=f099e00c01439441dcb8e0c96198e6bc&amp;chksm=80bb29e9b7cca0ffe5a9757f7ccdb12a792dff661d7e01e53ec9168588a78099dfa396f8f400&amp;scene=27">带你彻底击溃跳表原理及其 Golang 实现！（内含图解）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651453211&amp;idx=1&amp;sn=f099e00c01439441dcb8e0c96198e6bc&amp;chksm=80bb29e9b7cca0ffe5a9757f7ccdb12a792dff661d7e01e53ec9168588a78099dfa396f8f400&amp;scene=27">数据结构和算法之 —— 跳表</a></li>
<li><a href="https://juejin.cn/post/6844903869873389582">SkipList 跳表的原理以及实现</a></li>
<li><a href="https://blog.csdn.net/weixin_52967653/article/details/125941153">详解高级数据结构之 跳表</a></li>
<li><a href="https://blog.csdn.net/weixin_45480785/article/details/116293416">跳表</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器模式</title>
    <url>/2023/01/31/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实际场景"><a href="#1-实际场景" class="headerlink" title="1 实际场景"></a>1 实际场景</h1><h2 id="1-1-导出数据的应用框架"><a href="#1-1-导出数据的应用框架" class="headerlink" title="1.1 导出数据的应用框架"></a>1.1 导出数据的应用框架</h2><p>在<a href="https://markhe1222.github.io/2022/12/25/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">工厂方法模式</a>一文中，讨论并使用工厂方法模式来解决了导出数据的应用框架中如何选择具体到处方式的问题，并没还有涉及到具体的数据导出实现方式，即，没有实现如何将数据导出成文本、<code>xml</code> 等具体的格式。本文场景需要讨论数据导出的具体实现。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<p>对于导出数据的内容格式具体需求如下：</p>
<blockquote>
<p>分为三个部分：文件头、文件体以及文件尾</p>
<ul>
<li>文件头：一般描述公司编号、导出数据的日期，对于文本格式，中间使用逗号分隔符；</li>
<li>文件体：表名称、粉条描述数据。对于文本格式，标名称单独占一行，数据描述一行算一条数据，字段间用逗号分隔符；</li>
<li>文件尾：描述输出数据的用户信息；</li>
</ul>
</blockquote>
<p>应用框架的其它功能不在重复实现（具体信息可参考工厂方法模式的文章），目前只关注如何实现导出文件，导出格式暂定为文本格式和 <code>xml</code> 格式。</p>
<h2 id="1-2-不使用设计模式的方案"><a href="#1-2-不使用设计模式的方案" class="headerlink" title="1.2 不使用设计模式的方案"></a>1.2 不使用设计模式的方案</h2><p>无论导出数据的格式是哪种，导出数据都是相同的。</p>
<p>1、定义数据对象</p>
<p>文件头数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ExportHeaderModel.java v 0.1 2023/1/31 23:55 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 描述输出到文件头的内容的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportHeaderModel</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分公司或门市点编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String depId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出数据的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String exportDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDepId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> depId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDepId</span><span class="params">(String depId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.depId = depId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getExportDate</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> exportDate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExportDate</span><span class="params">(String exportDate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.exportDate = exportDate;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件体数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ExportDataModel.java v 0.1 2023/1/31 23:56 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 描述输出数据的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportDataModel</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> {</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAmount</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAmount</span><span class="params">(<span class="type">double</span> amount)</span> {</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件尾数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ExportFooterModel.java v 0.1 2023/1/31 23:57 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 描述输出到文件尾的内容的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportFooterModel</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String exportUser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getExportUser</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> exportUser;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExportUser</span><span class="params">(String exportUser)</span> {</span><br><span class="line">        <span class="built_in">this</span>.exportUser = exportUser;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、文本文件格式导出实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ExportToTxt.java v 0.1 2023/2/1 00:00 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 导出数据到文本文件的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportToTxt</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出数据到文本文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ehm     文件头的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapData 数据的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> efm     文件尾的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">(ExportHeaderModel ehm, Map&lt;String, Collection&lt;ExportDataModel&gt;&gt; mapData, ExportFooterModel efm)</span> {</span><br><span class="line">        <span class="comment">//用来记录最终输出的文件内容</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//1：先来拼接文件头的内容</span></span><br><span class="line">        sb.append(ehm.getDepId()).append(<span class="string">","</span>).append(ehm.getExportDate()).append(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">//2：接着来拼接文件体的内容</span></span><br><span class="line">        <span class="keyword">for</span> (String tblName : mapData.keySet()) {</span><br><span class="line">            <span class="comment">//先拼接表名称</span></span><br><span class="line">            sb.append(tblName).append(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="comment">//然后循环拼接具体数据</span></span><br><span class="line">            <span class="keyword">for</span> (ExportDataModel edm : mapData.get(tblName)) {</span><br><span class="line">                sb.append(edm.getProductId()).append(<span class="string">","</span>).append(edm.getPrice()).append(<span class="string">","</span>).append(edm.getAmount()).append(<span class="string">"\n"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//3：接着来拼接文件尾的内容</span></span><br><span class="line">        sb.append(efm.getExportUser());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了演示简洁性，这里就不去写输出文件的代码了</span></span><br><span class="line">        <span class="comment">//把要输出的内容输出到控制台看看</span></span><br><span class="line">        System.out.println(<span class="string">"输出到文本文件的内容：\n"</span> + sb);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、<code>xml</code> 格式导出实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ExportToXml.java v 0.1 2023/2/1 00:03 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 导出数据到XML文件的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportToXml</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出数据到XML文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ehm     文件头的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapData 数据的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> efm     文件尾的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">(ExportHeaderModel ehm, Map&lt;String, Collection&lt;ExportDataModel&gt;&gt; mapData, ExportFooterModel efm)</span> {</span><br><span class="line">        <span class="comment">//用来记录最终输出的文件内容</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//1：先来拼接文件头的内容</span></span><br><span class="line">        sb.append(<span class="string">"&lt;?xml version='1.0' encoding='gb2312'?&gt;\n"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;Report&gt;\n"</span>);</span><br><span class="line">        sb.append(<span class="string">"  &lt;Header&gt;\n"</span>);</span><br><span class="line">        sb.append(<span class="string">"    &lt;DepId&gt;"</span>).append(ehm.getDepId()).append(<span class="string">"&lt;/DepId&gt;\n"</span>);</span><br><span class="line">        sb.append(<span class="string">"    &lt;ExportDate&gt;"</span>).append(ehm.getExportDate()).append(<span class="string">"&lt;/ExportDate&gt;\n"</span>);</span><br><span class="line">        sb.append(<span class="string">"  &lt;/Header&gt;\n"</span>);</span><br><span class="line">        <span class="comment">//2：接着来拼接文件体的内容</span></span><br><span class="line">        sb.append(<span class="string">"  &lt;Body&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String tblName : mapData.keySet()) {</span><br><span class="line">            <span class="comment">//先拼接表名称</span></span><br><span class="line">            sb.append(<span class="string">"    &lt;Datas TableName=\""</span>).append(tblName).append(<span class="string">"\"&gt;\n"</span>);</span><br><span class="line">            <span class="comment">//然后循环拼接具体数据</span></span><br><span class="line">            <span class="keyword">for</span> (ExportDataModel edm : mapData.get(tblName)) {</span><br><span class="line">                sb.append(<span class="string">"      &lt;Data&gt;\n"</span>);</span><br><span class="line">                sb.append(<span class="string">"          &lt;ProductId&gt;"</span>).append(edm.getProductId()).append(<span class="string">"&lt;/ProductId&gt;\n"</span>);</span><br><span class="line">                sb.append(<span class="string">"          &lt;Price&gt;"</span>).append(edm.getPrice()).append(<span class="string">"&lt;/Price&gt;\n"</span>);</span><br><span class="line">                sb.append(<span class="string">"          &lt;Amount&gt;"</span>).append(edm.getAmount()).append(<span class="string">"&lt;/Amount&gt;\n"</span>);</span><br><span class="line">                sb.append(<span class="string">"      &lt;/Data&gt;\n"</span>);</span><br><span class="line">            }</span><br><span class="line">            sb.append(<span class="string">"    &lt;/Datas&gt;\n"</span>);</span><br><span class="line">        }</span><br><span class="line">        sb.append(<span class="string">"  &lt;/Body&gt;\n"</span>);</span><br><span class="line">        <span class="comment">//3：接着来拼接文件尾的内容</span></span><br><span class="line">        sb.append(<span class="string">"  &lt;Footer&gt;\n"</span>);</span><br><span class="line">        sb.append(<span class="string">"    &lt;ExportUser&gt;"</span>).append(efm.getExportUser()).append(<span class="string">"&lt;/ExportUser&gt;\n"</span>);</span><br><span class="line">        sb.append(<span class="string">"  &lt;/Footer&gt;\n"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;/Report&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了演示简洁性，这里就不去写输出文件的代码了</span></span><br><span class="line">        <span class="comment">//把要输出的内容输出到控制台看看</span></span><br><span class="line">        System.out.println(<span class="string">"输出到XML文件的内容：\n"</span> + sb);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、客户端代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/1 00:04 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//准备测试数据</span></span><br><span class="line">        <span class="type">ExportHeaderModel</span> <span class="variable">ehm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportHeaderModel</span>();</span><br><span class="line">        ehm.setDepId(<span class="string">"一分公司"</span>);</span><br><span class="line">        ehm.setExportDate(<span class="string">"2010-05-18"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Collection&lt;ExportDataModel&gt;&gt; mapData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Collection&lt;ExportDataModel&gt; col = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExportDataModel</span> <span class="variable">edm1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportDataModel</span>();</span><br><span class="line">        edm1.setProductId(<span class="string">"产品001号"</span>);</span><br><span class="line">        edm1.setPrice(<span class="number">100</span>);</span><br><span class="line">        edm1.setAmount(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExportDataModel</span> <span class="variable">edm2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportDataModel</span>();</span><br><span class="line">        edm2.setProductId(<span class="string">"产品002号"</span>);</span><br><span class="line">        edm2.setPrice(<span class="number">99</span>);</span><br><span class="line">        edm2.setAmount(<span class="number">55</span>);</span><br><span class="line">        <span class="comment">//把数据组装起来</span></span><br><span class="line">        col.add(edm1);</span><br><span class="line">        col.add(edm2);</span><br><span class="line">        mapData.put(<span class="string">"销售记录表"</span>, col);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExportFooterModel</span> <span class="variable">efm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportFooterModel</span>();</span><br><span class="line">        efm.setExportUser(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">//测试输出到文本文件</span></span><br><span class="line">        <span class="type">ExportToTxt</span> <span class="variable">toTxt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportToTxt</span>();</span><br><span class="line">        toTxt.export(ehm, mapData, efm);</span><br><span class="line">        <span class="comment">//测试输出到xml文件</span></span><br><span class="line">        <span class="type">ExportToXml</span> <span class="variable">toXml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportToXml</span>();</span><br><span class="line">        toXml.export(ehm, mapData, efm);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码运行结果：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">输出到文本文件的内容：</span><br><span class="line">一分公司,2010-05-18</span><br><span class="line">销售记录表</span><br><span class="line">产品001号,100.0,80.0</span><br><span class="line">产品002号,99.0,55.0</span><br><span class="line">张三</span><br><span class="line"></span><br><span class="line">输出到XML文件的内容：</span><br><span class="line">&lt;?xml version='1.0' encoding='gb2312'?&gt;</span><br><span class="line">&lt;Report&gt;</span><br><span class="line">  &lt;Header&gt;</span><br><span class="line">    &lt;DepId&gt;一分公司&lt;/DepId&gt;</span><br><span class="line">    &lt;ExportDate&gt;2010-05-18&lt;/ExportDate&gt;</span><br><span class="line">  &lt;/Header&gt;</span><br><span class="line">  &lt;Body&gt;</span><br><span class="line">    &lt;Datas TableName="销售记录表"&gt;</span><br><span class="line">      &lt;Data&gt;</span><br><span class="line">          &lt;ProductId&gt;产品001号&lt;/ProductId&gt;</span><br><span class="line">          &lt;Price&gt;100.0&lt;/Price&gt;</span><br><span class="line">          &lt;Amount&gt;80.0&lt;/Amount&gt;</span><br><span class="line">      &lt;/Data&gt;</span><br><span class="line">      &lt;Data&gt;</span><br><span class="line">          &lt;ProductId&gt;产品002号&lt;/ProductId&gt;</span><br><span class="line">          &lt;Price&gt;99.0&lt;/Price&gt;</span><br><span class="line">          &lt;Amount&gt;55.0&lt;/Amount&gt;</span><br><span class="line">      &lt;/Data&gt;</span><br><span class="line">    &lt;/Datas&gt;</span><br><span class="line">  &lt;/Body&gt;</span><br><span class="line">  &lt;Footer&gt;</span><br><span class="line">    &lt;ExportUser&gt;张三&lt;/ExportUser&gt;</span><br><span class="line">  &lt;/Footer&gt;</span><br><span class="line">&lt;/Report&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-存在的问题"><a href="#1-3-存在的问题" class="headerlink" title="1.3 存在的问题"></a>1.3 存在的问题</h2><p>观察上面的实现，无论输出到哪种格式，步骤基本一致：</p>
<blockquote>
<ol>
<li>拼接文件头内容；</li>
<li>拼接文件体内容；</li>
<li>拼接文件尾内容；</li>
<li>将拼接好的内容输出；</li>
</ol>
</blockquote>
<p>按照目前的实现方式存在以下问题：</p>
<blockquote>
<ol>
<li>构建每种输出格式的文件内容的时候，都会<strong>重复这几个处理步骤，应该提炼出来，形成公共的处理过程</strong>；</li>
<li>今后可能会有很多不同输出格式的要求，这就<strong>需要在处理过程不变的情况下，能方便的切换不同的输出格式的处理</strong>；</li>
</ol>
</blockquote>
<p>即：<strong>构建每种格式的数据文件的处理过程，应该和具体的步骤实现分开，这样就能够复用处理过程，而且能很容易的切换不同的输出格式</strong>。</p>
<p>如何实现？</p>
<h1 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h1><h2 id="2-1-生成器模式"><a href="#2-1-生成器模式" class="headerlink" title="2.1 生成器模式"></a>2.1 生成器模式</h2><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h3><p>生成器模式（Builder）是创建型模式：将复杂对象的构建与表示分离，是的同样的构建过程可创建不同表示。简单来说就是调用相同的创建对象的方法（建造过程）可以创建出不同的对象。</p>
<h3 id="2-1-2-生成器模式解决方案思路"><a href="#2-1-2-生成器模式解决方案思路" class="headerlink" title="2.1.2 生成器模式解决方案思路"></a>2.1.2 生成器模式解决方案思路</h3><p>在上述案例场景中，构建不同格式的数据文件的处理过程，就是对象的构建，而每种格式具体的实现步骤，就相当于不同的表示。因为不同实现步骤，决定了表现的不同。</p>
<p>要实现同样的构建过程可以创建不同的表现，那么<strong>一个自然的思路就是先把构建过程独立出来，在生成器模式中把它称为指导者，由它来指导装配过程，但是不负责每步具体的实现</strong>。当然，光有指导者是不够的，<strong>必须要有能具体实现每步的对象，在生成器模式中称这些实现对象为生成器</strong>。</p>
<p>如此，<strong>指导者就是可以重用的构建过程，而生成器是可以被切换的具体实现</strong>。前面的实现中，每种具体的导出文件格式的实现就相当于生成器。</p>
<h3 id="2-1-3-结构说明"><a href="#2-1-3-结构说明" class="headerlink" title="2.1.3 结构说明"></a>2.1.3 结构说明</h3><img src="/2023/01/31/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20230202001114080.png" alt="image-20230202001114080" style="zoom: 50%;">

<blockquote>
<p><code>Builder</code>：生成器接口，定义创建一个 <code>Product</code> 对象所需的各个部件的操作；</p>
<p><code>ConcreteBuilder</code>：具体的生成器实现，实现各个部件的创建，并负责组装 <code>Product</code> 对象的各个部件，同时还提供一个让用户获取组装完成后的产品对象的方法；</p>
<p><code>Direcotor</code>：指导者，主要用来使用 <code>Builder</code> 接口，以一个统一的过程构建所需要的 <code>Product</code> 对象；</p>
<p><code>Product</code>：产品，表示被创建者构建的复杂对象，包含多个部件；</p>
</blockquote>
<h3 id="2-1-4-示例代码"><a href="#2-1-4-示例代码" class="headerlink" title="2.1.4 示例代码"></a>2.1.4 示例代码</h3><p>1、生成器接口定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Builder.java v 0.1 2023/2/2 00:44 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 生成器接口，定义创建一个产品对象所需的各个部件的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Builder</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，构建某个部件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildPart</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、生成器实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConcreteBuilder.java v 0.1 2023/2/2 00:46 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 具体的生成器实现对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成器最终构建的产品对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Product resultProduct;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取生成器最终构建的产品对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 生成器最终构建的产品对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> resultProduct;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPart</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//构建某个部件的功能处理</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、产品对象接口定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Product.java v 0.1 2023/2/2 00:46 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 被构建的产品对象的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="comment">//定义产品的操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、指导者示意：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Director.java v 0.1 2023/2/2 00:49 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 指导者，指导使用生成器的接口来构建产品的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有当前需要使用的生成器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入生成器对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder 生成器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> {</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，指导生成器构建最终的产品对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//通过使用生成器接口来构建最终的产品对象</span></span><br><span class="line">        builder.buildPart();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-2-重写方案"><a href="#2-2-重写方案" class="headerlink" title="2.2 重写方案"></a>2.2 重写方案</h2><p>生成器模式重写实例的结构图：</p>
<img src="/2023/01/31/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20230202234107504.png" alt="image-20230202234107504" style="zoom:50%;">

<p>1、文件头：<code>ExportHeaderModel</code>、文件体：<code>ExportDataModel</code>、文件尾：<code>ExportFooterModel</code>，与前述的定义的一致；</p>
<p>2、<code>Builder</code> 接口定义：将导出各种格式文件的处理过程</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Builder.java v 0.1 2023/2/2 23:47 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 生成器接口，定义创建一个输出文件对象所需的各个部件的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Builder</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建输出文件的Header部分</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ehm 文件头的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildHeader</span><span class="params">(ExportHeaderModel ehm)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建输出文件的Body部分</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapData 要输出的数据的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">(Map&lt;String, Collection&lt;ExportDataModel&gt;&gt; mapData)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建输出文件的Footer部分</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> efm 文件尾的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildFooter</span><span class="params">(ExportFooterModel efm)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、具体生成器的实现</p>
<p>文本格式：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> TxtBuilder.java v 0.1 2023/2/2 23:50 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 实现导出数据到文本文件的的生成器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxtBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来记录构建的文件的内容，相当于产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHeader</span><span class="params">(ExportHeaderModel ehm)</span> {</span><br><span class="line">        stringBuilder.append(ehm.getDepId()).append(<span class="string">","</span>).append(ehm.getExportDate()).append(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">(Map&lt;String, Collection&lt;ExportDataModel&gt;&gt; mapData)</span> {</span><br><span class="line">        <span class="keyword">for</span> (String tblName : mapData.keySet()) {</span><br><span class="line">            <span class="comment">//先拼接表名称</span></span><br><span class="line">            stringBuilder.append(tblName).append(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="comment">//然后循环拼接具体数据</span></span><br><span class="line">            <span class="keyword">for</span> (ExportDataModel edm : mapData.get(tblName)) {</span><br><span class="line">                stringBuilder.append(edm.getProductId())</span><br><span class="line">                        .append(<span class="string">","</span>).append(edm.getPrice())</span><br><span class="line">                        .append(<span class="string">","</span>).append(edm.getAmount()).append(<span class="string">"\n"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFooter</span><span class="params">(ExportFooterModel efm)</span> {</span><br><span class="line">        stringBuilder.append(efm.getExportUser());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">getResult</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>xml</code> 格式：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> XmlBuilder.java v 0.1 2023/2/2 23:55 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 实现导出数据到XML文件的的生成器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来记录构建的文件的内容，相当于产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHeader</span><span class="params">(ExportHeaderModel ehm)</span> {</span><br><span class="line">        stringBuilder.append(<span class="string">"&lt;?xml version='1.0' encoding='gb2312'?&gt;\n"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"&lt;Report&gt;\n"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"  &lt;Header&gt;\n"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"    &lt;DepId&gt;"</span>).append(ehm.getDepId()).append(<span class="string">"&lt;/DepId&gt;\n"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"    &lt;ExportDate&gt;"</span>).append(ehm.getExportDate()).append(<span class="string">"&lt;/ExportDate&gt;\n"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"  &lt;/Header&gt;\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">(Map&lt;String, Collection&lt;ExportDataModel&gt;&gt; mapData)</span> {</span><br><span class="line">        stringBuilder.append(<span class="string">"  &lt;Body&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String tblName : mapData.keySet()) {</span><br><span class="line">            <span class="comment">//先拼接表名称</span></span><br><span class="line">            stringBuilder.append(<span class="string">"    &lt;Datas TableName=\""</span>).append(tblName).append(<span class="string">"\"&gt;\n"</span>);</span><br><span class="line">            <span class="comment">//然后循环拼接具体数据</span></span><br><span class="line">            <span class="keyword">for</span> (ExportDataModel edm : mapData.get(tblName)) {</span><br><span class="line">                stringBuilder.append(<span class="string">"      &lt;Data&gt;\n"</span>);</span><br><span class="line">                stringBuilder.append(<span class="string">"        &lt;ProductId&gt;"</span>).append(edm.getProductId()).append(<span class="string">"&lt;/ProductId&gt;\n"</span>);</span><br><span class="line">                stringBuilder.append(<span class="string">"        &lt;Price&gt;"</span>).append(edm.getPrice()).append(<span class="string">"&lt;/Price&gt;\n"</span>);</span><br><span class="line">                stringBuilder.append(<span class="string">"        &lt;Amount&gt;"</span>).append(edm.getAmount()).append(<span class="string">"&lt;/Amount&gt;\n"</span>);</span><br><span class="line">                stringBuilder.append(<span class="string">"      &lt;/Data&gt;\n"</span>);</span><br><span class="line">            }</span><br><span class="line">            stringBuilder.append(<span class="string">"    &lt;/Datas&gt;\n"</span>);</span><br><span class="line">        }</span><br><span class="line">        stringBuilder.append(<span class="string">"  &lt;/Body&gt;\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFooter</span><span class="params">(ExportFooterModel efm)</span> {</span><br><span class="line">        stringBuilder.append(<span class="string">"  &lt;Footer&gt;\n"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"    &lt;ExportUser&gt;"</span>).append(efm.getExportUser()).append(<span class="string">"&lt;/ExportUser&gt;\n"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"  &lt;/Footer&gt;\n"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"&lt;/Report&gt;\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">getResult</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、指导者：指导具体的产品构建</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Director.java v 0.1 2023/2/2 23:59 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 指导者，指导使用生成器的接口来构建输出的文件的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有当前需要使用的生成器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入生成器对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder 生成器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> {</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指导生成器构建最终的输出的文件的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ehm     文件头的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapData 数据的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> efm     文件尾的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">(ExportHeaderModel ehm, Map&lt;String, Collection&lt;ExportDataModel&gt;&gt; mapData, ExportFooterModel efm)</span> {</span><br><span class="line">        <span class="comment">//1：先构建Header</span></span><br><span class="line">        builder.buildHeader(ehm);</span><br><span class="line">        <span class="comment">//2：然后构建Body</span></span><br><span class="line">        builder.buildBody(mapData);</span><br><span class="line">        <span class="comment">//3：然后构建Footer</span></span><br><span class="line">        builder.buildFooter(efm);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、客户端:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/3 00:02 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//准备测试数据</span></span><br><span class="line">        <span class="type">ExportHeaderModel</span> <span class="variable">ehm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportHeaderModel</span>();</span><br><span class="line">        ehm.setDepId(<span class="string">"一分公司"</span>);</span><br><span class="line">        ehm.setExportDate(<span class="string">"2010-05-18"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Collection&lt;ExportDataModel&gt;&gt; mapData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Collection&lt;ExportDataModel&gt;&gt;();</span><br><span class="line">        Collection&lt;ExportDataModel&gt; col = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ExportDataModel&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExportDataModel</span> <span class="variable">edm1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportDataModel</span>();</span><br><span class="line">        edm1.setProductId(<span class="string">"产品001号"</span>);</span><br><span class="line">        edm1.setPrice(<span class="number">100</span>);</span><br><span class="line">        edm1.setAmount(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExportDataModel</span> <span class="variable">edm2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportDataModel</span>();</span><br><span class="line">        edm2.setProductId(<span class="string">"产品002号"</span>);</span><br><span class="line">        edm2.setPrice(<span class="number">99</span>);</span><br><span class="line">        edm2.setAmount(<span class="number">55</span>);</span><br><span class="line">        <span class="comment">//把数据组装起来</span></span><br><span class="line">        col.add(edm1);</span><br><span class="line">        col.add(edm2);</span><br><span class="line">        mapData.put(<span class="string">"销售记录表"</span>, col);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExportFooterModel</span> <span class="variable">efm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportFooterModel</span>();</span><br><span class="line">        efm.setExportUser(<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试输出到文本文件</span></span><br><span class="line">        <span class="type">TxtBuilder</span> <span class="variable">txtBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TxtBuilder</span>();</span><br><span class="line">        <span class="comment">//创建指导者对象</span></span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(txtBuilder);</span><br><span class="line">        director.construct(ehm, mapData, efm);</span><br><span class="line">        <span class="comment">//把要输出的内容输出到控制台看看</span></span><br><span class="line">        System.out.println(<span class="string">"输出到文本文件的内容：\n"</span> + txtBuilder.getResult());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//测试输出到xml文件</span></span><br><span class="line">        <span class="type">XmlBuilder</span> <span class="variable">xmlBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBuilder</span>();</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(xmlBuilder);</span><br><span class="line">        director2.construct(ehm, mapData, efm);</span><br><span class="line">        <span class="comment">//把要输出的内容输出到控制台看看</span></span><br><span class="line">        System.out.println(<span class="string">"输出到XML文件的内容：\n"</span> + xmlBuilder.getResult());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生成器的优势：<strong>对同一构建过程，只要配置不同的生成器实现，就会生成不同表现的对象</strong>。</p>
<h1 id="3-模式讲解"><a href="#3-模式讲解" class="headerlink" title="3 模式讲解"></a>3 模式讲解</h1><h2 id="3-1-认识生成器模式"><a href="#3-1-认识生成器模式" class="headerlink" title="3.1 认识生成器模式"></a>3.1 认识生成器模式</h2><p>生成器模式的主要功能是：构建复杂的产品，而且是细化的、分步骤的构建产品，即，生成器模式重在解决一步一步构造复杂对象的问题。更为重要的是，这个构建的过程是统一的，固定不变的，变化的部分放在了生成器部分，只要配置不同的生成器，那么同样的构建过程，就能构建出不同的产品表示出来。</p>
<p>简而言之，生成器模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用，具体的构造实现可以很方便的拓展课切换，通过灵活的的组合来构造出不同的产品对象。</p>
<h3 id="生成器模式的构成"><a href="#生成器模式的构成" class="headerlink" title="生成器模式的构成"></a>生成器模式的构成</h3><p>主要的两部分：</p>
<blockquote>
<p><code>Builder</code> 接口：定义了如何构建各个部件，即，指导每个部件功能如何实现，以及如何装配这些部件到产品中去；</p>
<p><code>Direcotr</code>：指导如何组合来构建产品，负责整体的构建算法，一般是分步骤来执行</p>
</blockquote>
<p>无论模式如何变化，都存在这两个部分，认识这点很重要，因为在生成器模式中，强调的是固定整体构建的算法，而灵活扩展和切换部件的具体构造和产品装配的方式，所以要严格区分这两个部分。</p>
<p>在 <code>Director</code> 实现整体构建算法的时候，遇到需要创建和组合具体部件的时候，就会把这些功能通过委托，交给 <code>Builder</code> 去完成。</p>
<h2 id="3-2-实现的要点"><a href="#3-2-实现的要点" class="headerlink" title="3.2 实现的要点"></a>3.2 实现的要点</h2><h3 id="3-2-1-生成器Builder"><a href="#3-2-1-生成器Builder" class="headerlink" title="3.2.1 生成器Builder"></a>3.2.1 生成器 <code>Builder</code></h3><p>实际上在 <code>Builder</code> 接口的实现中，每个部件构建的方法里面，除了部件装配外，也可以实现如何具体的创建各个部件对象，即，<strong>每个方法都可以有两部分功能，一个是创建部件对象，一个是组装部件</strong>。</p>
<p>在构建部件的方法里面可以<strong>实现选择并创建具体的部件对象，然后再把这个部件对象组装到产品对象中去，这样一来，<code>Builder</code> 就可以和工厂方法配合使用</strong>。</p>
<p>再进一步，<strong>如果在实现 <code>Builder</code> 的时候，只有创建对象的功能，而没有组装的功能，那么这个时候 <code>Builder</code> 实现与抽象工厂的实现是类似的</strong>。这时 <code>Builder</code> 接口就类似于抽象工厂的接口，<code>Builder</code> 的具体实现就类似于具体的工厂，而且 <code>Builder</code> 接口里面定义的创建各个部件的方法也是有关联的，这些方法是构建一个复杂对象所需要的部件对象。</p>
<h3 id="3-2-2-指导者Director"><a href="#3-2-2-指导者Director" class="headerlink" title="3.2.2 指导者Director"></a>3.2.2 指导者 <code>Director</code></h3><p>在生成器模式里面，<strong>指导者承担的是整体构建算法部分，是相对不变的部分</strong>。因此在实现指导者的时候，把变化的部分分离出去是很重要的。</p>
<p>其实指导者分离出去的变化部分，就到了生成器那边，<strong>指导者知道整体的构建算法，就是不知道如何具体的创建和装配部件对象</strong>。</p>
<p>因此真正的指导者实现，并不仅仅是如同前面示例那样，简单的按照一定顺序调用生成器的方法来生成对象，并没有这么简单。<strong>应该是有较为复杂的算法和运算过程，在运算过程中根据需要，才会调用生成器的方法来生成部件对象</strong>。</p>
<h3 id="3-2-2-指导者和生成器的交互"><a href="#3-2-2-指导者和生成器的交互" class="headerlink" title="3.2.2 指导者和生成器的交互"></a>3.2.2 指导者和生成器的交互</h3><p>在生成器模式里面，指导者和生成器的交互，是通过生成器的 <code>buildPart</code> 方法来完成。在前面的示例中，指导者和生成器是没有太多相互交互的，指导者仅仅只是简单的调用了一下生成器的方法，在实际开发中，比这要复杂。如：</p>
<blockquote>
<p>在运行指导者的时候，会按照整体构建算法的步骤进行运算，可能先运行前几步运算，<strong>到了某一步骤，需要具体创建某个部件对象了，然后就调用 <code>Builder</code> 中创建相应部件的方法来创建具体的部件</strong>。同时，把前面运算得到的数据传递给 <code>Builder</code>，因为在 <code>Builder</code> 内部实现创建和组装部件的时候，可能会需要这些数据；</p>
<p><code>Builder</code> 创建完具体的部件对象后，会<strong>把创建好的部件对象返回给指导者，指导者继续后续的算法运算，可能会用到已经创建好的对象</strong>；</p>
<p>如此反复下去，直到整个构建算法运行完成。</p>
</blockquote>
<h3 id="3-2-3-生成器返回装配好的产品和方法"><a href="#3-2-3-生成器返回装配好的产品和方法" class="headerlink" title="3.2.3 生成器返回装配好的产品和方法"></a>3.2.3 生成器返回装配好的产品和方法</h3><p><strong>在标准的生成器模式里面，在 <code>Builder</code> 实现里面会提供一个返回装配好的产品的方法，在 <code>Builder</code> 接口上是没有的</strong>。它考虑的是最终的对象一定要通过部件构建和装配，才算真正创建了，而具体干活的就是这个 <code>Builder</code> 实现，虽然指导者也参与了，<strong>但是指导者是不负责具体的部件创建和组装的</strong>，因此客户端是从 <code>Builder</code> 实现里面获取最终装配好的产品。</p>
<h3 id="3-2-4-被构建产品的接口"><a href="#3-2-4-被构建产品的接口" class="headerlink" title="3.2.4 被构建产品的接口"></a>3.2.4 被构建产品的接口</h3><p>在使用生成器模式的时候，大多数情况下是不知道最终构建出来的产品是什么样的，所以<strong>在标准的生成器模式里面，一般是不需要对产品定义抽象接口</strong>，因为最终构造的产品千差万别，给这些产品定义公共接口几乎是没有意义的。</p>
<h2 id="3-3-生成器模式构建复杂对象"><a href="#3-3-生成器模式构建复杂对象" class="headerlink" title="3.3 生成器模式构建复杂对象"></a>3.3 生成器模式构建复杂对象</h2><p>考虑这样一个实际应用，要创建一个保险合同的对象，里面很多属性的值都有约束，要求创建出来的对象是满足这些约束规则的。约束规则比如：保险合同通常情况下可以和个人签订，也可以和某个公司签订，但是一份保险合同不能同时与个人和公司签订。这个对象里面有很多类似这样的约束，该如何来创建这个对象？</p>
<p>要想简洁直观、安全性好、又具有很好的拓展性的来创建这个对象的话，<strong>一个很好的选择就是使用 <code>Builder</code> 模式，把复杂的创建过程通过 <code>Buidler</code> 来实现</strong>。</p>
<p><strong>采用 <code>Builder</code> 模式来构建复杂的对象，通常会对 <code>Builder</code> 模式进行一定的简化，因为目标明确，就是创建某个复杂对象</strong>，因此做适当简化会使程序更简洁，大致简化如下：</p>
<blockquote>
<ol>
<li>由于是用 <code>Builder</code> 模式来创建某个对象，因此就没有必要再定义一个 <code>Builder</code> 接口，直接提供一个具体的构建器类就可以了；</li>
<li>对于创建一个复杂的对象，可能会有很多种不同的选择和步骤，干脆去掉 “指导者”，把指导者的功能和 <code>Client</code> 的功能合并起来，也就是说，<code>Client</code> 这个时候就相当于指导者，它来指导构建器类去构建需要的复杂对象；</li>
</ol>
</blockquote>
<p>还是来看看示例会比较清楚，为了实例简单，先不去考虑约束的实现，只是考虑如何通过 <code>Builder</code> 模式来构建复杂对象。</p>
<h3 id="1、使用Builder模式构建复杂对象（不考虑约束）"><a href="#1、使用Builder模式构建复杂对象（不考虑约束）" class="headerlink" title="1、使用Builder模式构建复杂对象（不考虑约束）"></a>1、使用 <code>Builder</code> 模式构建复杂对象（不考虑约束）</h3><p>（a）保险合同对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> InsuranceContract.java v 0.1 2023/2/5 23:07 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 保险合同的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsuranceContract</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保险合同编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String contractId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被保险人员的名称，同一份保险合同，要么跟人员签订，要么跟公司签订，</span></span><br><span class="line"><span class="comment">     * 也就是说，"被保险人员"和"被保险公司"这两个属性，不可能同时有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被保险公司的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保险开始生效的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>   beginDate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保险失效的日期，一定会大于保险开始生效的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>   endDate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例：其它数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String otherData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，访问级别是同包能访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InsuranceContract(ConcreteBuilder builder) {</span><br><span class="line">        <span class="built_in">this</span>.contractId = builder.getContractId();</span><br><span class="line">        <span class="built_in">this</span>.personName = builder.getPersonName();</span><br><span class="line">        <span class="built_in">this</span>.companyName = builder.getCompanyName();</span><br><span class="line">        <span class="built_in">this</span>.beginDate = builder.getBeginDate();</span><br><span class="line">        <span class="built_in">this</span>.endDate = builder.getEndDate();</span><br><span class="line">        <span class="built_in">this</span>.otherData = builder.getOtherData();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意：保险合同的某些操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someOperation</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Now in Insurance Contract someOperation=="</span> + <span class="built_in">this</span>.contractId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：构造方法传入的是构建器对象，里面包含有所有保险合同需要的数据。</p>
</blockquote>
<p>（b）构造器的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConcreteBuilder.java v 0.1 2023/2/5 23:08 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 构造保险合同对象的构建器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> {</span><br><span class="line">    <span class="keyword">private</span> String contractId;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>   beginDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>   endDate;</span><br><span class="line">    <span class="keyword">private</span> String otherData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入必须要有的参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> contractId 保险合同编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beginDate  保险开始生效的日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endDate    保险失效的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteBuilder</span><span class="params">(String contractId, <span class="type">long</span> beginDate, <span class="type">long</span> endDate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.contractId = contractId;</span><br><span class="line">        <span class="built_in">this</span>.beginDate = beginDate;</span><br><span class="line">        <span class="built_in">this</span>.endDate = endDate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选填数据，被保险人员的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> personName 被保险人员的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 构建器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ConcreteBuilder <span class="title function_">setPersonName</span><span class="params">(String personName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.personName = personName;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选填数据，被保险公司的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> companyName 被保险公司的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 构建器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ConcreteBuilder <span class="title function_">setCompanyName</span><span class="params">(String companyName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选填数据，其它数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherData 其它数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 构建器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ConcreteBuilder <span class="title function_">setOtherData</span><span class="params">(String otherData)</span> {</span><br><span class="line">        <span class="built_in">this</span>.otherData = otherData;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建真正的对象并返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 构建的保险合同的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> InsuranceContract <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InsuranceContract</span>(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContractId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> contractId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPersonName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> personName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBeginDate</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> beginDate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getEndDate</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> endDate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOtherData</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> otherData;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：构建器提供了类似于 <code>setter</code> 的方法，来供外部设置需要的参数。每个这种方法都有返回值，返回的是构建器对象，这样客户端就可以通过连缀（链式）的方式来使用 <code>Builder</code>，以创建他们需要的对象。</p>
</blockquote>
<p>（c）客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/5 23:09 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//创建构建器</span></span><br><span class="line">        <span class="type">ConcreteBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>(<span class="string">"001"</span>, <span class="number">12345L</span>, <span class="number">67890L</span>);</span><br><span class="line">        <span class="comment">//设置需要的数据，然后构建保险合同对象</span></span><br><span class="line">        <span class="type">InsuranceContract</span> <span class="variable">contract</span> <span class="operator">=</span> builder.setPersonName(<span class="string">"张三"</span>).setOtherData(<span class="string">"test"</span>).build();</span><br><span class="line">        <span class="comment">//操作保险合同对象的方法</span></span><br><span class="line">        contract.someOperation();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2、-使用Builder模式构建复杂对象（考虑约束）"><a href="#2、-使用Builder模式构建复杂对象（考虑约束）" class="headerlink" title="2、 使用Builder模式构建复杂对象（考虑约束）"></a>2、 使用 <code>Builder</code> 模式构建复杂对象（考虑约束）</h3><p>带约束规则构建复杂对象，大致的实现步骤与刚才的实现一直，只是需要在刚才的实现上把约束规则添加上去。</p>
<p>通常有两个地方可以添加约束规则：</p>
<blockquote>
<ol>
<li><strong>在构建器的每一个类似于 <code>setter</code> 的方法</strong>，可以在这里进行单个数据的约束规则校验，如果不正确，就抛出 <code>IllegalStateException</code>；</li>
<li><strong>在构建器的 <code>build</code> 方法</strong>，在创建保险合同对象之前，对所有的数据都可以进行数据的约束规则校验，尤其是那些涉及到几个数据之间的约束关系，在这里校验会比较合适。如果不正确，同样抛出 <code>IllegalStateException</code>；</li>
</ol>
</blockquote>
<p>新的 <code>builder</code> 方法示例</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建真正的对象并返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 构建的保险合同的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> InsuranceContract <span class="title function_">build</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">if</span>(contractId==<span class="literal">null</span> || contractId.trim().length()==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"合同编号不能为空"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">signPerson</span> <span class="operator">=</span> personName!=<span class="literal">null</span> &amp;&amp; personName.trim().length()&gt;<span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">signCompany</span> <span class="operator">=</span> companyName!=<span class="literal">null</span> &amp;&amp; companyName.trim().length()&gt;<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(signPerson &amp;&amp; signCompany){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"一份保险合同不能同时与人和公司签订"</span>);</span><br><span class="line">    }     </span><br><span class="line">    <span class="keyword">if</span>(signPerson==<span class="literal">false</span> &amp;&amp; signCompany==<span class="literal">false</span>){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"一份保险合同不能没有签订对象"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(beginDate&lt;=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"合同必须有保险开始生效的日期"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(endDate&lt;=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"合同必须有保险失效的日期"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(endDate&lt;=beginDate){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"保险失效的日期必须大于保险生效日期"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InsuranceContract</span>(<span class="built_in">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-合并构建对象与被构建对象"><a href="#3-合并构建对象与被构建对象" class="headerlink" title="3 合并构建对象与被构建对象"></a>3 合并构建对象与被构建对象</h3><p>在实际开发中，如果构建器对象和被构建的对象是这样分开的话，<strong>可能会导致同包内的对象不使用构建器来构建对象，而是直接去使用 <code>new</code> 来构建对象，进而会导致错误</strong>；另外，这个构建器的功能就是为了创建被构建的对象，完全可以不用单独一个类。</p>
<p>对于这种情况，<strong>重构的手法通常是将类内联化<code>（Inline Class）</code>，即，就是把构建器对象合并到被构建对象里面去</strong>。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> InsuranceContract.java v 0.1 2023/2/5 23:24 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsuranceContract</span> {</span><br><span class="line">    <span class="keyword">private</span> String contractId;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>   beginDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>   endDate;</span><br><span class="line">    <span class="keyword">private</span> String otherData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，访问级别是私有的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">InsuranceContract</span><span class="params">(ConcreteBuilder builder)</span> {</span><br><span class="line">        <span class="built_in">this</span>.contractId = builder.contractId;</span><br><span class="line">        <span class="built_in">this</span>.personName = builder.personName;</span><br><span class="line">        <span class="built_in">this</span>.companyName = builder.companyName;</span><br><span class="line">        <span class="built_in">this</span>.beginDate = builder.beginDate;</span><br><span class="line">        <span class="built_in">this</span>.endDate = builder.endDate;</span><br><span class="line">        <span class="built_in">this</span>.otherData = builder.otherData;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造保险合同对象的构建器，作为保险合同的类级内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> {</span><br><span class="line">        <span class="keyword">private</span> String contractId;</span><br><span class="line">        <span class="keyword">private</span> String personName;</span><br><span class="line">        <span class="keyword">private</span> String companyName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span>   beginDate;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span>   endDate;</span><br><span class="line">        <span class="keyword">private</span> String otherData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法，传入必须要有的参数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> contractId 保险合同编号</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> beginDate  保险开始生效的日期</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> endDate    保险失效的日期</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ConcreteBuilder</span><span class="params">(String contractId, <span class="type">long</span> beginDate, <span class="type">long</span> endDate)</span> {</span><br><span class="line">            <span class="built_in">this</span>.contractId = contractId;</span><br><span class="line">            <span class="built_in">this</span>.beginDate = beginDate;</span><br><span class="line">            <span class="built_in">this</span>.endDate = endDate;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 选填数据，被保险人员的名称</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> personName 被保险人员的名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 构建器对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> ConcreteBuilder <span class="title function_">setPersonName</span><span class="params">(String personName)</span> {</span><br><span class="line">            <span class="built_in">this</span>.personName = personName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 选填数据，被保险公司的名称</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> companyName 被保险公司的名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 构建器对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> ConcreteBuilder <span class="title function_">setCompanyName</span><span class="params">(String companyName)</span> {</span><br><span class="line">            <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 选填数据，其它数据</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> otherData 其它数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 构建器对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> ConcreteBuilder <span class="title function_">setOtherData</span><span class="params">(String otherData)</span> {</span><br><span class="line">            <span class="built_in">this</span>.otherData = otherData;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构建真正的对象并返回</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 构建的保险合同的对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> InsuranceContract <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (contractId == <span class="literal">null</span> || contractId.trim().length() == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"合同编号不能为空"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">signPerson</span> <span class="operator">=</span> personName != <span class="literal">null</span> &amp;&amp; personName.trim().length() &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">signCompany</span> <span class="operator">=</span> companyName != <span class="literal">null</span> &amp;&amp; companyName.trim().length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (signPerson &amp;&amp; signCompany) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"一份保险合同不能同时与人和公司签订"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (signPerson == <span class="literal">false</span> &amp;&amp; signCompany == <span class="literal">false</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"一份保险合同不能没有签订对象"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (beginDate &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"合同必须有保险开始生效的日期"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (endDate &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"合同必须有保险失效的日期"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (endDate &lt;= beginDate) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"保险失效的日期必须大于保险生效日期"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InsuranceContract</span>(<span class="built_in">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意：保险合同的某些操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someOperation</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Now in Insurance Contract someOperation=="</span> + <span class="built_in">this</span>.contractId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面的示例可以看出，这种实现方式会更简单和直观。此时客户端的写法也发生了一点变化，主要就是创建构造器的地方需要变化，示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/2/5 23:25 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//创建构建器</span></span><br><span class="line">        InsuranceContract.<span class="type">ConcreteBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsuranceContract</span>.ConcreteBuilder(<span class="string">"001"</span>, <span class="number">12345L</span>, <span class="number">67890L</span>);</span><br><span class="line">        <span class="comment">//设置需要的数据，然后构建保险合同对象</span></span><br><span class="line">        <span class="type">InsuranceContract</span> <span class="variable">contract</span> <span class="operator">=</span> builder.setPersonName(<span class="string">"张三"</span>).setOtherData(<span class="string">"test"</span>).build();</span><br><span class="line">        <span class="comment">//操作保险合同对象的方法</span></span><br><span class="line">        contract.someOperation();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-4-生成器模式的优缺点"><a href="#3-4-生成器模式的优缺点" class="headerlink" title="3.4 生成器模式的优缺点"></a>3.4 生成器模式的优缺点</h2><h3 id="1、-松散耦合"><a href="#1、-松散耦合" class="headerlink" title="1、 松散耦合"></a>1、 松散耦合</h3><p><strong>生成器模式可以用同一个构建算法，构建出表现上完全不同的产品，实现产品构建和产品表现上的分离。</strong>生成器模式正是把产品构建的过程独立出来，使它和具体产品的表现松散耦合，从而使得构建算法可以复用，而具体产品表现也可以灵活的、方便的拓展和切换。</p>
<h3 id="2、灵活低改变产品的内部表示"><a href="#2、灵活低改变产品的内部表示" class="headerlink" title="2、灵活低改变产品的内部表示"></a>2、灵活低改变产品的内部表示</h3><p>在生成器模式中，由于 <code>Builder</code> 对象只是提供接口给 <code>Director</code> 使用，那么具体的部件创建和装配方式是被 <code>Builder</code> 接口隐藏，<code>Director</code> 并不知道这些具体的实现细节。这样一来，<strong>要想改变产品的内部表示，只需要切换 <code>Builder</code> 的具体实现即可，不用管 <code>Director</code>。</strong></p>
<h3 id="3、更高的复用性"><a href="#3、更高的复用性" class="headerlink" title="3、更高的复用性"></a>3、更高的复用性</h3><p><strong>生成器模式很好实现了构建算法和具体产品实现的分离</strong>，这样一来，<strong>使得构建产品的算法可以复用</strong>。同样的道理，具体产品的实现也可以复用，同一个产品的实现，可以配合不同的构建算法使用。</p>
<h2 id="3-5-思考"><a href="#3-5-思考" class="headerlink" title="3.5 思考"></a>3.5 思考</h2><h3 id="3-5-1-生成器模式的本质"><a href="#3-5-1-生成器模式的本质" class="headerlink" title="3.5.1 生成器模式的本质"></a>3.5.1 生成器模式的本质</h3><p>本质：分离整体构建算法和部件构造。</p>
<p>构建一个复杂的对象，本来就有构建的过程，以及构建过程中具体的实现，生成器模式就是用来分离这两个部分，从而使得程序结构更松散、扩展更容易、复用性更好，同时也会使得代码更清晰，意图更明确。</p>
<p>虽然在生成器模式的整体构建算法中，会一步一步引导 <code>Builder</code> 来构建对象，但这<strong>并不是说生成器就主要是用来实现分步骤构建对象的</strong>。生成器模式的重心还是在于分离整体构建算法和部件构造，<strong>而分步骤构建对象不过是整体构建算法的一个简单表现，或者说是一个附带产物</strong>。</p>
<h3 id="3-5-2-使用场景"><a href="#3-5-2-使用场景" class="headerlink" title="3.5.2 使用场景"></a>3.5.2 使用场景</h3><ol>
<li><strong>如果创建对象的算法</strong>，应该独立于该对象的组成部分以及它们的装配方式时；</li>
<li><strong>如果同一个构建过程有着不同的表示时；</strong></li>
</ol>
<h2 id="3-6-相关模式"><a href="#3-6-相关模式" class="headerlink" title="3.6 相关模式"></a>3.6 相关模式</h2><h3 id="3-6-1-生成器模式与工厂方法模式"><a href="#3-6-1-生成器模式与工厂方法模式" class="headerlink" title="3.6.1 生成器模式与工厂方法模式"></a>3.6.1 生成器模式与工厂方法模式</h3><p>这两个模式可以组合使用。生成器模式的 <code>Builder</code> 实现中，通常需要选择具体的部件实现，<strong>一个可行的方案就是实现成为工厂方法，通过工厂方法来获取具体的部件对象，然后再进行部件的装配。</strong></p>
<h3 id="3-6-2-生成器模式与抽象工厂模式"><a href="#3-6-2-生成器模式与抽象工厂模式" class="headerlink" title="3.6.2 生成器模式与抽象工厂模式"></a>3.6.2 生成器模式与抽象工厂模式</h3><p>这两个模式既相似又有区别，也可以组合使用。</p>
<p>区别：</p>
<blockquote>
<p><strong>抽象工厂模式的主要目的是创建产品簇</strong>，这个产品簇里面的单个产品，就相当于是构成一个复杂对象的部件对象，<strong>抽象工厂对象创建完成过后就立即返回整个产品簇</strong>；而<strong>生成器模式的主要目的是按照构造算法</strong>，一步一步来构建一个复杂的产品对象，通常要等到整个构建过程结束过后，才会得到最终的产品对象。</p>
</blockquote>
<p>事实上，这两个模式是可以组合使用，在生成器模式的 <code>Builder</code> 实现中，需要创建各个部件对象，而这些部件对象是有关联的，通常是构成一个复杂对象的部件对象，也就是说，<code>Builder</code> 实现中，需要获取构成一个复杂对象的产品簇，那自然就可以使用抽象工厂模式来实现。这样一来，由抽象工厂模式负责了部件对象的创建，<code>Builder</code> 实现里面就主要负责产品对象整体的构建。</p>
<h3 id="3-6-3-生成器模式与模板方法模式"><a href="#3-6-3-生成器模式与模板方法模式" class="headerlink" title="3.6.3 生成器模式与模板方法模式"></a>3.6.3 生成器模式与模板方法模式</h3><p>这也是两个非常类似的模式</p>
<blockquote>
<p><strong>模板方法模式主要是用来定义算法的骨架，把算法中某些步骤延迟到子类中实现。</strong>而生成器模式，<code>Director</code> 用来定义整体的构建算法，把算法中某些涉及到具体部件对象的创建和装配的功能，委托给具体的 <code>Builder</code> 来实现。</p>
</blockquote>
<p>虽然生成器不是延迟到子类，是委托给 <code>Builder</code>，但那只是具体实现方式上的差别，<strong>从实质上看两个模式很类似，都是定义一个固定的算法骨架，然后把算法中的某些具体步骤交给其它类来完成，都能实现整体算法步骤和某些具体步骤实现的分离。</strong></p>
<p>具体区别：</p>
<blockquote>
<p>目的：生成器模式是用来构建复杂对象的，而模板方法是用来定义算法骨架，尤其是一些复杂的业务功能的处理算法的骨架；</p>
<p>实现：生成器模式是采用委托的方法，而模板方法是采用的继承的方式；</p>
<p>使用的复杂度：生成器模式需要组合 <code>Director</code> 和 <code>Builder</code> 对象，然后才能开始构建，要等构建完后才能获得最终的对象，而模板方法就没有这么麻烦，直接使用子类对象即可。</p>
</blockquote>
<h3 id="3-6-4-生成器模式与组合模式"><a href="#3-6-4-生成器模式与组合模式" class="headerlink" title="3.6.4 生成器模式与组合模式"></a>3.6.4 生成器模式与组合模式</h3><p>两个模式可以组合使用，对于复杂的组合结构，可以使用生成器模式一步一步构建。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>创建型模式</tag>
        <tag>生成器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2023/03/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实际场景"><a href="#1-实际场景" class="headerlink" title="1 实际场景"></a>1 实际场景</h1><h2 id="1-1-日志管理系统"><a href="#1-1-日志管理系统" class="headerlink" title="1.1 日志管理系统"></a>1.1 日志管理系统</h2><p>考虑一个记录日志的应用，由于用户对日志记录的要求很高，使得开发人员不能简单的采用一些已有的日志工具或日志框架来满足用户的要求，而需要按照用户的要求重新开发新的日志管理系统。为案例展示，只是抽取跟适配器模式相关的部分来讲述。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h3 id="日志以文件的形式记录"><a href="#日志以文件的形式记录" class="headerlink" title="日志以文件的形式记录"></a>日志以文件的形式记录</h3><p>1、先简单定义日志对象，也就是描述日志的对象模型，由于这个对象需要被写入文件中，因此这个对象需要序列化，示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> LogModel.java v 0.1 2023/3/1 23:15 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 日志数据对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogModel</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String logId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String operateUser;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作时间，以yyyy-MM-dd HH:mm:ss的格式记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String operateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String logContent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLogId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> logId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogId</span><span class="params">(String logId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.logId = logId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOperateUser</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> operateUser;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOperateUser</span><span class="params">(String operateUser)</span> {</span><br><span class="line">        <span class="built_in">this</span>.operateUser = operateUser;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOperateTime</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> operateTime;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOperateTime</span><span class="params">(String operateTime)</span> {</span><br><span class="line">        <span class="built_in">this</span>.operateTime = operateTime;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLogContent</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> logContent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogContent</span><span class="params">(String logContent)</span> {</span><br><span class="line">        <span class="built_in">this</span>.logContent = logContent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"LogModel{"</span> +</span><br><span class="line">                <span class="string">"logId='"</span> + logId + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", operateUser='"</span> + operateUser + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", operateTime='"</span> + operateTime + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", logContent='"</span> + logContent + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、操作日志文件的接口</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> LogFileOperateApi.java v 0.1 2023/3/1 23:18 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 日志文件操作接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogFileOperateApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取日志文件，从文件里面获取存储的日志列表对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存储的日志列表对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;LogModel&gt; <span class="title function_">readLogFile</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写日志文件，把日志列表写出到日志文件中去</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 要写到日志文件的日志列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeLogFile</span><span class="params">(List&lt;LogModel&gt; list)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、接口实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> LogFileOperate.java v 0.1 2023/3/1 23:19 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 实现对日志文件的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFileOperate</span> <span class="keyword">implements</span> <span class="title class_">LogFileOperateApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志文件的路径和文件名称，默认是当前项目的根下的AdapterLog.log</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">logFilePathName</span> <span class="operator">=</span> <span class="string">"AdapterLog.log"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入文件的路径和名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logFilePathName 文件的路径和名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogFileOperate</span><span class="params">(String logFilePathName)</span> {</span><br><span class="line">        <span class="comment">//先判断是否传入了文件的路径和名称，如果是，</span></span><br><span class="line">        <span class="comment">//就重新设置操作的日志文件的路径和名称</span></span><br><span class="line">        <span class="keyword">if</span> (logFilePathName != <span class="literal">null</span> &amp;&amp; logFilePathName.trim().length() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.logFilePathName = logFilePathName;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;LogModel&gt; <span class="title function_">readLogFile</span><span class="params">()</span> {</span><br><span class="line">        List&lt;LogModel&gt; list = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">oin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logFilePathName);</span><br><span class="line">            <span class="keyword">if</span> (f.exists()) {</span><br><span class="line">                oin = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f)));</span><br><span class="line">                list = (List&lt;LogModel&gt;) oin.readObject();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (oin != <span class="literal">null</span>) {</span><br><span class="line">                    oin.close();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLogFile</span><span class="params">(List&lt;LogModel&gt; list)</span> {</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logFilePathName);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oout</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            oout = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f)));</span><br><span class="line">            oout.writeObject(list);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                oout.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/3/1 23:26 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//准备日志内容，也就是测试的数据</span></span><br><span class="line">        <span class="type">LogModel</span> <span class="variable">lm1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogModel</span>();</span><br><span class="line">        lm1.setLogId(<span class="string">"001"</span>);</span><br><span class="line">        lm1.setOperateUser(<span class="string">"admin"</span>);</span><br><span class="line">        lm1.setOperateTime(<span class="string">"2010-03-0210:08:18"</span>);</span><br><span class="line">        lm1.setLogContent(<span class="string">"这是一个测试"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;LogModel&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LogModel&gt;();</span><br><span class="line">        list.add(lm1);</span><br><span class="line">        <span class="comment">//创建操作日志文件的对象</span></span><br><span class="line">        <span class="type">LogFileOperateApi</span> <span class="variable">api</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogFileOperate</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//保存日志文件</span></span><br><span class="line">        api.writeLogFile(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取日志文件的内容</span></span><br><span class="line">        List&lt;LogModel&gt; readLog = api.readLogFile();</span><br><span class="line">        System.out.println(<span class="string">"readLog="</span> + readLog);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">readLog=[LogModel{logId=<span class="string">'001'</span>, operateUser=<span class="string">'admin'</span>, operateTime=<span class="string">'2010-03-0210:08:18'</span>, logContent=<span class="string">'这是一个测试'</span>}]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="日志以数据库的形式记录"><a href="#日志以数据库的形式记录" class="headerlink" title="日志以数据库的形式记录"></a>日志以数据库的形式记录</h3><p>1、接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> LogDbOperateApi.java v 0.1 2023/3/1 23:33 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定义操作日志的应用接口，为了示例的简单，只是简单的定义了增删改查的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDbOperateApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lm 需要新增的日志对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createLog</span><span class="params">(LogModel lm)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lm 需要修改的日志对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateLog</span><span class="params">(LogModel lm)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lm 需要删除的日志对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeLog</span><span class="params">(LogModel lm)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所有的日志对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;LogModel&gt; <span class="title function_">getAllLog</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了示例演示方便，暂不实现数据库的接口实现。需求要求日志管理系统同时满足文件以及数据库两种方式？</p>
<h2 id="1-2-有何问题"><a href="#1-2-有何问题" class="headerlink" title="1.2 有何问题"></a>1.2 有何问题</h2><p>当日志管理系统新增数据库的方式时，对于原来文件保存的接口则无法使用。</p>
<p>如何做到使日志管理系统同时支持两种方式？</p>
<blockquote>
<p>几种方式：</p>
<ul>
<li>按照数据库形式的接口，重新实现文件操作形式的操作对象。不应该对于已经实现过的对象，重复实现，违背抽象的逻辑；</li>
<li>修改文件形式的接口，使之适配数据库的形式的接口。会导致原来依赖于此接口的代码都需要同步修改适配；</li>
</ul>
</blockquote>
<h1 id="2-适配器模式"><a href="#2-适配器模式" class="headerlink" title="2 适配器模式"></a>2 适配器模式</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>适配器模式（<code>Adapter Pattern</code>）属于结构型模式。将一个类的接口转换成客户端适配的另外的接口，适配器模式使得原本由于接口不兼容的类，可以通过适配转接而兼容适用。</p>
<h2 id="2-2-适配器模式解决问题思路"><a href="#2-2-适配器模式解决问题思路" class="headerlink" title="2.2 适配器模式解决问题思路"></a>2.2 适配器模式解决问题思路</h2><p>上述案例中，问题的根源在于接口的不兼容，其中功能已经实现，目标只要将接口适配，如此则可以使用两种方式进行日志管理。</p>
<blockquote>
<p>按照适配器模式的实现方式，<strong>可以定义一个类来实现第二版的接口，然后在内部实现的时候，转调第一版已经实现了的功能</strong>，这样就可以通过对象组合的方式，既复用了第一版已有的功能，同时又在接口上满足了第二版调用的要求。完成上述工作的这个类就是适配器。</p>
</blockquote>
<h2 id="2-3-结构说明"><a href="#2-3-结构说明" class="headerlink" title="2.3 结构说明"></a>2.3 结构说明</h2><img src="/2023/03/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20230305213625383.png" alt="image-20230305213625383" style="zoom: 50%;">

<blockquote>
<ul>
<li><code>Client</code>：客户端；</li>
<li><code>Target</code>：客户端交互的特定领域的相关接口；</li>
<li><code>Adaptee</code>：已经存在的接口，已经实现特定的功能，但是与 <code>Target</code> 接口不一致，需要被适配的对象；</li>
<li><code>Adapter</code>：适配器，将 <code>Adaptee</code> 适配为 <code>Client</code> 需要的 <code>Target</code>；</li>
</ul>
</blockquote>
<h2 id="2-4-示例代码"><a href="#2-4-示例代码" class="headerlink" title="2.4 示例代码"></a>2.4 示例代码</h2><p>1、<code>Target</code> 接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Target.java v 0.1 2023/3/5 21:59 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定义客户端使用的接口，与特定领域相关</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，客户端请求处理的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、需要被适配的对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Adaptee.java v 0.1 2023/3/5 22:00 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 已经存在的接口，这个接口需要被适配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意方法，原本已经存在，已经实现的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 具体的功能处理</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、适配器的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Adapter.java v 0.1 2023/3/5 22:02 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有需要被适配的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入需要被适配的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> adaptee 需要被适配的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> {</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 可能转调已经实现了的方法，进行适配</span></span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/3/5 22:05 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 使用适配器的客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建需被适配的对象</span></span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="comment">// 创建客户端需要调用的接口对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(adaptee);</span><br><span class="line">        <span class="comment">// 请求处理</span></span><br><span class="line">        target.request();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-5-重写方案"><a href="#2-5-重写方案" class="headerlink" title="2.5 重写方案"></a>2.5 重写方案</h2><p>要使用适配器模式来实现示例，关键就是要实现适配器对象，需要实现日志以数据库的形式记录的接口，在内部实现的时候，需要调用日志以文件的形式记录的功能。即，日志以数据库的记录的接口就相当于适配器模式中的 <code>Target</code> 接口，而以文件的形式记录的实现就相当于适配器模式中的 <code>Adaptee</code> 对象。</p>
<p>1、适配器的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Adapter.java v 0.1 2023/3/5 22:16 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 适配器对象，把记录日志到文件的功能适配成DB需要的增删改查的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">LogDbOperateApi</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有需要被适配的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LogFileOperateApi adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(LogFileOperateApi adaptee)</span> {</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        <span class="comment">//1：先读取文件的内容</span></span><br><span class="line">        List&lt;LogModel&gt; list = adaptee.readLogFile();</span><br><span class="line">        <span class="comment">//2：加入新的日志对象</span></span><br><span class="line">        list.add(lm);</span><br><span class="line">        <span class="comment">//3：重新写入文件</span></span><br><span class="line">        adaptee.writeLogFile(list);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        <span class="comment">//1：先读取文件的内容</span></span><br><span class="line">        List&lt;LogModel&gt; list = adaptee.readLogFile();</span><br><span class="line">        <span class="comment">//2：修改相应的日志对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).getLogId().equals(lm.getLogId())) {</span><br><span class="line">                list.set(i, lm);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//3：重新写入文件</span></span><br><span class="line">        adaptee.writeLogFile(list);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        <span class="comment">//1：先读取文件的内容</span></span><br><span class="line">        List&lt;LogModel&gt; list = adaptee.readLogFile();</span><br><span class="line">        <span class="comment">//2：删除相应的日志对象</span></span><br><span class="line">        list.remove(lm);</span><br><span class="line">        <span class="comment">//3：重新写入文件</span></span><br><span class="line">        adaptee.writeLogFile(list);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;LogModel&gt; <span class="title function_">getAllLog</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> adaptee.readLogFile();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、客户端的重写</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2023/3/5 22:19 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//准备日志内容，也就是测试的数据</span></span><br><span class="line">        <span class="type">LogModel</span> <span class="variable">lm1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogModel</span>();</span><br><span class="line">        lm1.setLogId(<span class="string">"001"</span>);</span><br><span class="line">        lm1.setOperateUser(<span class="string">"admin"</span>);</span><br><span class="line">        lm1.setOperateTime(<span class="string">"2010-03-0210:08:18"</span>);</span><br><span class="line">        lm1.setLogContent(<span class="string">"这是一个测试"</span>);</span><br><span class="line">        List&lt;LogModel&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LogModel&gt;();</span><br><span class="line">        list.add(lm1);</span><br><span class="line">        <span class="comment">//创建操作日志文件的对象</span></span><br><span class="line">        <span class="type">LogFileOperateApi</span> <span class="variable">logFileApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogFileOperate</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新版的操作日志的接口对象</span></span><br><span class="line">        <span class="type">LogDbOperateApi</span> <span class="variable">api</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(logFileApi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存日志文件</span></span><br><span class="line">        api.createLog(lm1);</span><br><span class="line">        <span class="comment">//读取日志文件的内容</span></span><br><span class="line">        List&lt;LogModel&gt; allLog = api.getAllLog();</span><br><span class="line">        System.out.println(<span class="string">"allLog="</span> + allLog);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-6-案例图解"><a href="#2-6-案例图解" class="headerlink" title="2.6 案例图解"></a>2.6 案例图解</h2><img src="/2023/03/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20230305232742262.png" alt="image-20230305232742262" style="zoom:50%;">

<h1 id="3-模式讲解"><a href="#3-模式讲解" class="headerlink" title="3 模式讲解"></a>3 模式讲解</h1><h2 id="3-1-认识适配器模式"><a href="#3-1-认识适配器模式" class="headerlink" title="3.1 认识适配器模式"></a>3.1 认识适配器模式</h2><p><strong>适配器模式的主要功能是进行转换匹配，目的是复用已有的功能，而不是来实现新的接口</strong>。即，客户端需要的功能应该是已经实现好了的，不需要适配器模式来实现，适配器模式主要负责把不兼容的接口转换成客户端期望的样子。</p>
<blockquote>
<p>注：适配器里面可以实现功能，<strong>称这种适配器为智能适配器</strong>。同时在接口匹配和转换的过程中，也是有可能需要额外实现一定的功能，才能够转换过来，比如需要调整参数以进行匹配等。</p>
</blockquote>
<h2 id="3-2-实现方式"><a href="#3-2-实现方式" class="headerlink" title="3.2 实现方式"></a>3.2 实现方式</h2><h3 id="1、常见实现"><a href="#1、常见实现" class="headerlink" title="1、常见实现"></a>1、常见实现</h3><p>在实现适配器的时候，适配器通常是一个类，一般会让适配器类去实现 <code>Target</code> 接口，然后在适配器的具体实现里面调用 <code>Adaptee</code>。即，适配器通常是一个 <code>Target</code> 类型，而不是 <code>Adaptee</code> 类型。如同前面的例子演示的那样。</p>
<h3 id="2、智能适配器"><a href="#2、智能适配器" class="headerlink" title="2、智能适配器"></a>2、智能适配器</h3><p>在实际开发中，适配器也可以实现一些 <code>Adaptee</code> 没有的功能，但是在 <code>Target</code> 中定义的功能，这种情况就需要在适配器的实现里面，加入新功能的实现，这种适配器被称为智能适配器。</p>
<p>如果要使用智能适配器，一般新加入的功能的实现，会用到很多 <code>Adaptee</code> 的功能，相当于利用 <code>Adaptee</code> 的功能来实现更高层的功能。当然也可以完全实现新加的功能。</p>
<h3 id="3、适配多个Adaptee"><a href="#3、适配多个Adaptee" class="headerlink" title="3、适配多个Adaptee"></a>3、适配多个 Adaptee</h3><p>实现适配器时，可以适配多个 <code>Adaptee</code>，即，实现某个新的 <code>Target</code> 时，需要调用到多个模块的功能才能满足新接口的需求。</p>
<h3 id="4、缺省适配"><a href="#4、缺省适配" class="headerlink" title="4、缺省适配"></a>4、缺省适配</h3><p>缺省适配：为一个接口提供缺省实现。则不用直接去实现接口，而是采用继承此缺省适配对象，让子类可以有选择的去覆盖需要的方法，对于不需要的接口，则直接使用缺省的适配方法；</p>
<h3 id="5、适配器的复杂度"><a href="#5、适配器的复杂度" class="headerlink" title="5、适配器的复杂度"></a>5、适配器的复杂度</h3><p>适配器 <code>Adapter</code> 实现的复杂度取决于 <code>Target</code> 与 <code>Adaptee</code> 的相似度。</p>
<p>相似度高时：如，只有方法名称不一样，则适配器 <code>Adapter</code> 只需要简单转换一下方法就好，如文章开头的案例。</p>
<p>相似度低时：如，功能方法定义完全不一致，则可能需要使用 <code>Adaptee</code> 中多个方法来组合使用，才能实现出 <code>Target</code> 中一个定义的方法。</p>
<h2 id="3-3-双向适配器"><a href="#3-3-双向适配器" class="headerlink" title="3.3 双向适配器"></a>3.3 双向适配器</h2><p>双向适配器：可以将 <code>Adaptee</code> 适配成 <code>Target</code>，也可以将 <code>Target</code> 适配成 <code>Adaptee</code>。</p>
<p>如文章开头的案例中，既可以将文件形式管理日志适配成数据库的形式，也可以将数据库的形式适配成日志形式。</p>
<img src="/2023/03/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20230305233136185.png" alt="image-20230305233136185" style="zoom:50%;">

<p>1、数据形式管理日志的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * DB存储日志的实现，为了简单，这里就不去真的实现和数据库交互了，示意一下</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogDbOperate</span> <span class="keyword">implements</span> <span class="title class_">LogDbOperateApi</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        System.out.println(<span class="string">"now in LogDbOperate createLog,lm="</span>+lm);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> List&lt;LogModel&gt; <span class="title function_">getAllLog</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"now in LogDbOperate getAllLog"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        System.out.println(<span class="string">"now in LogDbOperate removeLog,lm="</span>+lm);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        System.out.println(<span class="string">"now in LogDbOperate updateLog,lm="</span>+lm);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、双向适配器的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 双向适配器对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoDirectAdapter</span> <span class="keyword">implements</span> <span class="title class_">LogDbOperateApi</span>,LogFileOperateApi{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有需要被适配的文件存储日志的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LogFileOperateApi fileLog;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有需要被适配的DB存储日志的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LogDbOperateApi  dbLog;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入需要被适配的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileLog 需要被适配的文件存储日志的接口对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbLog 需要被适配的DB存储日志的接口对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoDirectAdapter</span><span class="params">(LogFileOperateApi fileLog, LogDbOperateApi dbLog)</span> {</span><br><span class="line">        <span class="built_in">this</span>.fileLog = fileLog;</span><br><span class="line">        <span class="built_in">this</span>.dbLog = dbLog;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*-----以下是把文件操作的方式适配成为DB实现方式的接口-----*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        <span class="comment">//1：先读取文件的内容</span></span><br><span class="line">        List&lt;LogModel&gt; list = fileLog.readLogFile();</span><br><span class="line">        <span class="comment">//2：加入新的日志对象</span></span><br><span class="line">        list.add(lm);</span><br><span class="line">        <span class="comment">//3：重新写入文件</span></span><br><span class="line">        fileLog.writeLogFile(list);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> List&lt;LogModel&gt; <span class="title function_">getAllLog</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> fileLog.readLogFile();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        <span class="comment">//1：先读取文件的内容</span></span><br><span class="line">        List&lt;LogModel&gt; list = fileLog.readLogFile();</span><br><span class="line">        <span class="comment">//2：删除相应的日志对象</span></span><br><span class="line">        list.remove(lm);</span><br><span class="line">        <span class="comment">//3：重新写入文件</span></span><br><span class="line">        fileLog.writeLogFile(list);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLog</span><span class="params">(LogModel lm)</span> {</span><br><span class="line">        <span class="comment">//1：先读取文件的内容</span></span><br><span class="line">        List&lt;LogModel&gt; list = fileLog.readLogFile();</span><br><span class="line">        <span class="comment">//2：修改相应的日志对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(list.get(i).getLogId().equals(lm.getLogId())){</span><br><span class="line">                list.set(i, lm);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//3：重新写入文件</span></span><br><span class="line">        fileLog.writeLogFile(list);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*-----以下是把DB操作的方式适配成为文件实现方式的接口-----*/</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;LogModel&gt; <span class="title function_">readLogFile</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> dbLog.getAllLog();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLogFile</span><span class="params">(List&lt;LogModel&gt; list)</span> {</span><br><span class="line">        <span class="comment">//1：最简单的实现思路，先删除数据库中的数据</span></span><br><span class="line">        <span class="comment">//2：然后循环把现在的数据加入到数据库中</span></span><br><span class="line">        <span class="keyword">for</span>(LogModel lm : list){</span><br><span class="line">            dbLog.createLog(lm);</span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、客户端实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//准备日志内容，也就是测试的数据</span></span><br><span class="line">        <span class="type">LogModel</span> <span class="variable">lm1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogModel</span>();</span><br><span class="line">        lm1.setLogId(<span class="string">"001"</span>);</span><br><span class="line">        lm1.setOperateUser(<span class="string">"caixukun"</span>);</span><br><span class="line">        lm1.setOperateTime(<span class="string">"2023-03-05 10:08:18"</span>);</span><br><span class="line">        lm1.setLogContent(<span class="string">"这是一个测试"</span>);</span><br><span class="line">        List&lt;LogModel&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LogModel&gt;();</span><br><span class="line">        list.add(lm1);</span><br><span class="line">        <span class="comment">//创建操作日志文件的对象</span></span><br><span class="line">        <span class="type">LogFileOperateApi</span> <span class="variable">fileLogApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogFileOperate</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="type">LogDbOperateApi</span> <span class="variable">dbLogApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogDbOperate</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建经过双向适配后的操作日志的接口对象</span></span><br><span class="line">        <span class="type">LogFileOperateApi</span> <span class="variable">fileLogApi2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoDirectAdapter</span>(fileLogApi,dbLogApi);</span><br><span class="line">        <span class="type">LogDbOperateApi</span> <span class="variable">dbLogApi2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoDirectAdapter</span>(fileLogApi,dbLogApi);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//先测试从文件操作适配到数据库，</span></span><br><span class="line">        <span class="comment">//虽然调用的是数据库的接口，其实是文件操作在实现</span></span><br><span class="line">        dbLogApi2.createLog(lm1);</span><br><span class="line">        List&lt;LogModel&gt; allLog = dbLogApi2.getAllLog();</span><br><span class="line">        System.out.println(<span class="string">"allLog="</span>+allLog);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//再测试从数据库存储适配成文件的接口，</span></span><br><span class="line">        <span class="comment">//也就是调用文件的接口，其实是数据实现</span></span><br><span class="line">        fileLogApi2.writeLogFile(list);</span><br><span class="line">        fileLogApi2.readLogFile();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：</p>
<p>使用适配器有一个潜在的问题：被适配的对象不再兼容 <code>Adaptee</code> 的接口。因为适配器只实现了 <code>Target</code> 接口，所以不是所有 <code>Adaptee</code> 对象可以被使用的地方都可以使用适配器。</p>
<p>而双向适配器则解决了这个问题，双向适配器同时实现了 <code>Target</code> 和 <code>Adaptee</code> 的接口，使得双向适配器可以在 <code>Target</code> 或 <code>Adaptee</code> 被使用的地方使用。</p>
</blockquote>
<h2 id="3-4-适配器模式的优缺点"><a href="#3-4-适配器模式的优缺点" class="headerlink" title="3.4 适配器模式的优缺点"></a>3.4 适配器模式的优缺点</h2><h3 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h3><ul>
<li>更好的复用性：如果功能已经实现，只是接口不兼容，则可以通过适配器模式让代码得到复用，不必重复建设；</li>
<li>更好的可拓展性：实现适配器时，可以调用其它的实现接口，从而自然地拓展系统功能；</li>
</ul>
<h3 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h3><ul>
<li>增加代码复杂度：过多的使用适配器，会让系统层次变模糊凌乱，不容易整体把握；</li>
</ul>
<h2 id="3-5-思考"><a href="#3-5-思考" class="headerlink" title="3.5 思考"></a>3.5 思考</h2><h3 id="1、适配器模式的本质"><a href="#1、适配器模式的本质" class="headerlink" title="1、适配器模式的本质"></a>1、适配器模式的本质</h3><p>本质：转换匹配，复用功能。通过转换调用已有的实现，从而能把已有的实现匹配成需要的接口，使之能满足客户端的需要。<strong>也就是说转换匹配是手段，而复用已有的功能才是目的。</strong></p>
<h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><ul>
<li>若想要使用一个已经实现的功能类，但是接口不符合需求时；</li>
<li>若想要创建一个可以复用的类，但是此类可能与一些不兼容的类一起使用；</li>
<li>若想要使用一些已经存在的子类，但是不可能对每个子类进行适配，可以使用适配器模式直接对这些子类的父类进行适配；</li>
</ul>
<h2 id="3-6-相关模式"><a href="#3-6-相关模式" class="headerlink" title="3.6 相关模式"></a>3.6 相关模式</h2><h3 id="1、适配器模式和抽象工厂模式"><a href="#1、适配器模式和抽象工厂模式" class="headerlink" title="1、适配器模式和抽象工厂模式"></a>1、适配器模式和抽象工厂模式</h3><p>在实现适配器时，通常需要得到被适配的对象，如果被适配的是一个接口，则可以结合一些创建型的设计模式，来的到被适配的对象实例。如：抽象工厂模式、单例模式、工厂方法模式等。</p>
<h3 id="2、适配器模式和代理模式"><a href="#2、适配器模式和代理模式" class="headerlink" title="2、适配器模式和代理模式"></a>2、适配器模式和代理模式</h3><p>适配器模式可以结合代理模式组合使用，在实现适配器的时候，可以通过代理来调用 <code>Adaptee</code>，可以获得更大的灵活性。</p>
<h3 id="3、适配器模式和桥接模式"><a href="#3、适配器模式和桥接模式" class="headerlink" title="3、适配器模式和桥接模式"></a>3、适配器模式和桥接模式</h3><p>这两个模式结构相似，功能完全不同。适配器模式将一个或多个接口进行转换匹配；而桥接模式是让接口与实现部分分离，以便接口与实现可以相对独立的变化。</p>
<h3 id="4、适配器模式和装饰器模式"><a href="#4、适配器模式和装饰器模式" class="headerlink" title="4、适配器模式和装饰器模式"></a>4、适配器模式和装饰器模式</h3><p>从某种意义上讲，适配器模式能模拟实现简单的装饰模式的功能，也就是为已有功能增添功能。</p>
<p>如下适配器模式的实现，想大于在调用 <code>Adaptee</code> 中被适配方法前后增加了显得实现，适配过后，客户端得到的是被拓展过的功能，类似于装饰器模式。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adapterMethod</span><span class="params">()</span>{</span><br><span class="line">      System.out.println(<span class="string">"在调用Adaptee的方法之前完成一定的工作"</span>);</span><br><span class="line">      <span class="comment">//调用Adaptee的相关方法</span></span><br><span class="line">      adaptee.method();</span><br><span class="line">      System.out.println(<span class="string">"在调用Adaptee的方法之后完成一定的工作"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>两种模式最大的不同：一般适配器适配过后需要改变接口，如果不需要改变接口，说明无需适配；而装饰器模式不改变接口，只是增加装饰层。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>结构型模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2023/03/26/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实际场景"><a href="#1-实际场景" class="headerlink" title="1 实际场景"></a>1 实际场景</h1><h2 id="1-1-发送提示信息"><a href="#1-1-发送提示信息" class="headerlink" title="1.1 发送提示信息"></a>1.1 发送提示信息</h2><p>考虑一个<strong>发送提示消息</strong>的实际业务功能。基本所有带业务流程处理的系统都会有这样的功能。</p>
<p>从业务上来看，消息可以分为普通消息、加急消息、特急消息多种。不同的消息类型，业务功能处理逻辑不一样。如：加急消息会在消息上添加加急；特急消息处理在消息上添加特急标识之外，还在会另外发送一条催促的消息。其中发送消息的方式可以分为系统消息，手机消息，邮件等。</p>
<p>如何实现？</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002--> 

<h2 id="1-2-非设计模式的解决方案"><a href="#1-2-非设计模式的解决方案" class="headerlink" title="1.2 非设计模式的解决方案"></a>1.2 非设计模式的解决方案</h2><h3 id="1-2-1-简化版本"><a href="#1-2-1-简化版本" class="headerlink" title="1.2.1 简化版本"></a>1.2.1 简化版本</h3><p>先实现一个简化的功能：消息的类型只有普通类型，发送的方式只有<strong>站内消息</strong>和<strong>邮件</strong>。将问题简单化，方便后续说明。</p>
<ol>
<li><p>由于发送普通消息会有两种不同的实现方式，为了让外部能统一操作，因此，把消息设计成接口，然后由两个不同的实现类，分别实现系统内短消息方式和邮件发送消息的方式。此时系统结构如图所示：</p>
<img src="/2023/03/26/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20240102131358457.png" alt="image-20240102131358457" style="zoom:67%;">
</li>
<li><p>消息的统一接口代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Message.java v 0.1 2023/03/27 23:57 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 消息的统一接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Message</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>两种消息的实现类型代码如下：（这里只是做示意，简单实现消息的类型）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> CommonMessageSMS.java v 0.1 2023/03/27 23:57 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 以站内短消息的方式发送普通消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonMessageSMS</span> <span class="keyword">implements</span> <span class="title class_">Message</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用站内短消息的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> CommonMessageEmail.java v 0.1 2023/03/27 23:58 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 以Email的方式发送普通消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonMessageEmail</span> <span class="keyword">implements</span> <span class="title class_">Message</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用Email的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="1-2-2-增加消息类型"><a href="#1-2-2-增加消息类型" class="headerlink" title="1.2.2 增加消息类型"></a>1.2.2 增加消息类型</h3><p>上述简单版本的示例看着非常简单，若是还需要新增消息类型：<strong>加急信息</strong>，发送方式也是<strong>站内消息</strong>和<strong>邮件</strong>。其中与普通消息不同的是，加急消息会在消息内容中添加加急的前缀，然后在发送消息；另外加急消息会提供监控的方法，用户可以通过这个方法来查询加急消息的处理进度。因此加急消息需要扩展一个新的接口，处理发送消息的基本方法之外，还需要提供监控的功能，系统结构图如下：</p>
<img src="/2023/03/26/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20240102132442529.png" alt="image-20240102132442529" style="zoom:67%;">

<ol>
<li><p>需要扩展的加急消息的接口（监控功能）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> UrgencyMessage.java v 0.1 2023/03/28 00:02 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 加急消息的抽象接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UrgencyMessage</span> <span class="keyword">extends</span> <span class="title class_">Message</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监控某消息的处理过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 被监控的消息的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含监控到的数据对象，这里示意一下，所以用了Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">watch</span><span class="params">(String messageId)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对应的两种消息发送方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> UrgencyMessageSMS.java v 0.1 2023/03/28 00:03 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgencyMessageSMS</span> <span class="keyword">implements</span> <span class="title class_">UrgencyMessage</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        message = <span class="string">"加急："</span> + message;</span><br><span class="line">        System.out.println(<span class="string">"使用站内短消息的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">watch</span><span class="params">(String messageId)</span> {</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> UrgencyMessageEmail.java v 0.1 2023/03/28 00:04 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgencyMessageEmail</span> <span class="keyword">implements</span> <span class="title class_">UrgencyMessage</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        message = <span class="string">"加急："</span> + message;</span><br><span class="line">        System.out.println(<span class="string">"使用Email的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">watch</span><span class="params">(String messageId)</span> {</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>在实现加急消息的实际过程中，一般是让加急消息处理的对象继承普通消息的实现，来满足发送不一样消息内容的需求，这里为了示例结构简单，没有这样做。</li>
</ol>
</li>
</ol>
<h3 id="1-2-2-有何问题"><a href="#1-2-2-有何问题" class="headerlink" title="1.2.2 有何问题"></a>1.2.2 有何问题</h3><p>上述做法中，也能满足需求。假设需要持续添加消息类型：<strong>特级消息</strong>，特级消息是在不同消息的处理基础上，添加催促功能，并且投递消息的方式还是<strong>站内消息</strong>和<strong>邮件</strong>，系统结构图如下：</p>
<p><img src="/2023/03/26/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20240102205620274.png" alt="image-20240102205620274"></p>
<p>通过系统结构图可以看出，通过继承的方式来扩展，会非常不方便。每次添加新的消息类型时，都需要将所有的消息投递方式都实现一遍（<strong>站内消息</strong>和<strong>邮件</strong>）。</p>
<p>若是新增投递方式，则需要对当前所有的消息类型都适配，如下系统结构图，新增了手机的消息投递方式，则需要对每个消息类型的具体实现中添加新的处理逻辑。</p>
<p><img src="/2023/03/26/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20240102210024290.png" alt="image-20240102210024290"></p>
<p>通过上述的例子可以直观地看出，<strong>扩展消息类型相当麻烦，不同的消息具有不同的实现。对于每一类的消息都有不同的发送消息的方式。而且如果要新增消息发送方式的时候，那么就要求所有的消息类型，都实现适配新的发送方式</strong>。</p>
<h1 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2 桥接模式"></a>2 桥接模式</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>适配器模式（<code>Bridge Pattern</code>）属于结构型模式，<strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化</strong>。</p>
<h2 id="2-2-桥接模式解决问题思路"><a href="#2-2-桥接模式解决问题思路" class="headerlink" title="2.2 桥接模式解决问题思路"></a>2.2 桥接模式解决问题思路</h2><p>分析示例，可以消息拆分为两个维度：<strong>消息类型</strong>和<strong>发送消息的方式</strong>，其中消息类型有，普通消息、加急信息、特殊加急信息；发送消息方式有，站内信息、手机短信、Email。关系图如下：</p>
<img src="/2023/03/26/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20240102230839837.png" alt="image-20240102230839837" style="zoom:67%;">

<p>前面分析扩展困难的原因是，消息的抽象和实现是混合在一起的，这就导致其中一个维度变化的话，则会引起另外一个维度的变化。</p>
<p>解决的方法就是将两个维度拆分开来，相互独立，这样可以实现独立的变化，是扩展变得简单。</p>
<p><strong>桥接模式通过引入实现的接口，将实现部分从系统中分离出去，将顶层的抽象接口改成抽象类，在类里面持有一个具体的实现部分的实例，抽象部分与实现部分结合起来</strong>。</p>
<p>这样一来，对于需要发送消息的客户端而言，就只需要创建相应的消息对象，然后调用这个消息对象的方法就可以了，这个消息对象会调用持有的真正的消息发送方式来把消息发送出去。也就是说客户端只是想要发送消息而已，并不想关心具体如何发送。</p>
<h2 id="2-3-结构说明"><a href="#2-3-结构说明" class="headerlink" title="2.3 结构说明"></a>2.3 结构说明</h2><img src="/2023/03/26/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20240102234024753.png" alt="image-20240102234024753" style="zoom:67%;">

<blockquote>
<ul>
<li><code>Abstraction</code> ：抽象部分的接口，通常在这个对象里面维护一个实现部分的对象引用，在抽象对象的方法中调用实现部分的完成，在这个方法中通常都是跟具体的业务相关的方法；</li>
<li><code>RefinedAbstract</code>：扩展抽象部分的接口，通常在这些对象里面，定义与实际业务相关的方法，这些方法中会使用 <code>Abstraction</code> 中定义的方法，也可能需要调用实现部分的对象来完成；</li>
<li><code>Implementor</code>：定义实现部分的接口，这个接口不用和 <code>Abstraction</code> 里面的方法一致，通常是由 <code>Implementor</code> 接口提供基本的操作，而 <code>Abstraction</code> 里面定义的是基于这些基本操作的业务方法，也就是说 <code>Abstraction</code> 定义了基于这些基本操作的较高层次的操作；</li>
<li><code>ConcreteImplementor</code>：实现 <code>Implementor</code> 接口的对象；</li>
</ul>
</blockquote>
<h2 id="2-4-示例代码"><a href="#2-4-示例代码" class="headerlink" title="2.4 示例代码"></a>2.4 示例代码</h2><ol>
<li><p><code>Implementor</code> 接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Implementor.java v 0.1 2023/03/28 23:34 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定义实现部分的接口，可以与抽象部分接口的方法不一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Implementor</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例方法，实现抽象部分需要的某些具体功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>Abstraction</code> 抽象接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Abstraction.java v 0.1 2023/03/28 23:34 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定义抽象部分的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abstraction</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有一个实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Implementor impl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入实现部分的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> impl 实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Abstraction</span><span class="params">(Implementor impl)</span> {</span><br><span class="line">        <span class="built_in">this</span>.impl = impl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例操作，实现一定的功能，可能需要转调实现部分的具体实现方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> {</span><br><span class="line">        impl.operationImpl();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>具体的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConcreteImplementorA.java v 0.1 2023/03/28 23:37 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 真正的具体实现对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//真正的实现</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> ConcreteImplementorB.java v 0.1 2023/03/28 23:38 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 真正的具体实现对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteImplementorB</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//真正的实现</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>扩展 <code>Abstraction</code> 接口的对象实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> RefinedAbstraction.java v 0.1 2023/03/28 23:39 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 扩充由Abstraction定义的接口功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title class_">Abstraction</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefinedAbstraction</span><span class="params">(Implementor impl)</span> {</span><br><span class="line">        <span class="built_in">super</span>(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例操作，实现一定的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">otherOperation</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//实现一定的功能，可能会使用具体实现部分的实现方法，</span></span><br><span class="line">        <span class="comment">//但是本方法更大的可能是使用Abstraction中定义的方法，</span></span><br><span class="line">        <span class="comment">//通过组合使用Abstraction中定义的方法来完成更多的功能</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="2-5-重写方案"><a href="#2-5-重写方案" class="headerlink" title="2.5 重写方案"></a>2.5 重写方案</h2><p>首先将消息的抽象和实现分离出来，分析要实现的功能，抽象部分就是消息类型对应的功能，而实现部分是发送消息的方式。</p>
<h3 id="2-5-1-简化版本"><a href="#2-5-1-简化版本" class="headerlink" title="2.5.1 简化版本"></a>2.5.1 简化版本</h3><p>桥接模式的结构图：</p>
<img src="/2023/03/26/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20240103131622622.png" alt="image-20240103131622622" style="zoom:67%;">

<ol>
<li><p>实现部分 - 定义的接口</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> MessageImplementor.java v 0.1 2024/3/29 13:17 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 实现发送消息的统一接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageImplementor</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>抽象部分 - 定义的接口</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> AbstractMessage.java v 0.1 2024/3/29 13:17 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 抽象的消息对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessage</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有一个实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> MessageImplementor impl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入实现部分的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> impl 实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractMessage</span><span class="params">(MessageImplementor impl)</span> {</span><br><span class="line">        <span class="built_in">this</span>.impl = impl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息，转调实现部分的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        <span class="built_in">this</span>.impl.send(message, toUser);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>具体的实现，即消息的投递方式</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> CommonMessage.java v 0.1 2024/3/29 13:27 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonMessage</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessage</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonMessage</span><span class="params">(MessageImplementor impl)</span> {</span><br><span class="line">        <span class="built_in">super</span>(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        <span class="comment">// 对于普通消息，什么都不干，直接调父类的方法，把消息发送出去就可以了</span></span><br><span class="line">        <span class="built_in">super</span>.sendMessage(message, toUser);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> UrgencyMessage.java v 0.1 2024/3/29 13:27 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgencyMessage</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessage</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UrgencyMessage</span><span class="params">(MessageImplementor impl)</span> {</span><br><span class="line">        <span class="built_in">super</span>(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        <span class="built_in">super</span>.sendMessage(message, toUser);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展自己的新功能：监控某消息的处理过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 被监控的消息的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含监控到的数据对象，这里示意一下，所以用了Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">watch</span><span class="params">(String messageId)</span> {</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>抽象部分的拓展，即消息的类型</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> CommonMessage.java v 0.1 2024/3/29 13:27 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonMessage</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessage</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonMessage</span><span class="params">(MessageImplementor impl)</span> {</span><br><span class="line">        <span class="built_in">super</span>(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        <span class="comment">// 对于普通消息，什么都不干，直接调父类的方法，把消息发送出去就可以了</span></span><br><span class="line">        <span class="built_in">super</span>.sendMessage(message, toUser);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> UrgencyMessage.java v 0.1 2024/3/29 13:27 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgencyMessage</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessage</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UrgencyMessage</span><span class="params">(MessageImplementor impl)</span> {</span><br><span class="line">        <span class="built_in">super</span>(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        <span class="built_in">super</span>.sendMessage(message, toUser);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展自己的新功能：监控某消息的处理过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 被监控的消息的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含监控到的数据对象，这里示意一下，所以用了Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">watch</span><span class="params">(String messageId)</span> {</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="2-5-2-添加功能"><a href="#2-5-2-添加功能" class="headerlink" title="2.5.2 添加功能"></a>2.5.2 添加功能</h3><p>在抽象部分（消息类型）添加一个特级消息，实现部分（消息投递方式）添加一个收集发送消息的方式。</p>
<ol>
<li><p>特急消息的处理类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> SpecialUrgencyMessage.java v 0.1 2024/3/29 13:30 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpecialUrgencyMessage</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessage</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpecialUrgencyMessage</span><span class="params">(MessageImplementor impl)</span> {</span><br><span class="line">        <span class="built_in">super</span>(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        <span class="comment">//还需要增加一条待催促的信息</span></span><br><span class="line">        message = <span class="string">"特急："</span>+message;</span><br><span class="line">        <span class="built_in">super</span>.sendMessage(message, toUser);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hurry</span><span class="params">(String messageId)</span> {</span><br><span class="line">        <span class="comment">//执行催促的业务，发出催促的信息</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>手机消息投递方式的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> MessageMobile.java v 0.1 2024/3/29 13:31 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 以手机短消息的方式发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageMobile</span> <span class="keyword">implements</span> <span class="title class_">MessageImplementor</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用手机短消息的方式，发送消息'"</span>+message+<span class="string">"'给"</span>+toUser);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="2-5-3-功能测试"><a href="#2-5-3-功能测试" class="headerlink" title="2.5.3 功能测试"></a>2.5.3 功能测试</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mark.hct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> Client.java v 0.1 2024/3/29 13:32 Exp $</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//创建具体的实现对象</span></span><br><span class="line">        <span class="type">MessageImplementor</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageSMS</span>();</span><br><span class="line">        <span class="comment">//创建一个普通消息对象</span></span><br><span class="line">        <span class="type">AbstractMessage</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonMessage</span>(impl);</span><br><span class="line">        m.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小马"</span>);</span><br><span class="line">        <span class="comment">//创建一个紧急消息对象</span></span><br><span class="line">        m = <span class="keyword">new</span> <span class="title class_">UrgencyMessage</span>(impl);</span><br><span class="line">        m.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小马"</span>);</span><br><span class="line">        <span class="comment">//创建一个特急消息对象</span></span><br><span class="line">        m = <span class="keyword">new</span> <span class="title class_">SpecialUrgencyMessage</span>(impl);</span><br><span class="line">        m.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小马"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把实现方式切换成手机短消息，然后再实现一遍</span></span><br><span class="line">        impl = <span class="keyword">new</span> <span class="title class_">MessageMobile</span>();</span><br><span class="line">        m = <span class="keyword">new</span> <span class="title class_">CommonMessage</span>(impl);</span><br><span class="line">        m.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小马"</span>);</span><br><span class="line">        m = <span class="keyword">new</span> <span class="title class_">UrgencyMessage</span>(impl);</span><br><span class="line">        m.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小马"</span>);</span><br><span class="line">        m = <span class="keyword">new</span> <span class="title class_">SpecialUrgencyMessage</span>(impl);</span><br><span class="line">        m.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小马"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">使用站内短消息的方式，发送消息<span class="string">'请喝一杯茶'</span>给小马</span><br><span class="line">使用站内短消息的方式，发送消息<span class="string">'请喝一杯茶'</span>给小马</span><br><span class="line">使用站内短消息的方式，发送消息<span class="string">'特急：请喝一杯茶'</span>给小马</span><br><span class="line">使用手机短消息的方式，发送消息<span class="string">'请喝一杯茶'</span>给小马</span><br><span class="line">使用手机短消息的方式，发送消息<span class="string">'请喝一杯茶'</span>给小马</span><br><span class="line">使用手机短消息的方式，发送消息<span class="string">'特急：请喝一杯茶'</span>给小马</span><br></pre></td></tr></tbody></table></figure>

<h1 id="3-模式讲解"><a href="#3-模式讲解" class="headerlink" title="3 模式讲解"></a>3 模式讲解</h1><p>所谓桥接，就是把分离的抽象部分和实现部分进行连接（搭桥）</p>
<blockquote>
<p>在桥接模式中的桥接是单向的，只能是抽象部分对象去使用具体实现部分的对象，不能反过来</p>
</blockquote>
<p>只要让抽象部分拥有实现部分的接口对象，就属于桥接关系，再抽象部分中，就可以通过这个接口来调用具体的实现部分的功能，维护桥接，也就维护了这个关系。</p>
<p>桥接模式的意图：是的抽象和实现可以独立变化，可以分别扩充，两者之间是非常松散的关系，某种角度来讲，抽象和实现部分可以完全分开独立，抽象部分不过是一个使用实现部分对外接口的程序。类似于策略模式，抽象部分需要根据某个策略，来选择真实的实现，<strong>也就是说桥接模式的抽象部分相当于策略模式的上下文</strong>。更原始的就直接类似于面向接口编程，通过接口分离的两个部分而已。但是，<strong>桥接模式的抽象部分，是可以继续扩展和变化，而策略模式只有上下文，是不存在所谓抽象部分</strong>。</p>
<p>那抽象和实现为何还要组合在一起呢？<strong>原因是在抽象部分和实现部分还是存在内部联系，抽象部分的实现通常是需要调用实现部分的功能来实现</strong>。</p>
<h3 id="3-1-退化的桥接模式"><a href="#3-1-退化的桥接模式" class="headerlink" title="3.1 退化的桥接模式"></a>3.1 退化的桥接模式</h3><p>如果 <code>Implementor</code> 仅有一个实现，那么就没有必要创建 <code>Implementor</code> 接口了，这是一种桥接模式退化的情况。这个时候 <code>Abstraction</code> 和 <code>Implementor</code> 是一对一的关系，虽然如此，也还是要保持它们的分离状态，这样的话，它们才不会相互影响，才可以分别扩展。</p>
<h3 id="3-2-桥接实现分析"><a href="#3-2-桥接实现分析" class="headerlink" title="3.2 桥接实现分析"></a>3.2 桥接实现分析</h3><p>如何拆分需求中的抽象部分和实现部分，如上述例子中，谁来负责创建 <code>Implementor</code> 的对象，谁来抽象部分，有以下几种方式：</p>
<p>1、<strong>由抽象部分的对象自己来创建相应的 Implementor 的对象</strong></p>
<p>a. 从外面传递参数比较简单，如上述示例，如果用一个 <code>type</code> 来标识具体采用哪种发送消息的方案，然后在 <code>Abstraction</code> 的构造方法中，根据 <code>type</code> 进行创建；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 抽象的消息对象 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessage</span> {  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 持有一个实现部分的对象 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">protected</span> MessageImplementor impl;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 构造方法，传入选择实现部分的类型  </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> type 传入选择实现部分的类型 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">AbstractMessage</span><span class="params">(<span class="type">int</span> type)</span>{  </span><br><span class="line">          <span class="keyword">if</span>(type==<span class="number">1</span>){  </span><br><span class="line">              <span class="built_in">this</span>.impl = <span class="keyword">new</span> <span class="title class_">MessageSMS</span>();  </span><br><span class="line">          }<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>){  </span><br><span class="line">              <span class="built_in">this</span>.impl = <span class="keyword">new</span> <span class="title class_">MessageEmail</span>();  </span><br><span class="line">          }<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>){  </span><br><span class="line">              <span class="built_in">this</span>.impl = <span class="keyword">new</span> <span class="title class_">MessageMobile</span>();  </span><br><span class="line">          }  </span><br><span class="line">      }     </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 发送消息，转调实现部分的方法 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> message 要发送的消息内容 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> toUser 把消息发送的目的人员 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message,String toUser)</span>{  </span><br><span class="line">          <span class="built_in">this</span>.impl.send(message, toUser);  </span><br><span class="line">      }     </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>b. 对于不需要外部传入参数的情况，那就说明是在 Abstraction 的实现中，根据具体的参数数据来选择相应的 Implementor 对象。有可能在 Abstraction 的构造方法中选，也有可能在具体的方法中选择；</p>
<blockquote>
<p>比如前面的示例，如果发送的消息长度在 100 以内采用手机短消息，长度在 100-1000 采用站内短消息，长度在 1000 以上采用 Email，那么就可以在内部方法中自己判断实现。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessage</span> {  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 构造方法 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">AbstractMessage</span><span class="params">()</span> {  </span><br><span class="line">          <span class="comment">//现在什么都不做了  </span></span><br><span class="line">      }  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 发送消息，转调实现部分的方法 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> message 要发送的消息内容 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> toUser 把消息发送的目的人员 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message,String toUser)</span> {        </span><br><span class="line">          <span class="built_in">this</span>.getImpl(message).send(message, toUser);  </span><br><span class="line">      }  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 根据消息的长度来选择合适的实现 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> message 要发送的消息 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 合适的实现对象 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">protected</span> MessageImplementor <span class="title function_">getImpl</span><span class="params">(String message)</span> {  </span><br><span class="line">          <span class="type">MessageImplementor</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">          <span class="keyword">if</span>(message == <span class="literal">null</span>) {  </span><br><span class="line">              <span class="comment">//如果没有消息，默认使用站内短消息  </span></span><br><span class="line">              impl = <span class="keyword">new</span> <span class="title class_">MessageSMS</span>();  </span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span>(message.length()&lt; <span class="number">100</span>) {  </span><br><span class="line">              <span class="comment">//如果消息长度在100以内，使用手机短消息  </span></span><br><span class="line">              impl = <span class="keyword">new</span> <span class="title class_">MessageMobile</span>();  </span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span>(message.length()&lt;<span class="number">1000</span>) {  </span><br><span class="line">              <span class="comment">//如果消息长度在100-1000以内，使用站内短消息  </span></span><br><span class="line">              impl = <span class="keyword">new</span> <span class="title class_">MessageSMS</span>();  </span><br><span class="line">          } <span class="keyword">else</span> {  </span><br><span class="line">              <span class="comment">//如果消息长度在1000以上  </span></span><br><span class="line">              impl = <span class="keyword">new</span> <span class="title class_">MessageEmail</span>();  </span><br><span class="line">          }  </span><br><span class="line">          <span class="keyword">return</span> impl;  </span><br><span class="line">      }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>总结：优点是客户使用简单，而且集中控制 Implementor 对象的创建和切换逻辑；缺点是要求 Abstraction 知道所有的具体的 Implementor 实现，并知道如何选择和创建它们</p>
<p>2、<strong>在 Abstraction 中创建缺省的 Implementor 对象</strong></p>
<p>对于这种方式，实现比较简单，直接在 <code>Abstraction</code> 的构造方法中，创建一个缺省的 <code>Implementor</code> 对象，然后子类根据需要，看是直接使用还是覆盖掉。示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessage</span> {  </span><br><span class="line">      <span class="keyword">protected</span> MessageImplementor impl;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 构造方法 </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">AbstractMessage</span><span class="params">()</span>{  </span><br><span class="line">          <span class="comment">//创建一个默认的实现  </span></span><br><span class="line">          <span class="built_in">this</span>.impl = <span class="keyword">new</span> <span class="title class_">MessageSMS</span>();  </span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message,String toUser)</span>{  </span><br><span class="line">          <span class="built_in">this</span>.impl.send(message, toUser);  </span><br><span class="line">      }</span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>3、<strong>使用抽象工厂或者是简单工厂</strong></p>
<p>对于这种方式，根据具体的需要来选择，如果是想要创建一系列实现对象，那就使用抽象工厂，如果是创建单个的实现对象，那就使用简单工厂就可以了。</p>
<p>直接在原来创建 <code>Implementor</code> 对象的地方，直接调用相应的抽象工厂或者是简单工厂，来获取相应的 <code>Implementor</code> 对象，这种方法的优点是 <code>Abstraction</code> 类不用和任何一个 <code>Implementor</code> 类直接耦合。</p>
<p>4、<strong>使用 IoC/DI 的方式</strong></p>
<p>对于这种方式，<code>Abstraction</code> 的实现就更简单了，只需要实现注入 <code>Implementor</code> 对象的方法就可以了，其它的 <code>Abstraction</code> 就不管了。</p>
<p><code>IoC/DI</code> 容器会负责创建 <code>Implementor</code> 对象，并设置回到 <code>Abstraction</code> 对象中，使用 <code>IoC/DI</code> 的方式，并不会改变 <code>Abstraction</code> 和 <code>Implementor</code> 的关系，<code>Abstraction</code> 同样需要持有相应的 <code>Implementor</code> 对象，同样会把功能委托给 <code>Implementor</code> 对象去实现。</p>
<h3 id="3-3-桥接模式的优缺点"><a href="#3-3-桥接模式的优缺点" class="headerlink" title="3.3 桥接模式的优缺点"></a>3.3 桥接模式的优缺点</h3><ol>
<li>分离抽象和实现部分：桥接模式分离了抽象和实现部分，从而极大地提高了系统的灵活性。<strong>让抽象部分和实现部分独立开来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。</strong>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了；</li>
<li>更好的扩展性：由于桥接模式把抽象和实现部分分离开了，而且分别定义接口，这就使得抽象部分和实现部分可以分别独立的扩展，而不会相互影响，从而大大的提高了系统的可扩展性。可动态切换实现；</li>
<li>可减少子类的个数：如文章一开头的例子，对于有两个变化纬度的情况，<strong>如果采用继承的实现方式，大约需要两个纬度上的可变化数量的乘积个子类；而采用桥接模式来实现的话，大约需要两个纬度上的可变化数量的和个子类。</strong>可以明显地减少子类的个数；</li>
</ol>
<h3 id="3-3-使用场景"><a href="#3-3-使用场景" class="headerlink" title="3.3 使用场景"></a>3.3 使用场景</h3><ul>
<li>不希望抽象和实现部分使用固定的绑定关系：把抽象和实现部分分开，然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现；</li>
<li>出现抽象部分和实现部分都应该可以扩展的情况：让抽象部分和实现部分可以独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边；</li>
<li>希望实现部分的修改，不会对客户产生影响：客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，说对客户是透明的；</li>
<li>采用继承的实现方案，会导致产生很多子类：可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目；</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>结构型模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
</search>
